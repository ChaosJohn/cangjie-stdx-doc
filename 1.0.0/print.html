<!DOCTYPE HTML>
<html lang="zh-cn" class="light" dir="ltr">
    <head>
            <script type="text/x-mathjax-config">
                MathJax.Hub.Config({
                    showProcessingMessages: false,
                    messageStyle: "none",
                    extensions: ['tex2jax.js'],
                    jax: ['input/TeX', 'output/HTML-CSS'],
                    tex2jax: {
                        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
                        processEscapes: true
                    },
                    "HTML-CSS": { availableFonts: ["STIX", "TeX"] }
                });
            </script>
            
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>仓颉编程语言扩展库 API</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="assets/style.css">
        <link rel="stylesheet" href="assets/theme.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="libs_overview.html"><strong aria-hidden="true">1.</strong> 仓颉编程语言扩展库 API</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="compress/zlib/zlib_package_overview.html"><strong aria-hidden="true">1.1.</strong> stdx.compress.zlib</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="compress/zlib/zlib_package_api/zlib_package_classes.html"><strong aria-hidden="true">1.1.1.</strong> 类</a></li><li class="chapter-item "><a href="compress/zlib/zlib_package_api/zlib_package_enums.html"><strong aria-hidden="true">1.1.2.</strong> 枚举</a></li><li class="chapter-item "><a href="compress/zlib/zlib_package_api/zlib_package_exceptions.html"><strong aria-hidden="true">1.1.3.</strong> 异常类</a></li><li class="chapter-item "><div><strong aria-hidden="true">1.1.4.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="compress/zlib/zlib_samples/deflate_compress_decompress.html"><strong aria-hidden="true">1.1.4.1.</strong> Deflate 格式数据的压缩和解压</a></li><li class="chapter-item "><a href="compress/zlib/zlib_samples/gzip_compress_decompress.html"><strong aria-hidden="true">1.1.4.2.</strong> Gzip 格式数据的压缩和解压</a></li></ol></li></ol></li><li class="chapter-item "><a href="crypto/crypto/crypto_package_overview.html"><strong aria-hidden="true">1.2.</strong> stdx.crypto.crypto</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="crypto/crypto/crypto_package_api/crypto_package_classes.html"><strong aria-hidden="true">1.2.1.</strong> 类</a></li><li class="chapter-item "><a href="crypto/crypto/crypto_package_api/crypto_package_structs.html"><strong aria-hidden="true">1.2.2.</strong> 结构体</a></li><li class="chapter-item "><a href="crypto/crypto/crypto_package_api/crypto_package_exceptions.html"><strong aria-hidden="true">1.2.3.</strong> 异常类</a></li><li class="chapter-item "><div><strong aria-hidden="true">1.2.4.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="crypto/crypto/crypto_samples/sample_secure_random.html"><strong aria-hidden="true">1.2.4.1.</strong> SecureRandom 使用</a></li><li class="chapter-item "><a href="crypto/crypto/crypto_samples/sample_crypto.html"><strong aria-hidden="true">1.2.4.2.</strong> SM4 使用</a></li></ol></li></ol></li><li class="chapter-item "><a href="crypto/digest/crypto_digest_package_overview.html"><strong aria-hidden="true">1.3.</strong> stdx.crypto.digest</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="crypto/digest/digest_package_api/digest_package_classes.html"><strong aria-hidden="true">1.3.1.</strong> 类</a></li><li class="chapter-item "><a href="crypto/digest/digest_package_api/digest_package_structs.html"><strong aria-hidden="true">1.3.2.</strong> 结构体</a></li><li class="chapter-item "><a href="crypto/digest/digest_package_api/digest_package_exceptions.html"><strong aria-hidden="true">1.3.3.</strong> 异常类</a></li><li class="chapter-item "><div><strong aria-hidden="true">1.3.4.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="crypto/digest/digest_samples/sample_digest.html"><strong aria-hidden="true">1.3.4.1.</strong> digest 使用</a></li></ol></li></ol></li><li class="chapter-item "><a href="crypto/keys/keys_package_overview.html"><strong aria-hidden="true">1.4.</strong> stdx.crypto.keys</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="crypto/keys/keys_package_api/keys_package_classes.html"><strong aria-hidden="true">1.4.1.</strong> 类</a></li><li class="chapter-item "><a href="crypto/keys/keys_package_api/keys_package_enums.html"><strong aria-hidden="true">1.4.2.</strong> 枚举</a></li><li class="chapter-item "><a href="crypto/keys/keys_package_api/keys_package_structs.html"><strong aria-hidden="true">1.4.3.</strong> 结构体</a></li><li class="chapter-item "><div><strong aria-hidden="true">1.4.4.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="crypto/keys/keys_samples/sample_keys.html"><strong aria-hidden="true">1.4.4.1.</strong> keys 使用</a></li></ol></li></ol></li><li class="chapter-item "><a href="crypto/x509/x509_package_overview.html"><strong aria-hidden="true">1.5.</strong> stdx.crypto.x509</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="crypto/x509/x509_package_api/x509_package_type.html"><strong aria-hidden="true">1.5.1.</strong> 类型别名</a></li><li class="chapter-item "><a href="crypto/x509/x509_package_api/x509_package_interfaces.html"><strong aria-hidden="true">1.5.2.</strong> 接口</a></li><li class="chapter-item "><a href="crypto/x509/x509_package_api/x509_package_classes.html"><strong aria-hidden="true">1.5.3.</strong> 类</a></li><li class="chapter-item "><a href="crypto/x509/x509_package_api/x509_package_enums.html"><strong aria-hidden="true">1.5.4.</strong> 枚举</a></li><li class="chapter-item "><a href="crypto/x509/x509_package_api/x509_package_structs.html"><strong aria-hidden="true">1.5.5.</strong> 结构体</a></li><li class="chapter-item "><a href="crypto/x509/x509_package_api/x509_package_exceptions.html"><strong aria-hidden="true">1.5.6.</strong> 异常类</a></li><li class="chapter-item "><div><strong aria-hidden="true">1.5.7.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="crypto/x509/x509_samples/sample_x509.html"><strong aria-hidden="true">1.5.7.1.</strong> x509 使用</a></li></ol></li></ol></li><li class="chapter-item "><a href="encoding/base64/base64_package_overview.html"><strong aria-hidden="true">1.6.</strong> stdx.encoding.base64</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="encoding/base64/base64_package_api/base64_package_funcs.html"><strong aria-hidden="true">1.6.1.</strong> 函数</a></li><li class="chapter-item "><div><strong aria-hidden="true">1.6.2.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="encoding/base64/base64_samples/base64.html"><strong aria-hidden="true">1.6.2.1.</strong> Byte 数组和 Base64 互转</a></li></ol></li></ol></li><li class="chapter-item "><a href="encoding/hex/hex_package_overview.html"><strong aria-hidden="true">1.7.</strong> stdx.encoding.hex</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="encoding/hex/hex_package_api/hex_package_funcs.html"><strong aria-hidden="true">1.7.1.</strong> 函数</a></li><li class="chapter-item "><div><strong aria-hidden="true">1.7.2.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="encoding/hex/hex_samples/hex.html"><strong aria-hidden="true">1.7.2.1.</strong> Byte 数组和 Hex 互转</a></li></ol></li></ol></li><li class="chapter-item "><a href="encoding/json/json_package_overview.html"><strong aria-hidden="true">1.8.</strong> stdx.encoding.json</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="encoding/json/json_package_api/encoding_json_package_interfaces.html"><strong aria-hidden="true">1.8.1.</strong> 接口</a></li><li class="chapter-item "><a href="encoding/json/json_package_api/encoding_json_package_classes.html"><strong aria-hidden="true">1.8.2.</strong> 类</a></li><li class="chapter-item "><a href="encoding/json/json_package_api/encoding_json_package_enums.html"><strong aria-hidden="true">1.8.3.</strong> 枚举</a></li><li class="chapter-item "><a href="encoding/json/json_package_api/encoding_json_package_exceptions.html"><strong aria-hidden="true">1.8.4.</strong> 异常类</a></li><li class="chapter-item "><div><strong aria-hidden="true">1.8.5.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="encoding/json/json_samples/json_array_sample.html"><strong aria-hidden="true">1.8.5.1.</strong> JsonArray 使用示例</a></li><li class="chapter-item "><a href="encoding/json/json_samples/json_value_sample.html"><strong aria-hidden="true">1.8.5.2.</strong> JsonValue 和 String 互相转换</a></li><li class="chapter-item "><a href="encoding/json/json_samples/to_json_sample.html"><strong aria-hidden="true">1.8.5.3.</strong> JsonValue 与 DataModel 的转换</a></li></ol></li></ol></li><li class="chapter-item "><a href="encoding/json_stream/json_stream_package_overview.html"><strong aria-hidden="true">1.9.</strong> stdx.encoding.json.stream</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html"><strong aria-hidden="true">1.9.1.</strong> 接口</a></li><li class="chapter-item "><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html"><strong aria-hidden="true">1.9.2.</strong> 类</a></li><li class="chapter-item "><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_enums.html"><strong aria-hidden="true">1.9.3.</strong> 枚举</a></li><li class="chapter-item "><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_structs.html"><strong aria-hidden="true">1.9.4.</strong> 结构体</a></li><li class="chapter-item "><div><strong aria-hidden="true">1.9.5.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="encoding/json_stream/json_stream_samples/sample_json_reader.html"><strong aria-hidden="true">1.9.5.1.</strong> 使用 Json Stream 进行反序列化</a></li><li class="chapter-item "><a href="encoding/json_stream/json_stream_samples/sample_json_writer.html"><strong aria-hidden="true">1.9.5.2.</strong> 使用 Json Stream 进行序列化</a></li><li class="chapter-item "><a href="encoding/json_stream/json_stream_samples/sample_json_writeconfig.html"><strong aria-hidden="true">1.9.5.3.</strong> WriteConfig 使用示例</a></li></ol></li></ol></li><li class="chapter-item "><a href="encoding/url/url_package_overview.html"><strong aria-hidden="true">1.10.</strong> stdx.encoding.url</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="encoding/url/url_package_api/url_package_classes.html"><strong aria-hidden="true">1.10.1.</strong> 类</a></li><li class="chapter-item "><a href="encoding/url/url_package_api/url_package_exceptions.html"><strong aria-hidden="true">1.10.2.</strong> 异常类</a></li><li class="chapter-item "><div><strong aria-hidden="true">1.10.3.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="encoding/url/url_samples/form.html"><strong aria-hidden="true">1.10.3.1.</strong> Form 的构造使用</a></li><li class="chapter-item "><a href="encoding/url/url_samples/url_parse.html"><strong aria-hidden="true">1.10.3.2.</strong> URL 解析函数 parse 的使用</a></li></ol></li></ol></li><li class="chapter-item "><a href="fuzz/fuzz_package_overview.html"><strong aria-hidden="true">1.11.</strong> stdx.fuzz.fuzz</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="fuzz/fuzz_package_api/fuzz_package_constants_vars.html"><strong aria-hidden="true">1.11.1.</strong> 常量变量</a></li><li class="chapter-item "><a href="fuzz/fuzz_package_api/fuzz_package_classes.html"><strong aria-hidden="true">1.11.2.</strong> 类</a></li><li class="chapter-item "><a href="fuzz/fuzz_package_api/fuzz_package_exceptions.html"><strong aria-hidden="true">1.11.3.</strong> 异常类</a></li><li class="chapter-item "><div><strong aria-hidden="true">1.11.4.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="fuzz/fuzz_samples/basic_fuzzing_test.html"><strong aria-hidden="true">1.11.4.1.</strong> 测试猜测字符功能</a></li><li class="chapter-item "><a href="fuzz/fuzz_samples/dataprovider_usage.html"><strong aria-hidden="true">1.11.4.2.</strong> 使用 DataProvider 功能进行测试</a></li><li class="chapter-item "><a href="fuzz/fuzz_samples/fake_coverage_usage.html"><strong aria-hidden="true">1.11.4.3.</strong> 使用 FakeCoverage 避免 DataProvider 模式下 Fuzz 异常终止</a></li><li class="chapter-item "><a href="fuzz/fuzz_samples/print_cj-fuzz_usage.html"><strong aria-hidden="true">1.11.4.4.</strong> 打印 fuzz 使用方法</a></li><li class="chapter-item "><a href="fuzz/fuzz_samples/print_coverage.html"><strong aria-hidden="true">1.11.4.5.</strong> 实验性特性-覆盖率信息打印</a></li><li class="chapter-item "><a href="fuzz/fuzz_samples/stack_backtrace_missing_solution.html"><strong aria-hidden="true">1.11.4.6.</strong> 栈回溯缺失的处理方案</a></li></ol></li></ol></li><li class="chapter-item "><a href="log/log_package_overview.html"><strong aria-hidden="true">1.12.</strong> stdx.log</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="log/log_package_api/log_package_types.html"><strong aria-hidden="true">1.12.1.</strong> 类型别名</a></li><li class="chapter-item "><a href="log/log_package_api/log_package_funcs.html"><strong aria-hidden="true">1.12.2.</strong> 函数</a></li><li class="chapter-item "><a href="log/log_package_api/log_package_interfaces.html"><strong aria-hidden="true">1.12.3.</strong> 接口</a></li><li class="chapter-item "><a href="log/log_package_api/log_package_classes.html"><strong aria-hidden="true">1.12.4.</strong> 类</a></li><li class="chapter-item "><a href="log/log_package_api/log_package_structs.html"><strong aria-hidden="true">1.12.5.</strong> 结构体</a></li><li class="chapter-item "><a href="log/log_package_api/log_package_exceptions.html"><strong aria-hidden="true">1.12.6.</strong> 异常类</a></li><li class="chapter-item "><div><strong aria-hidden="true">1.12.7.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="log/log_samples/log_sample.html"><strong aria-hidden="true">1.12.7.1.</strong> 日志打印示例</a></li></ol></li></ol></li><li class="chapter-item "><a href="logger/logger_package_overview.html"><strong aria-hidden="true">1.13.</strong> stdx.logger</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="logger/logger_package_api/logger_package_classes.html"><strong aria-hidden="true">1.13.1.</strong> 类</a></li><li class="chapter-item "><div><strong aria-hidden="true">1.13.2.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="logger/logger_samples/logger_sample.html"><strong aria-hidden="true">1.13.2.1.</strong> 日志打印示例</a></li></ol></li></ol></li><li class="chapter-item "><a href="net/http/http_package_overview.html"><strong aria-hidden="true">1.14.</strong> stdx.net.http</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="net/http/http_package_api/http_package_funcs.html"><strong aria-hidden="true">1.14.1.</strong> 函数</a></li><li class="chapter-item "><a href="net/http/http_package_api/http_package_interfaces.html"><strong aria-hidden="true">1.14.2.</strong> 接口</a></li><li class="chapter-item "><a href="net/http/http_package_api/http_package_classes.html"><strong aria-hidden="true">1.14.3.</strong> 类</a></li><li class="chapter-item "><a href="net/http/http_package_api/http_package_enums.html"><strong aria-hidden="true">1.14.4.</strong> 枚举</a></li><li class="chapter-item "><a href="net/http/http_package_api/http_package_structs.html"><strong aria-hidden="true">1.14.5.</strong> 结构体</a></li><li class="chapter-item "><a href="net/http/http_package_api/http_package_exceptions.html"><strong aria-hidden="true">1.14.6.</strong> 异常类</a></li><li class="chapter-item "><div><strong aria-hidden="true">1.14.7.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="net/http/http_samples/http_client.html"><strong aria-hidden="true">1.14.7.1.</strong> client</a></li><li class="chapter-item "><a href="net/http/http_samples/cookie.html"><strong aria-hidden="true">1.14.7.2.</strong> cookie</a></li><li class="chapter-item "><a href="net/http/http_samples/log.html"><strong aria-hidden="true">1.14.7.3.</strong> log</a></li><li class="chapter-item "><a href="net/http/http_samples/http_server.html"><strong aria-hidden="true">1.14.7.4.</strong> server</a></li><li class="chapter-item "><a href="net/http/http_samples/webSocket.html"><strong aria-hidden="true">1.14.7.5.</strong> webSocket</a></li></ol></li></ol></li><li class="chapter-item "><a href="net/tls/tls_package_overview.html"><strong aria-hidden="true">1.15.</strong> stdx.net.tls</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="net/tls/tls_package_api/tls_package_classes.html"><strong aria-hidden="true">1.15.1.</strong> 类</a></li><li class="chapter-item "><a href="net/tls/tls_package_api/tls_package_enums.html"><strong aria-hidden="true">1.15.2.</strong> 枚举</a></li><li class="chapter-item "><a href="net/tls/tls_package_api/tls_package_structs.html"><strong aria-hidden="true">1.15.3.</strong> 结构体</a></li><li class="chapter-item "><a href="net/tls/tls_package_api/tls_package_exceptions.html"><strong aria-hidden="true">1.15.4.</strong> 异常类</a></li><li class="chapter-item "><div><strong aria-hidden="true">1.15.5.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="net/tls/tls_samples/cert_key.html"><strong aria-hidden="true">1.15.5.1.</strong> 服务端证书及公钥在一份文件中</a></li><li class="chapter-item "><a href="net/tls/tls_samples/client.html"><strong aria-hidden="true">1.15.5.2.</strong> 客户端示例</a></li><li class="chapter-item "><a href="net/tls/tls_samples/hot_update_cert.html"><strong aria-hidden="true">1.15.5.3.</strong> 证书热更新</a></li><li class="chapter-item "><a href="net/tls/tls_samples/server.html"><strong aria-hidden="true">1.15.5.4.</strong> 服务端示例</a></li></ol></li></ol></li><li class="chapter-item "><a href="serialization/serialization_package_overview.html"><strong aria-hidden="true">1.16.</strong> stdx.serialization.serialization</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="serialization/serialization_package_api/serialization_package_functions.html"><strong aria-hidden="true">1.16.1.</strong> 函数</a></li><li class="chapter-item "><a href="serialization/serialization_package_api/serialization_package_interfaces.html"><strong aria-hidden="true">1.16.2.</strong> 接口</a></li><li class="chapter-item "><a href="serialization/serialization_package_api/serialization_package_classes.html"><strong aria-hidden="true">1.16.3.</strong> 类</a></li><li class="chapter-item "><a href="serialization/serialization_package_api/serialization_package_exceptions.html"><strong aria-hidden="true">1.16.4.</strong> 异常类</a></li><li class="chapter-item "><div><strong aria-hidden="true">1.16.5.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="serialization/serialization_samples/serialize_and_deserialize_class.html"><strong aria-hidden="true">1.16.5.1.</strong> class 序列化和反序列化</a></li><li class="chapter-item "><a href="serialization/serialization_samples/serialize_hashmap_and_hashset.html"><strong aria-hidden="true">1.16.5.2.</strong> HashSet 和 HashMap 序列化</a></li></ol></li></ol></li><li class="chapter-item "><a href="unittest/data/data_package_overview.html"><strong aria-hidden="true">1.17.</strong> stdx.unittest.data</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="unittest/data/data_package_api/data_package_functions.html"><strong aria-hidden="true">1.17.1.</strong> 函数</a></li><li class="chapter-item "><a href="unittest/data/data_package_api/data_package_classes.html"><strong aria-hidden="true">1.17.2.</strong> 类</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">仓颉编程语言扩展库 API</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="仓颉编程语言扩展库-api"><a class="header" href="#仓颉编程语言扩展库-api">仓颉编程语言扩展库 API</a></h1>
<p>仓颉编程语言扩展库（stdx）包含若干包，提供相关功能。</p>
<p>标准库为开发者提供了最通用的 API，而扩展库则专注于某一领域。如 compress 包提供压缩与解压缩能力，crypto 包提供加解密相关能力，net 包则专注于提供高效的网络协议解析和网络通信能力。</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>目前，官方提供的扩展库不随仓颉编译器、工具链一起发布，需要用户单独下载。</p>
</blockquote>
<h2 id="包列表"><a class="header" href="#包列表">包列表</a></h2>
<p>stdx 含若干包，提供了丰富的扩展功能：</p>
<div class="table-wrapper"><table><thead><tr><th>包名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="./compress/zlib/zlib_package_overview.html">compress.zlib</a></td><td>compress 包提供压缩解压功能。</td></tr>
<tr><td><a href="./crypto/crypto/crypto_package_overview.html">crypto.crypto</a></td><td>crypto 包提供安全加密能力。</td></tr>
<tr><td><a href="./crypto/digest/crypto_digest_package_overview.html">crypto.digest</a></td><td>digest 包提供常用的消息摘要算法。</td></tr>
<tr><td><a href="./crypto/keys/keys_package_overview.html">crypto.keys</a></td><td>keys 包提供非对称加密和签名算法。</td></tr>
<tr><td><a href="./crypto/x509/x509_package_overview.html">crypto.x509</a></td><td>x509 包提供处理数字证书功能。</td></tr>
<tr><td><a href="./encoding/base64/base64_package_overview.html">encoding.base64</a></td><td>base 包提供字符串的 Base64 编码及解码。</td></tr>
<tr><td><a href="./encoding/hex/hex_package_overview.html">encoding.hex</a></td><td>hex 包提供字符串的 Hex 编码及解码。</td></tr>
<tr><td><a href="./encoding/json/json_package_overview.html">encoding.json</a></td><td>json 包用于对 json 数据的处理，实现 String, JsonValue, DataModel 之间的相互转换。</td></tr>
<tr><td><a href="./encoding/json_stream/json_stream_package_overview.html">encoding.json.stream</a></td><td>json.stream 包主要用于仓颉对象和 JSON 数据流之间的互相转换。</td></tr>
<tr><td><a href="./encoding/url/url_package_overview.html">encoding.url</a></td><td>url 包提供了 URL 相关的能力，包括解析 URL 的各个组件，对 URL 进行编解码，合并 URL 或路径等。 。</td></tr>
<tr><td><a href="./fuzz/fuzz_package_overview.html">fuzz</a></td><td>fuzz 包为开发者提供基于覆盖率反馈的仓颉 fuzz 引擎及对应的接口，开发者可以编写代码对 API 进行测试。</td></tr>
<tr><td><a href="./log/log_package_overview.html">log</a></td><td>log 包提供了日志记录相关的能力。</td></tr>
<tr><td><a href="./logger/logger_package_overview.html">logger</a></td><td>logger  包提供文本格式和 JSON 格式日志打印功能。</td></tr>
<tr><td><a href="./net/http/http_package_overview.html">net.http</a></td><td>http 包提供 HTTP/1.1，HTTP/2，WebSocket 协议的 server、client 端实现。</td></tr>
<tr><td><a href="./net/tls/tls_package_overview.html">net.tls</a></td><td>tls 包用于进行安全加密的网络通信，提供创建 TLS 服务器、基于协议进行 TLS 握手、收发加密数据、恢复 TLS 会话等能力。</td></tr>
<tr><td><a href="./serialization/serialization_package_overview.html">serialization</a></td><td>serialization 包提供了序列化和反序列化能力。</td></tr>
<tr><td><a href="./unittest/data/data_package_overview.html">unittest.data</a></td><td>unittest 模块提供了单元测试扩展能力。</td></tr>
</tbody></table>
</div>
<h2 id="使用指导"><a class="header" href="#使用指导">使用指导</a></h2>
<p>仓颉编程语言扩展库 stdx 二进制包包含静态（static）和 动态 （dynamic） 两部分，请按需引用。</p>
<h3 id="二进制产物结构"><a class="header" href="#二进制产物结构">二进制产物结构</a></h3>
<p>二进制包解压出来的目录包含 dynamic 和 static 两个目录：</p>
<p>dynamic/stdx 是动态产物，包含动态文件、cjo、bc 文件。</p>
<p>static/stdx 是静态产物，包含静态文件、cjo、bc 文件。</p>
<h3 id="包依赖"><a class="header" href="#包依赖">包依赖</a></h3>
<div class="table-wrapper"><table><thead><tr><th>导入库名</th><th>依赖包</th></tr></thead><tbody>
<tr><td>import stdx.compress.zlip.*</td><td>stdx.compress.zlib</td></tr>
<tr><td>import stdx.crypto.crypto.*</td><td>stdx.crypto.crypto、stdx.crypto.digest</td></tr>
<tr><td>import stdx.crypto.digest.*</td><td>stdx.crypto.digest</td></tr>
<tr><td>import stdx.crypto.keys.*</td><td>stdx.crypto.keys、stdx.crypto.x509、stdx.encoding.hex、stdx.encoding.base64、stdx.crypto.crypto、stdx.crypto.digest</td></tr>
<tr><td>import stdx.crypto.x509.*</td><td>stdx.crypto.x509、stdx.encoding.hex、stdx.encoding.base64、stdx.crypto.crypto、stdx.crypto.digest</td></tr>
<tr><td>import stdx.encoding.hex.*</td><td>stdx.encoding.hex</td></tr>
<tr><td>import stdx.encoding.base64.*</td><td>stdx.encoding.base64</td></tr>
<tr><td>import stdx.encoding.json.*</td><td>stdx.encoding.json、stdx.serialization.serialization</td></tr>
<tr><td>import stdx.encoding.json.stream.*</td><td>stdx.encoding.json.stream</td></tr>
<tr><td>import stdx.encoding.url.*</td><td>stdx.encoding.url</td></tr>
<tr><td>import stdx.log.*</td><td>stdx.log</td></tr>
<tr><td>import stdx.logger.*</td><td>stdx.logger</td></tr>
<tr><td>import stdx.serialization.serialization.*</td><td>stdx.serialization.serialization</td></tr>
<tr><td>import stdx.fuzz.fuzz.*</td><td>stdx.fuzz.fuzz</td></tr>
<tr><td>import stdx.net.http .*</td><td>stdx.net.http、stdx.net.tls、stdx.logger、stdx.log、stdx.encoding.url、stdx.encoding.json.stream、stdx.crypto.x509 、stdx.encoding.hex、stdx.encoding.base64、stdx.crypto.crypto、stdx.crypto.digest</td></tr>
<tr><td>import stdx.net.tls.*</td><td>stdx.net.tls、stdx.crypto.x509、stdx.encoding.hex、stdx.encoding.base64、stdx.crypto.crypto、stdx.crypto.digest</td></tr>
<tr><td>import stdx.unittest.data.*</td><td>stdx.encoding.json、stdx.serialization.serialization</td></tr>
</tbody></table>
</div>
<p>代码中导入上述包，用 cjc 命令去编译代码，需要严格按照上述包的依赖的顺序去链接。 如果是用 cjpm 则无需关注。</p>
<p>如果使用静态库，在导入 crypto 和 net 库时，由于需要依赖系统符号，所以 <code>Windows</code> 操作系统 需要额外添加 <code>-lcrypt32</code>，<code>Linux</code> 操作系统 需要额外添加 <code>-ldl</code>。</p>
<h3 id="cjc-使用命令示例"><a class="header" href="#cjc-使用命令示例">cjc 使用命令示例</a></h3>
<p>cjc 的介绍和编译请查看 cjc 编译选项章节</p>
<pre><code class="language-cangjie">import stdx.compress.zlib.*
import stdx.crypto.crypto.*
import stdx.crypto.digest.*
import stdx.crypto.keys.*
import stdx.crypto.x509.*
import stdx.encoding.hex.*
import stdx.encoding.base64.*
import stdx.encoding.json.*
import stdx.encoding.url.*
import stdx.encoding.json.stream.*
import stdx.net.tls.*
import stdx.net.http.*
import stdx.log.*
import stdx.logger.*
import stdx.serialization.serialization.*
main() {
    0
}

</code></pre>
<p>Linux 和 mac 的编译命令：</p>
<pre><code class="language-shell">$ cjc main.cj -L $CANGJIE_STDX_PATH -lstdx.encoding.json -lstdx.serialization.serialization  -lstdx.net.http -lstdx.net.tls -lstdx.logger -lstdx.log -lstdx.encoding.url -lstdx.encoding.json.stream -lstdx.crypto.keys -lstdx.crypto.x509 -lstdx.encoding.hex -lstdx.encoding.base64 -lstdx.crypto.crypto -lstdx.crypto.digest  -lstdx.compress.zlib -lstdx.compress -ldl --import-path  $CANGJIE_STDX_PATH -o main.out
</code></pre>
<p>windows 编译命令：</p>
<pre><code class="language-shell">$ cjc main.cj -L $CANGJIE_STDX_PATH -lstdx.encoding.json -lstdx.serialization.serialization  -lstdx.net.http -lstdx.net.tls -lstdx.logger -lstdx.log -lstdx.encoding.url -lstdx.encoding.json.stream -lstdx.crypto.keys -lstdx.crypto.x509 -lstdx.encoding.hex -lstdx.encoding.base64 -lstdx.crypto.crypto -lstdx.crypto.digest  -lstdx.compress.zlib -lstdx.compress -lcrypt32 --import-path  $CANGJIE_STDX_PATH -o main.out
</code></pre>
<p>CANGJIE_STDX_PATH 是设置的 stdx 路径。</p>
<p>运行前 Linux 操作系统需要在 LD_LIBRARY_PATH 中设置扩展库的路径，Windows 操作系统需要在 PATH 中设置扩展库的路径，macOS 操作系统需要在 DYLD_LIBRARY_PATH 中设置扩展库的路径。</p>
<h3 id="cjpm-使用示例"><a class="header" href="#cjpm-使用示例">cjpm 使用示例</a></h3>
<p>cjpm 的介绍和使用请查看 cjpm 手册。</p>
<p>cjpm.toml 增加如下配置：</p>
<pre><code class="language-text">[target.x86_64-unknown-linux-gnu]
  [target.x86_64-unknown-linux-gnu.bin-dependencies]
    path-option = [&quot;${CANGJIE_STDX_PATH}&quot;]
</code></pre>
<p>上面配置中 x86_64-unknown-linux-gnu 这是表示的系统架构信息，需要通过 cjc -v 获取。并替换成自己获取的系统信息。
CANGJIE_STDX_PATH 是设置的 stdx 路径。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdxcompresszlib"><a class="header" href="#stdxcompresszlib">stdx.compress.zlib</a></h1>
<h2 id="功能介绍"><a class="header" href="#功能介绍">功能介绍</a></h2>
<p>compress 提供压缩解压功能。</p>
<p>压缩是指用更少的比特表示数据，以便更高效地存储和传输数据。在实际应用中，压缩广泛应用于文件压缩、网页压缩、数据库备份等。</p>
<p>压缩功能的实现依赖于压缩算法，主流的压缩算法有 deflate、lz77、lzw 等，这些算法可以将数据中的冗余信息去除或者替换成更紧凑的表示形式，从而实现数据压缩的目的。目前使用自研的 deflate 算法。</p>
<p>基于 deflate 压缩算法，给压缩后数据加上首部和尾部，可封装成不同格式的压缩文件，如 deflate-raw（无封装）、gzip、zip、png 等。其中 zip 可用于多个文件的压缩和打包，gzip 仅包含一个压缩文件。目前支持的数据格式有 deflate-raw 和 gzip，暂不支持文件打包功能。</p>
<p>此外，支持设置压缩级别，更高的压缩级别对应着更高的压缩率和更慢的压缩速度，反之，更低的压缩级别对应着更低的压缩率和更快的压缩速度。</p>
<p>特别地，zlib 指的是压缩功能的一个实现库，zlib 包实现了 deflate 算法，并支持 deflate-raw 和 gzip 压缩格式。</p>
<p>本包使用自研 deflate 算法，支持 deflate-raw 和 gzip 数据格式，支持快速、默认、高压缩率三种压缩等级，压缩速度依次下降，压缩率依次提升。</p>
<p>本包提供流式压缩和解压功能，即支持从输入流读取数据，将其压缩或解压，并写入字节数组，或从字节数组中读取数据，将其压缩或解压，并写入输出流。</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>本包暂不支持文件打包功能。</p>
</blockquote>
<h2 id="api-列表"><a class="header" href="#api-列表">API 列表</a></h2>
<h3 id="类"><a class="header" href="#类">类</a></h3>
<div class="table-wrapper"><table><thead><tr><th>类名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="compress/zlib/./zlib_package_api/zlib_package_classes.html#class-compressinputstream">CompressInputStream</a></td><td>压缩输入流。</td></tr>
<tr><td><a href="compress/zlib/./zlib_package_api/zlib_package_classes.html#class-compressoutputstream">CompressOutputStream</a></td><td>压缩输出流。</td></tr>
<tr><td><a href="compress/zlib/./zlib_package_api/zlib_package_classes.html#class-decompressinputstream">DecompressInputStream</a></td><td>解压输入流。</td></tr>
<tr><td><a href="compress/zlib/./zlib_package_api/zlib_package_classes.html#class-decompressoutputstream">DecompressOutputStream</a></td><td>解压输出流。</td></tr>
</tbody></table>
</div>
<h3 id="枚举"><a class="header" href="#枚举">枚举</a></h3>
<div class="table-wrapper"><table><thead><tr><th>枚举名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="compress/zlib/./zlib_package_api/zlib_package_enums.html#enum-compresslevel">CompressLevel</a></td><td>压缩等级。</td></tr>
<tr><td><a href="compress/zlib/./zlib_package_api/zlib_package_enums.html#enum-wraptype">WrapType</a></td><td>压缩数据格式。</td></tr>
</tbody></table>
</div>
<h3 id="异常类"><a class="header" href="#异常类">异常类</a></h3>
<div class="table-wrapper"><table><thead><tr><th>异常类名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="compress/zlib/./zlib_package_api/zlib_package_exceptions.html#class-zlibexception">ZlibException</a></td><td><code>zlib</code> 包的异常类。</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="类-1"><a class="header" href="#类-1">类</a></h1>
<h2 id="class-compressinputstream"><a class="header" href="#class-compressinputstream">class CompressInputStream</a></h2>
<pre><code class="language-cangjie">public class CompressInputStream &lt;: InputStream {
    public init(inputStream: InputStream, wrap!: WrapType = DeflateFormat, compressLevel!: CompressLevel = DefaultCompression, bufLen!: Int64 = 512)
}
</code></pre>
<p>功能：压缩输入流。</p>
<p>可将 <a href="compress/zlib/zlib_package_api/zlib_package_classes.html#class-compressinputstream">CompressInputStream</a> 实例绑定到任意 InputStream 输入流，将该输入流中的数据压缩，并输出到字节数组。</p>
<p>父类型：</p>
<ul>
<li>InputStream</li>
</ul>
<h3 id="initinputstream-wraptype-compresslevel-int64"><a class="header" href="#initinputstream-wraptype-compresslevel-int64">init(InputStream, WrapType, CompressLevel, Int64)</a></h3>
<pre><code class="language-cangjie">public init(inputStream: InputStream, wrap!: WrapType = DeflateFormat, compressLevel!: CompressLevel = DefaultCompression, bufLen!: Int64 = 512)
</code></pre>
<p>功能：构造一个压缩输入流。</p>
<p>需绑定一个输入流，可设置压缩数据格式、压缩等级、内部缓冲区大小（每次从输入流中读取多少数据进行压缩）。</p>
<p>参数：</p>
<ul>
<li>inputStream: InputStream - 待压缩的输入流。</li>
<li>wrap!: <a href="compress/zlib/zlib_package_api/zlib_package_enums.html#enum-wraptype">WrapType</a> - 压缩数据格式，默认值为 <a href="compress/zlib/zlib_package_api/zlib_package_enums.html#deflateformat">DeflateFormat</a>。</li>
<li>compressLevel!: <a href="compress/zlib/zlib_package_api/zlib_package_enums.html#enum-compresslevel">CompressLevel</a> - 压缩等级，默认值为 <a href="compress/zlib/zlib_package_api/zlib_package_enums.html#defaultcompression">DefaultCompression</a>。</li>
<li>bufLen!: Int64 - 输入流缓冲区的大小，取值范围为 (0, Int64.Max]，默认 512 字节。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="compress/zlib/zlib_package_api/zlib_package_exceptions.html#class-zlibexception">ZlibException</a> - 当 <code>bufLen</code> 小于等于 0，输入流分配内存失败，或压缩资源初始化失败，抛出异常。</li>
</ul>
<h3 id="func-close"><a class="header" href="#func-close">func close()</a></h3>
<pre><code class="language-cangjie">public func close(): Unit
</code></pre>
<p>功能：关闭压缩输入流。</p>
<p>当前 <a href="compress/zlib/zlib_package_api/zlib_package_classes.html#class-compressinputstream">CompressInputStream</a> 实例使用完毕后必须调用此函数来释放其所占内存资源，以免造成内存泄漏。调用该函数前需确保 <a href="compress/zlib/zlib_package_api/./zlib_package_classes.html#func-readarraybyte">read</a> 函数已返回 0，否则可能导致绑定的 InputStream 并未被全部压缩。</p>
<p>异常：</p>
<ul>
<li><a href="compress/zlib/zlib_package_api/zlib_package_exceptions.html#class-zlibexception">ZlibException</a> - 如果释放压缩资源失败，抛出异常。</li>
</ul>
<h3 id="func-readarraybyte"><a class="header" href="#func-readarraybyte">func read(Array&lt;Byte&gt;)</a></h3>
<pre><code class="language-cangjie">public func read(outBuf: Array&lt;Byte&gt;): Int64
</code></pre>
<p>功能：从绑定的输入流中读取数据并压缩，压缩后数据放入指定的字节数组中。</p>
<p>参数：</p>
<ul>
<li>outBuf: Array&lt;Byte&gt; - 用来存放压缩后数据的缓冲区。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Int64 - 如果压缩成功，返回压缩后字节数，如果绑定的输入流中数据已经全部压缩完成，或者该压缩输入流被关闭，返回 0。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="compress/zlib/zlib_package_api/zlib_package_exceptions.html#class-zlibexception">ZlibException</a> - 当 <code>outBuf</code> 为空，或压缩数据失败，抛出异常。</li>
</ul>
<p>示例：</p>
<!-- verify -->
<pre><code class="language-cangjie">import stdx.compress.zlib.*
import std.fs.*
import std.io.*

main(): Unit {
    let arr1 = &quot;Hello, World!Hello, World!Hello, World!Hello, World!Hello, World!&quot;.toArray()
    let byteBuffer = ByteBuffer(arr1)
    let bufferedInputStream = BufferedInputStream(byteBuffer)
    var compressInputStream: CompressInputStream = CompressInputStream(bufferedInputStream)
    var arr: Array&lt;Byte&gt; = Array&lt;Byte&gt;(1024, repeat: 0)
    println(arr1.size)
    var len = compressInputStream.read(arr)
    println(len)
    compressInputStream.close()
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-text">65
17
</code></pre>
<h2 id="class-compressoutputstream"><a class="header" href="#class-compressoutputstream">class CompressOutputStream</a></h2>
<pre><code class="language-cangjie">public class CompressOutputStream &lt;: OutputStream {
    public init(outputStream: OutputStream, wrap!: WrapType = DeflateFormat, compressLevel!: CompressLevel = DefaultCompression, bufLen!: Int64 = 512)
}
</code></pre>
<p>功能：压缩输出流。</p>
<p>可将 <a href="compress/zlib/zlib_package_api/zlib_package_classes.html#class-compressoutputstream">CompressOutputStream</a> 实例绑定到任意 OutputStream 类型输出流，读取、压缩指定字节数组中的数据，并将压缩后数据输出到绑定的输出流。</p>
<p>父类型：</p>
<ul>
<li>OutputStream</li>
</ul>
<h3 id="initoutputstream-wraptype-compresslevel-int64"><a class="header" href="#initoutputstream-wraptype-compresslevel-int64">init(OutputStream, WrapType, CompressLevel, Int64)</a></h3>
<pre><code class="language-cangjie">public init(outputStream: OutputStream, wrap!: WrapType = DeflateFormat, compressLevel!: CompressLevel = DefaultCompression, bufLen!: Int64 = 512)
</code></pre>
<p>功能：构造一个压缩输出流，需绑定一个输出流，可设置压缩数据类型、压缩等级、内部缓冲区大小（每得到多少压缩后数据往输出流写出）。</p>
<p>参数：</p>
<ul>
<li>outputStream: OutputStream - 绑定的输出流，压缩后数据将写入该输出流。</li>
<li>wrap!: <a href="compress/zlib/zlib_package_api/zlib_package_enums.html#enum-wraptype">WrapType</a> - 压缩数据格式，默认值为 <a href="compress/zlib/zlib_package_api/zlib_package_enums.html#deflateformat">DeflateFormat</a>。</li>
<li>compressLevel!: <a href="compress/zlib/zlib_package_api/zlib_package_enums.html#enum-compresslevel">CompressLevel</a> - 压缩等级，默认值为 <a href="compress/zlib/zlib_package_api/zlib_package_enums.html#defaultcompression">DefaultCompression</a>。</li>
<li>bufLen!: Int64 - 输出流缓冲区的大小，取值范围为 (0, Int64.Max]，默认 512 字节。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="compress/zlib/zlib_package_api/zlib_package_exceptions.html#class-zlibexception">ZlibException</a> - 如果 <code>bufLen</code> 小于等于 0，输出流分配内存失败，或压缩资源初始化失败，抛出异常。</li>
</ul>
<h3 id="func-close-1"><a class="header" href="#func-close-1">func close()</a></h3>
<pre><code class="language-cangjie">public func close(): Unit
</code></pre>
<p>功能：关闭当前压缩输出流实例。</p>
<p>关闭时，将写入剩余压缩数据（包括缓冲区中数据，以及压缩尾部信息），并释放其所占内存资源。当前压缩输出流使用完毕后必须调用此函数来释放其所占内存资源，以免造成内存泄漏。在调用 <a href="compress/zlib/zlib_package_api/./zlib_package_classes.html#func-close-1">close</a> 函数前，绑定的输出流里已写入的数据并不是一段完整的压缩数据，调用 <a href="compress/zlib/zlib_package_api/./zlib_package_classes.html#func-close-1">close</a> 函数后，才会把剩余压缩数据写入绑定的输出流，使其完整。</p>
<p>异常：</p>
<ul>
<li><a href="compress/zlib/zlib_package_api/zlib_package_exceptions.html#class-zlibexception">ZlibException</a> - 如果当前压缩输出流已经被关闭，或释放压缩资源失败，抛出异常。</li>
</ul>
<h3 id="func-flush"><a class="header" href="#func-flush">func flush()</a></h3>
<pre><code class="language-cangjie">public func flush(): Unit
</code></pre>
<p>功能：刷新压缩输出流。将内部缓冲区里已压缩的数据刷出并写入绑定的输出流，然后刷新绑定的输出流。</p>
<p>异常：</p>
<ul>
<li><a href="compress/zlib/zlib_package_api/zlib_package_exceptions.html#class-zlibexception">ZlibException</a> - 如果当前压缩输出流已经被关闭，抛出异常。</li>
</ul>
<h3 id="func-writearraybyte"><a class="header" href="#func-writearraybyte">func write(Array&lt;Byte&gt;)</a></h3>
<pre><code class="language-cangjie">public func write(inBuf: Array&lt;Byte&gt;): Unit
</code></pre>
<p>功能：将指定字节数组中的数据进行压缩，并写入输出流，当数据全部压缩完成并写入输出流，函数返回。</p>
<p>参数：</p>
<ul>
<li>inBuf: Array&lt;Byte&gt; - 待压缩的字节数组。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="compress/zlib/zlib_package_api/zlib_package_exceptions.html#class-zlibexception">ZlibException</a> - 如果当前压缩输出流已经被关闭，或压缩数据失败，抛出异常。</li>
</ul>
<p>示例：</p>
<!-- run -->
<pre><code class="language-cangjie">import stdx.compress.zlib.*
import std.io.*

main(): Unit {
    var byteBuffer = ByteBuffer()
    var compressOutputStream: CompressOutputStream = CompressOutputStream(byteBuffer,bufLen:39)

    var arr = &quot;Hello, World!Hello, World!Hello, World!&quot;.toArray()

    /* 将字节数组压缩后写入压缩输出流的缓冲区 */
    compressOutputStream.write(arr)

    /* 将内部缓冲区里已压缩的数据刷出并写入绑定的输出流，然后刷新绑定的输出流 */
    compressOutputStream.flush()
    
    /* 关闭压缩输出流 */
    compressOutputStream.close()
}
</code></pre>
<h2 id="class-decompressinputstream"><a class="header" href="#class-decompressinputstream">class DecompressInputStream</a></h2>
<pre><code class="language-cangjie">public class DecompressInputStream &lt;: InputStream {
    public init(inputStream: InputStream, wrap!: WrapType = DeflateFormat, bufLen!: Int64 = 512)
}
</code></pre>
<p>功能：解压输入流。</p>
<p>可将 <a href="compress/zlib/zlib_package_api/zlib_package_classes.html#class-decompressinputstream">DecompressInputStream</a> 实例绑定到任意 InputStream 输入流，读取、解压其中的数据，并将解压后数据输出到指定字节数组。</p>
<p>父类型：</p>
<ul>
<li>InputStream</li>
</ul>
<h3 id="initinputstream-wraptype-int64"><a class="header" href="#initinputstream-wraptype-int64">init(InputStream, WrapType, Int64)</a></h3>
<pre><code class="language-cangjie">public init(inputStream: InputStream, wrap!: WrapType = DeflateFormat, bufLen!: Int64 = 512)
</code></pre>
<p>功能：构造一个解压输入流。</p>
<p>需绑定一个输入流，可设置待解压数据格式、内部缓冲区大小（每次从输入流中读取多少数据进行解压）。</p>
<p>参数：</p>
<ul>
<li>inputStream: InputStream - 待压缩的输入流。</li>
<li>wrap!: <a href="compress/zlib/zlib_package_api/zlib_package_enums.html#enum-wraptype">WrapType</a> - 待解压数据格式，默认值为 <a href="compress/zlib/zlib_package_api/zlib_package_enums.html#deflateformat">DeflateFormat</a>。</li>
<li>bufLen!: Int64 - 输入流缓冲区的大小，取值范围为 (0, Int64.Max]，默认 512 字节。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="compress/zlib/zlib_package_api/zlib_package_exceptions.html#class-zlibexception">ZlibException</a> - 如果 <code>bufLen</code> 小于等于 0，输入流分配内存失败，或待解压资源初始化失败，抛出异常。</li>
</ul>
<h3 id="func-close-2"><a class="header" href="#func-close-2">func close()</a></h3>
<pre><code class="language-cangjie">public func close(): Unit
</code></pre>
<p>功能：关闭解压输入流。</p>
<p>当前 <a href="compress/zlib/zlib_package_api/zlib_package_classes.html#class-decompressinputstream">DecompressInputStream</a> 实例使用完毕后必须调用此函数来释放其所占内存资源，以免造成内存泄漏。调用该函数前需确保 <a href="compress/zlib/zlib_package_api/./zlib_package_classes.html#func-readarraybyte-1">read</a> 函数已返回 0，否则可能导致绑定的 InputStream 并未被全部解压。</p>
<p>异常：</p>
<ul>
<li><a href="compress/zlib/zlib_package_api/zlib_package_exceptions.html#class-zlibexception">ZlibException</a> - 如果释放解压资源失败，抛出异常。</li>
</ul>
<h3 id="func-readarraybyte-1"><a class="header" href="#func-readarraybyte-1">func read(Array&lt;Byte&gt;)</a></h3>
<pre><code class="language-cangjie">public func read(outBuf: Array&lt;Byte&gt;): Int64
</code></pre>
<p>功能：从绑定的输入流中读取数据并解压，解压后数据放入指定的字节数组中。</p>
<p>参数：</p>
<ul>
<li>outBuf: Array&lt;Byte&gt; - 用来存放解压后数据的缓冲区。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Int64 - 如果解压成功，返回解压后字节数，如果绑定的输入流中数据已经全部解压完成，或者该解压输入流被关闭，返回 0。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="compress/zlib/zlib_package_api/zlib_package_exceptions.html#class-zlibexception">ZlibException</a> - 当 <code>outBuf</code> 为空，或解压数据失败，抛出异常。</li>
</ul>
<p>示例：</p>
<!-- verify -->
<pre><code class="language-cangjie">import stdx.compress.zlib.*
import std.fs.*
import std.io.*

main(): Unit {
    let arr1 = &quot;Hello, World!Hello, World!Hello, World!Hello, World!Hello, World!&quot;.toArray()

    /* 使用压缩输入流进行数据压缩 */
    let byteBuffer = ByteBuffer(arr1)
    var compressInputStream: CompressInputStream = CompressInputStream(byteBuffer)
    var arr2: Array&lt;Byte&gt; = Array&lt;Byte&gt;(1024, repeat: 0)
    /* 原始数据长度 */
    println(arr1.size)
    var len1 = compressInputStream.read(arr2)
    /* 压缩后的数据长度 */
    println(len1)

    /* 使用解压缩输入流进行数据解压 */
    var decompressInputStream: DecompressInputStream = DecompressInputStream(ByteBuffer(arr2[..len1]))
    var arr3: Array&lt;Byte&gt; = Array&lt;Byte&gt;(1024, repeat: 0)
    var len2 = decompressInputStream.read(arr3)
    println(String.fromUtf8(arr3[..len2]))

    /* 关闭输入流 */
    compressInputStream.close()
    decompressInputStream.close()
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-text">65
17
Hello, World!Hello, World!Hello, World!Hello, World!Hello, World!
</code></pre>
<h2 id="class-decompressoutputstream"><a class="header" href="#class-decompressoutputstream">class DecompressOutputStream</a></h2>
<pre><code class="language-cangjie">public class DecompressOutputStream &lt;: OutputStream {
    public init(outputStream: OutputStream, wrap!: WrapType = DeflateFormat, bufLen!: Int64 = 512)
}
</code></pre>
<p>功能：解压输出流。</p>
<p>可将 <a href="compress/zlib/zlib_package_api/zlib_package_classes.html#class-decompressoutputstream">DecompressOutputStream</a> 实例绑定到指定的 OutputStream 类型输出流，读取、解压指定字节数组中的数据，并将解压后数据输出到绑定的输出流。</p>
<p>父类型：</p>
<ul>
<li>OutputStream</li>
</ul>
<h3 id="initoutputstream-wraptype-int64"><a class="header" href="#initoutputstream-wraptype-int64">init(OutputStream, WrapType, Int64)</a></h3>
<pre><code class="language-cangjie">public init(outputStream: OutputStream, wrap!: WrapType = DeflateFormat, bufLen!: Int64 = 512)
</code></pre>
<p>功能：构造一个解压输出流。</p>
<p>需绑定一个输出流，可设置压缩数据类型、压缩等级、内部缓冲区大小（解压后数据会存入内部缓冲区，缓冲区存满后再写到输出流）。</p>
<p>参数：</p>
<ul>
<li>outputStream: OutputStream - 绑定的输出流，解压后数据将写入该输出流。</li>
<li>wrap!: <a href="compress/zlib/zlib_package_api/zlib_package_enums.html#enum-wraptype">WrapType</a> - 待解压数据格式，默认值为 <a href="compress/zlib/zlib_package_api/zlib_package_enums.html#deflateformat">DeflateFormat</a>。</li>
<li>bufLen!: Int64 - 输出流缓冲区的大小，取值范围为 (0, Int64.Max]，默认 512 字节。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="compress/zlib/zlib_package_api/zlib_package_exceptions.html#class-zlibexception">ZlibException</a> - 如果 <code>bufLen</code> 小于等于 0，输出流分配内存失败，或解压资源初始化失败，抛出异常。</li>
</ul>
<h3 id="func-close-3"><a class="header" href="#func-close-3">func close()</a></h3>
<pre><code class="language-cangjie">public func close(): Unit
</code></pre>
<p>功能：关闭当前解压输出流实例。</p>
<p>关闭时，将写入剩余解压后数据，并释放其所占内存资源。当前压缩输出流使用完毕后必须调用此函数来释放其所占内存资源，以免造成内存泄漏。如果之前 <a href="compress/zlib/zlib_package_api/./zlib_package_classes.html#func-writearraybyte-1">write</a> 函数已处理的压缩数据不完整，调用 <a href="compress/zlib/zlib_package_api/./zlib_package_classes.html#func-close-1">close</a> 函数时会因为解压数据不全而抛出异常。</p>
<p>异常：</p>
<ul>
<li><a href="compress/zlib/zlib_package_api/zlib_package_exceptions.html#class-zlibexception">ZlibException</a> - 如果当前压缩输出流已经被关闭，通过 <a href="compress/zlib/zlib_package_api/./zlib_package_classes.html#func-writearraybyte-1">write</a> 函数传入的待解压数据不完整，或释放压缩资源失败，抛出异常。</li>
</ul>
<h3 id="func-flush-1"><a class="header" href="#func-flush-1">func flush()</a></h3>
<pre><code class="language-cangjie">public func flush(): Unit
</code></pre>
<p>功能：刷新解压输出流。将内部缓冲区里已解压的数据写入绑定的输出流，然后刷新绑定的输出流。</p>
<p>异常：</p>
<ul>
<li><a href="compress/zlib/zlib_package_api/zlib_package_exceptions.html#class-zlibexception">ZlibException</a> - 如果当前解压输出流已经被关闭，抛出异常。</li>
</ul>
<h3 id="func-writearraybyte-1"><a class="header" href="#func-writearraybyte-1">func write(Array&lt;Byte&gt;)</a></h3>
<pre><code class="language-cangjie">public func write(inBuf: Array&lt;Byte&gt;): Unit
</code></pre>
<p>功能：将指定字节数组中的数据进行解压，并写入输出流，当数据全部解压完成并写入输出流，函数返回。</p>
<p>参数：</p>
<ul>
<li>inBuf: Array&lt;Byte&gt; - 待解压的字节数组。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="compress/zlib/zlib_package_api/zlib_package_exceptions.html#class-zlibexception">ZlibException</a> - 如果当前解压输出流已经被关闭，或解压数据失败，抛出异常。</li>
</ul>
<p>示例：</p>
<!-- verify -->
<pre><code class="language-cangjie">import stdx.compress.zlib.*
import std.fs.*
import std.io.*

main(): Unit {
    let arr1 = &quot;Hello, World!Hello, World!Hello, World!Hello, World!Hello, World!&quot;.toArray()

    /* 使用压缩输入流进行数据压缩 */
    let byteBuffer = ByteBuffer(arr1)
    var compressInputStream: CompressInputStream = CompressInputStream(byteBuffer)
    var arr2: Array&lt;Byte&gt; = Array&lt;Byte&gt;(1024, repeat: 0)
    /* 原始数据长度 */
    println(arr1.size)
    var len1 = compressInputStream.read(arr2)
    /* 压缩后的数据长度 */
    println(len1)

    /* 使用解压缩输出流进行数据解压后，将数据写入文件，文件的内容为原始数据 */
    var file = File(&quot;./file.text&quot;, ReadWrite)
    var decompressOutputStream: DecompressOutputStream = DecompressOutputStream(file)
    decompressOutputStream.write(arr2[..len1])
    decompressOutputStream.flush()

    /* 关闭输入流和输出流 */
    compressInputStream.close()
    decompressOutputStream.close()
    file.close()
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-text">65
17
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="枚举-1"><a class="header" href="#枚举-1">枚举</a></h1>
<h2 id="enum-compresslevel"><a class="header" href="#enum-compresslevel">enum CompressLevel</a></h2>
<pre><code class="language-cangjie">public enum CompressLevel {
    | BestCompression
    | BestSpeed
    | DefaultCompression
}
</code></pre>
<p>功能：压缩等级。</p>
<p>压缩等级决定了压缩率和压缩速度，目前支持三种压缩等级，压缩率由小到大，压缩速度由快到慢依次为：BestSpeed、DefaultCompression、BestCompression。</p>
<h3 id="bestcompression"><a class="header" href="#bestcompression">BestCompression</a></h3>
<pre><code class="language-cangjie">BestCompression
</code></pre>
<p>功能：构造一个压缩率优先的压缩等级枚举实例，表示压缩率最高，压缩速度相对降低。</p>
<h3 id="bestspeed"><a class="header" href="#bestspeed">BestSpeed</a></h3>
<pre><code class="language-cangjie">BestSpeed
</code></pre>
<p>功能：构造一个压缩速度优先的压缩等级枚举实例，表示压缩速度最快，压缩率相对较低。</p>
<h3 id="defaultcompression"><a class="header" href="#defaultcompression">DefaultCompression</a></h3>
<pre><code class="language-cangjie">DefaultCompression
</code></pre>
<p>功能：构造一个压缩等级枚举实例，表示默认压缩等级。</p>
<h2 id="enum-wraptype"><a class="header" href="#enum-wraptype">enum WrapType</a></h2>
<pre><code class="language-cangjie">public enum WrapType {
    | DeflateFormat
    | GzipFormat
}
</code></pre>
<p>功能：压缩数据格式。</p>
<p>目前支持 DeflateFormat 和 GzipFormat 两种格式。</p>
<h3 id="deflateformat"><a class="header" href="#deflateformat">DeflateFormat</a></h3>
<pre><code class="language-cangjie">DeflateFormat
</code></pre>
<p>功能：构造一个表示 <code>Deflate</code> 压缩数据格式的枚举实例。</p>
<h3 id="gzipformat"><a class="header" href="#gzipformat">GzipFormat</a></h3>
<pre><code class="language-cangjie">GzipFormat
</code></pre>
<p>功能：构造一个表示 <code>Gzip</code> 压缩数据格式的枚举实例。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="异常类-1"><a class="header" href="#异常类-1">异常类</a></h1>
<h2 id="class-zlibexception"><a class="header" href="#class-zlibexception">class ZlibException</a></h2>
<pre><code class="language-cangjie">public class ZlibException &lt;: Exception {
    public init(message: String)
}
</code></pre>
<p>功能：zlib 包的异常类。</p>
<p>父类型：</p>
<ul>
<li>Exception</li>
</ul>
<h3 id="initstring"><a class="header" href="#initstring">init(String)</a></h3>
<pre><code class="language-cangjie">public init(message: String)
</code></pre>
<p>功能：根据异常信息创建 <a href="compress/zlib/zlib_package_api/zlib_package_exceptions.html#class-zlibexception">ZlibException</a> 实例。</p>
<p>参数：</p>
<ul>
<li>message: String - 异常提示信息。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deflate-格式数据的压缩和解压"><a class="header" href="#deflate-格式数据的压缩和解压">Deflate 格式数据的压缩和解压</a></h1>
<p>示例：</p>
<!-- verify -->
<pre><code class="language-cangjie">import stdx.compress.zlib.*
import std.fs.*

main() {
    var arr: Array&lt;Byte&gt; = Array&lt;Byte&gt;(1024 * 1024, {i =&gt; UInt8(i % 256)})
    File.writeTo(&quot;./zlib1.txt&quot;, arr)

    if (compressFile(&quot;./zlib1.txt&quot;, &quot;./zlib_copmressed1.zlib&quot;) &lt;= 0) {
        println(&quot;Failed to compress file!&quot;)
    }

    if (decompressFile(&quot;./zlib_copmressed1.zlib&quot;, &quot;./zlib_decopmressed1.txt&quot;) != arr.size) {
        println(&quot;Failed to decompress file!&quot;)
    }

    if (compareFile(&quot;./zlib1.txt&quot;, &quot;./zlib_decopmressed1.txt&quot;)) {
        println(&quot;success&quot;)
    } else {
        println(&quot;failed&quot;)
    }

    remove(&quot;./zlib1.txt&quot;)
    remove(&quot;./zlib_copmressed1.zlib&quot;)
    remove(&quot;./zlib_decopmressed1.txt&quot;)
    return 0
}

func compressFile(srcFileName: String, destFileName: String): Int64 {
    var count: Int64 = 0
    var srcFile: File = File(srcFileName, Read)
    var destFile: File = File(destFileName, Write)

    var tempBuf: Array&lt;UInt8&gt; = Array&lt;UInt8&gt;(1024, repeat: 0)
    var compressOutputStream: CompressOutputStream = CompressOutputStream(destFile, wrap: DeflateFormat)
    while (true) {
        var readNum = srcFile.read(tempBuf)
        if (readNum &gt; 0) {
            compressOutputStream.write(tempBuf.slice(0, readNum).toArray())
            count += readNum
        } else {
            break
        }
    }
    compressOutputStream.flush()
    compressOutputStream.close()

    srcFile.close()
    destFile.close()
    return count
}

func decompressFile(srcFileName: String, destFileName: String): Int64 {
    var count: Int64 = 0
    var srcFile: File = File(srcFileName, Read)
    var destFile: File = File(destFileName, Write)

    var tempBuf: Array&lt;UInt8&gt; = Array&lt;UInt8&gt;(1024, repeat: 0)
    var decompressInputStream: DecompressInputStream = DecompressInputStream(srcFile, wrap: DeflateFormat)
    while (true) {
        var readNum = decompressInputStream.read(tempBuf)
        if (readNum &lt;= 0) {
            break
        }
        destFile.write(tempBuf.slice(0, readNum).toArray())
        count += readNum
    }
    decompressInputStream.close()

    srcFile.close()
    destFile.close()
    return count
}

func compareFile(fileName1: String, fileName2: String): Bool {
    return File.readFrom(fileName1) == File.readFrom(fileName2)
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-text">success
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gzip-格式数据的压缩和解压"><a class="header" href="#gzip-格式数据的压缩和解压">Gzip 格式数据的压缩和解压</a></h1>
<p>示例：</p>
<!-- verify -->
<pre><code class="language-cangjie">import stdx.compress.zlib.*
import std.fs.*

main() {
    var arr: Array&lt;Byte&gt; = Array&lt;Byte&gt;(1024 * 1024, {i =&gt; UInt8(i % 256)})
    File.writeTo(&quot;./zlib.txt&quot;, arr)

    if (compressFile(&quot;./zlib.txt&quot;, &quot;./zlib_copmressed.zlib&quot;) &lt;= 0) {
        println(&quot;Failed to compress file!&quot;)
    }

    if (decompressFile(&quot;./zlib_copmressed.zlib&quot;, &quot;./zlib_decopmressed.txt&quot;) != arr.size) {
        println(&quot;Failed to decompress file!&quot;)
    }

    if (compareFile(&quot;./zlib.txt&quot;, &quot;./zlib_decopmressed.txt&quot;)) {
        println(&quot;success&quot;)
    } else {
        println(&quot;failed&quot;)
    }

    remove(&quot;./zlib.txt&quot;)
    remove(&quot;./zlib_copmressed.zlib&quot;)
    remove(&quot;./zlib_decopmressed.txt&quot;)
    return 0
}

func compressFile(srcFileName: String, destFileName: String): Int64 {
    var count: Int64 = 0
    var srcFile: File = File(srcFileName, Read)
    var destFile: File = File(destFileName, Write)

    var tempBuf: Array&lt;UInt8&gt; = Array&lt;UInt8&gt;(1024, repeat: 0)
    var compressOutputStream: CompressOutputStream = CompressOutputStream(destFile, wrap: GzipFormat, bufLen: 10000)
    while (true) {
        var readNum = srcFile.read(tempBuf)
        if (readNum &gt; 0) {
            compressOutputStream.write(tempBuf.slice(0, readNum).toArray())
            count += readNum
        } else {
            break
        }
    }
    compressOutputStream.flush()
    compressOutputStream.close()

    srcFile.close()
    destFile.close()
    return count
}

func decompressFile(srcFileName: String, destFileName: String): Int64 {
    var count: Int64 = 0
    var srcFile: File = File(srcFileName, Read)
    var destFile: File = File(destFileName, Write)

    var tempBuf: Array&lt;UInt8&gt; = Array&lt;UInt8&gt;(1024, repeat: 0)
    var decompressInputStream: DecompressInputStream = DecompressInputStream(srcFile, wrap: GzipFormat, bufLen: 10000)
    while (true) {
        var readNum = decompressInputStream.read(tempBuf)
        if (readNum &lt;= 0) {
            break
        }
        destFile.write(tempBuf.slice(0, readNum).toArray())
        count += readNum
    }
    decompressInputStream.close()

    srcFile.close()
    destFile.close()
    return count
}

func compareFile(fileName1: String, fileName2: String): Bool {
    return File.readFrom(fileName1) == File.readFrom(fileName2)
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-text">success
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdxcryptocrypto"><a class="header" href="#stdxcryptocrypto">stdx.crypto.crypto</a></h1>
<h2 id="功能介绍-1"><a class="header" href="#功能介绍-1">功能介绍</a></h2>
<p>crypto 包提供安全随机数功能和提供国密 SM4 对称加解密。</p>
<p>使用本包需要外部依赖 OpenSSL 3 的 crypto 动态库文件，故使用前需安装相关工具。</p>
<ul>
<li>
<p>对于 Linux 操作系统，可参考以下方式：</p>
<ul>
<li>如果系统的包管理工具支持安装 OpenSSL 3 开发工具包，可通过这个方式安装，并确保系统安装目录下含有 libcrypto.so 和 libcrypto.so.3 这两个动态库文件，例如 Ubuntu 22.04 系统上可使用 sudo apt install libssl-dev 命令安装 libssl-dev 工具包；</li>
<li>如果无法通过上面的方式安装，可自行下载 OpenSSL 3.x.x 源码编译安装软件包，并确保安装目录下含有 libcrypto.so 和 libcrypto.so.3 这两个动态库文件，然后可选择下面任意一种方式来保证系统链接器可以找到这些文件:
<ul>
<li>在系统未安装 OpenSSL 的场景，安装时选择直接安装到系统路径下；</li>
<li>安装在自定义目录的场景，将这些文件所在目录设置到环境变量 LD_LIBRARY_PATH 以及 LIBRARY_PATH 中。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>对于 Windows 操作系统，可按照以下步骤：</p>
<ul>
<li>自行下载 OpenSSL 3.x.x 源码编译安装 x64 架构软件包或者自行下载安装第三方预编译的供开发人员使用的 OpenSSL 3.x.x 软件包；</li>
<li>确保安装目录下含有 libcrypto.dll.a(或 libcrypto.lib)、libcrypto-3-x64.dll 这两个库文件；</li>
<li>将 libcrypto.dll.a(或 libcrypto.lib) 所在的目录路径设置到环境变量 LIBRARY_PATH 中，将 libcrypto-3-x64.dll 所在的目录路径设置到环境变量 PATH 中。</li>
</ul>
</li>
<li>
<p>对于 macOS 操作系统，可参考以下方式：</p>
<ul>
<li>使用 brew install openssl@3 安装，并确保系统安装目录下含有 libcrypto.dylib 和 libcrypto.3.dylib 这两个动态库文件；</li>
<li>如果无法通过上面的方式安装，可自行下载 OpenSSL 3.x.x 源码编译安装软件包，并确保安装目录下含有 libcrypto.dylib 和 libcrypto.3.dylib 这两个动态库文件，然后可选择下面任意一种方式来保证系统链接器可以找到这些文件:
<ul>
<li>在系统未安装 OpenSSL 的场景，安装时选择直接安装到系统路径下；</li>
<li>安装在自定义目录的场景，将这些文件所在目录设置到环境变量 DYLD_LIBRARY_PATH 以及 LIBRARY_PATH 中。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>说明：</strong></p>
<p>如果未安装 OpenSSL 3 软件包或者安装低版本的软件包，程序可能无法使用并抛出相关异常 SecureRandomException：Can not load openssl library or function xxx。</p>
</blockquote>
<h2 id="api-列表-1"><a class="header" href="#api-列表-1">API 列表</a></h2>
<h3 id="类-2"><a class="header" href="#类-2">类</a></h3>
<div class="table-wrapper"><table><thead><tr><th>类名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="crypto/crypto/./crypto_package_api/crypto_package_classes.html#class-securerandom">SecureRandom</a></td><td>安全随机数。</td></tr>
<tr><td><a href="crypto/crypto/./crypto_package_api/crypto_package_classes.html#class-sm4">SM4</a></td><td>提供国密SM4对称加解密。</td></tr>
</tbody></table>
</div>
<h3 id="结构体"><a class="header" href="#结构体">结构体</a></h3>
<div class="table-wrapper"><table><thead><tr><th>结构体名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="crypto/crypto/./crypto_package_api/crypto_package_structs.html#struct-operationmode">OperationMode</a></td><td>对称加解密算法的工作模式。</td></tr>
<tr><td><a href="crypto/crypto/./crypto_package_api/crypto_package_structs.html#struct-paddingmode">PaddingMode</a></td><td>对称加解密算法的工填充模式。</td></tr>
</tbody></table>
</div>
<h3 id="异常类-2"><a class="header" href="#异常类-2">异常类</a></h3>
<div class="table-wrapper"><table><thead><tr><th>异常类名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="crypto/crypto/./crypto_package_api/crypto_package_exceptions.html#class-securerandomexception">SecureRandomException</a></td><td>安全随机数异常类。</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="类-3"><a class="header" href="#类-3">类</a></h1>
<h2 id="class-securerandom"><a class="header" href="#class-securerandom">class SecureRandom</a></h2>
<pre><code class="language-cangjie">public class SecureRandom {
    public init(priv!: Bool = false)
}
</code></pre>
<p>功能：用于生成加密安全的伪随机数。</p>
<p>和 Random 相比，主要有三个方面不同：</p>
<ul>
<li>
<p>随机数种子： Random 使用系统时钟作为默认的种子，时间戳一样，结果就相同；<a href="crypto/crypto/crypto_package_api/crypto_package_classes.html#class-securerandom">SecureRandom</a> 使用操作系统或者硬件提供的随机数种子，生成的是真随机数。</p>
</li>
<li>
<p>随机数生成： Random 使用了梅森旋转伪随机生成器；<a href="crypto/crypto/crypto_package_api/crypto_package_classes.html#class-securerandom">SecureRandom</a> 则使用了 openssl 库提供的 <a href="crypto/crypto/crypto_package_api/../../digest/digest_package_api/digest_package_classes.html#class-md5">MD5</a> 等随机算法，使用熵源生成真随机数；如果硬件支持，还可以使用硬件随机数生成器来生成安全性更强的随机数。</p>
</li>
<li>
<p>安全性： Random 不能用于加密安全的应用或者隐私数据的保护，可以使用 <a href="crypto/crypto/crypto_package_api/crypto_package_classes.html#class-securerandom">SecureRandom</a>。</p>
</li>
</ul>
<p>使用示例见 <a href="crypto/crypto/crypto_package_api/../crypto_samples/sample_secure_random.html#SecureRandom-%E4%BD%BF%E7%94%A8">SecureRandom 使用</a>。</p>
<h3 id="initbool"><a class="header" href="#initbool">init(Bool)</a></h3>
<pre><code class="language-cangjie">public init(priv!: Bool = false)
</code></pre>
<p>功能：创建 <a href="crypto/crypto/crypto_package_api/crypto_package_classes.html#class-securerandom">SecureRandom</a> 实例，可指定是否使用更加安全的加密安全伪随机生成器，加密安全伪随机生成器可用于会话密钥和证书私钥等加密场景。</p>
<p>参数：</p>
<ul>
<li>priv!: Bool - 设置为 true 表示使用加密安全伪随机生成器。</li>
</ul>
<h3 id="func-nextbitsuint64"><a class="header" href="#func-nextbitsuint64">func nextBits(UInt64)</a></h3>
<pre><code class="language-cangjie">public func nextBits(bits: UInt64): UInt64
</code></pre>
<p>功能：生成一个指定位长的随机整数。</p>
<p>参数:</p>
<ul>
<li>bits: UInt64 - 要生成的随机数的位数，取值范围 (0, 64]。</li>
</ul>
<p>返回值：</p>
<ul>
<li>UInt64 - 生成的用户指定位长的随机数。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 如果 <code>bits</code> 等于 0，或大于 64，超过所能截取的 UInt64 长度，则抛出异常。</li>
<li><a href="crypto/crypto/crypto_package_api/crypto_package_exceptions.html#class-securerandomexception">SecureRandomException</a> - 当生成器不能正确生成随机数或生成随机数失败时，抛出异常。</li>
</ul>
<h3 id="func-nextbool"><a class="header" href="#func-nextbool">func nextBool()</a></h3>
<pre><code class="language-cangjie">public func nextBool(): Bool
</code></pre>
<p>功能：获取一个随机的 Bool 类型实例。</p>
<p>返回值：</p>
<ul>
<li>Bool - 一个随机的 Bool 类型实例。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/crypto/crypto_package_api/crypto_package_exceptions.html#class-securerandomexception">SecureRandomException</a> - 当生成器不能正确生成随机数或生成随机数失败时，抛出异常。</li>
</ul>
<h3 id="func-nextbytesarraybyte"><a class="header" href="#func-nextbytesarraybyte">func nextBytes(Array&lt;Byte&gt;)</a></h3>
<pre><code class="language-cangjie">public func nextBytes(bytes: Array&lt;Byte&gt;): Unit
</code></pre>
<p>功能：生成随机数替换入参数组中的每个元素。</p>
<p>参数：</p>
<ul>
<li>bytes: Array&lt;Byte&gt; - 被替换的数组。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/crypto/crypto_package_api/crypto_package_exceptions.html#class-securerandomexception">SecureRandomException</a> - 当生成器不能正确生成随机数或生成随机数失败时，抛出异常。</li>
</ul>
<h3 id="func-nextbytesint32"><a class="header" href="#func-nextbytesint32">func nextBytes(Int32)</a></h3>
<pre><code class="language-cangjie">public func nextBytes(length: Int32): Array&lt;Byte&gt;
</code></pre>
<p>功能：获取一个指定长度的随机字节的数组。</p>
<p>参数：</p>
<ul>
<li>length: Int32 - 要生成的随机字节数组的长度。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Array&lt;Byte&gt; - 一个随机字节数组。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 当参数 length 小于等于 0，抛出异常。</li>
<li><a href="crypto/crypto/crypto_package_api/crypto_package_exceptions.html#class-securerandomexception">SecureRandomException</a> - 当生成器不能正确生成随机数或生成随机数失败时，抛出异常。</li>
</ul>
<h3 id="func-nextfloat16"><a class="header" href="#func-nextfloat16">func nextFloat16()</a></h3>
<pre><code class="language-cangjie">public func nextFloat16(): Float16
</code></pre>
<p>功能：获取一个 Float16 类型且在区间 [0.0, 1.0) 内的随机数。</p>
<p>返回值：</p>
<ul>
<li>Float16 - 一个 Float16 类型的随机数。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/crypto/crypto_package_api/crypto_package_exceptions.html#class-securerandomexception">SecureRandomException</a> - 当生成器不能正确生成随机数或生成随机数失败时，抛出异常。</li>
</ul>
<h3 id="func-nextfloat32"><a class="header" href="#func-nextfloat32">func nextFloat32()</a></h3>
<pre><code class="language-cangjie">public func nextFloat32(): Float32
</code></pre>
<p>功能：获取一个 Float32 类型且在区间 [0.0, 1.0) 内的随机数。</p>
<p>返回值：</p>
<ul>
<li>Float32 - 一个 Float32 类型的随机数。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/crypto/crypto_package_api/crypto_package_exceptions.html#class-securerandomexception">SecureRandomException</a> - 当生成器不能正确生成随机数或生成随机数失败时，抛出异常。</li>
</ul>
<h3 id="func-nextfloat64"><a class="header" href="#func-nextfloat64">func nextFloat64()</a></h3>
<pre><code class="language-cangjie">public func nextFloat64(): Float64
</code></pre>
<p>功能：获取一个 Float64 类型且在区间 [0.0, 1.0) 内的随机数。</p>
<p>返回值：</p>
<ul>
<li>Float64 - 一个 Float64 类型的随机数。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/crypto/crypto_package_api/crypto_package_exceptions.html#class-securerandomexception">SecureRandomException</a> - 当生成器不能正确生成随机数或生成随机数失败时，抛出异常。</li>
</ul>
<h3 id="func-nextgaussianfloat16float16-float16"><a class="header" href="#func-nextgaussianfloat16float16-float16">func nextGaussianFloat16(Float16, Float16)</a></h3>
<pre><code class="language-cangjie">public func nextGaussianFloat16(mean!: Float16 = 0.0, sigma!: Float16 = 1.0): Float16
</code></pre>
<p>功能：默认获取一个 Float16 类型且符合均值为 0.0 标准差为 1.0 的高斯分布的随机数，其中均值是期望值，可解释为位置参数，决定了分布的位置，标准差可解释为尺度参数，决定了分布的幅度。</p>
<p>参数：</p>
<ul>
<li>mean!: Float16 - 均值。</li>
<li>sigma!: Float16 - 标准差。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Float16 - 一个 Float16 类型的随机数。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/crypto/crypto_package_api/crypto_package_exceptions.html#class-securerandomexception">SecureRandomException</a> - 当生成器不能正确生成随机数或生成随机数失败时，抛出异常。</li>
</ul>
<h3 id="func-nextgaussianfloat32float32-float32"><a class="header" href="#func-nextgaussianfloat32float32-float32">func nextGaussianFloat32(Float32, Float32)</a></h3>
<pre><code class="language-cangjie">public func nextGaussianFloat32(mean!: Float32 = 0.0, sigma!: Float32 = 1.0): Float32
</code></pre>
<p>功能：默认获取一个 Float32 类型且符合均值为 0.0 标准差为 1.0 的高斯分布的随机数，其中均值是期望值，可解释为位置参数，决定了分布的位置，标准差可解释为尺度参数，决定了分布的幅度。</p>
<p>参数：</p>
<ul>
<li>mean!: Float32 - 均值。</li>
<li>sigma!: Float32 - 标准差。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Float32 - 一个 Float32 类型的随机数。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/crypto/crypto_package_api/crypto_package_exceptions.html#class-securerandomexception">SecureRandomException</a> - 当生成器不能正确生成随机数或生成随机数失败时，抛出异常。</li>
</ul>
<h3 id="func-nextgaussianfloat64float64-float64"><a class="header" href="#func-nextgaussianfloat64float64-float64">func nextGaussianFloat64(Float64, Float64)</a></h3>
<pre><code class="language-cangjie">public func nextGaussianFloat64(mean!: Float64 = 0.0, sigma!: Float64 = 1.0): Float64
</code></pre>
<p>功能：默认获取一个 Float64 类型且符合均值为 0.0 标准差为 1.0 的高斯分布的随机数，其中均值是期望值，可解释为位置参数，决定了分布的位置，标准差可解释为尺度参数，决定了分布的幅度。</p>
<p>参数：</p>
<ul>
<li>mean!: Float64 - 均值。</li>
<li>sigma!: Float64 - 标准差。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Float64 - 一个 Float64 类型的随机数。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/crypto/crypto_package_api/crypto_package_exceptions.html#class-securerandomexception">SecureRandomException</a> - 当生成器不能正确生成随机数或生成随机数失败时，抛出异常。</li>
</ul>
<h3 id="func-nextint16"><a class="header" href="#func-nextint16">func nextInt16()</a></h3>
<pre><code class="language-cangjie">public func nextInt16(): Int16
</code></pre>
<p>功能：获取一个 Int16 类型的随机数。</p>
<p>返回值：</p>
<ul>
<li>Int16 - 一个 Int16 类型的随机数。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/crypto/crypto_package_api/crypto_package_exceptions.html#class-securerandomexception">SecureRandomException</a> - 当生成器不能正确生成随机数或生成随机数失败时，抛出异常。</li>
</ul>
<h3 id="func-nextint32"><a class="header" href="#func-nextint32">func nextInt32()</a></h3>
<pre><code class="language-cangjie">public func nextInt32(): Int32
</code></pre>
<p>功能：获取一个 Int32 类型的随机数。</p>
<p>返回值：</p>
<ul>
<li>Int32 - 一个 Int32 类型的随机数。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/crypto/crypto_package_api/crypto_package_exceptions.html#class-securerandomexception">SecureRandomException</a> - 当生成器不能正确生成随机数或生成随机数失败时，抛出异常。</li>
</ul>
<h3 id="func-nextint16int16"><a class="header" href="#func-nextint16int16">func nextInt16(Int16)</a></h3>
<pre><code class="language-cangjie">public func nextInt16(max: Int16): Int16
</code></pre>
<p>功能：获取一个 Int16 类型且在区间 [0, max) 内的随机数。</p>
<p>参数：</p>
<ul>
<li>max: Int16 - 区间最大值。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Int16 - 一个 Int16 类型的随机数。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 当 max 为非正数时，抛出异常。</li>
<li><a href="crypto/crypto/crypto_package_api/crypto_package_exceptions.html#class-securerandomexception">SecureRandomException</a> - 当生成器不能正确生成随机数或生成随机数失败时，抛出异常。</li>
</ul>
<h3 id="func-nextint32int32"><a class="header" href="#func-nextint32int32">func nextInt32(Int32)</a></h3>
<pre><code class="language-cangjie">public func nextInt32(max: Int32): Int32
</code></pre>
<p>功能：获取一个 Int32 类型且在区间 [0, max) 内的随机数。</p>
<p>参数：</p>
<ul>
<li>max: Int32 - 区间最大值。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Int32 - 一个 Int32 类型的随机数。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 当 max 为非正数时，抛出异常。</li>
<li><a href="crypto/crypto/crypto_package_api/crypto_package_exceptions.html#class-securerandomexception">SecureRandomException</a> - 当生成器不能正确生成随机数或生成随机数失败时，抛出异常。</li>
</ul>
<h3 id="func-nextint64"><a class="header" href="#func-nextint64">func nextInt64()</a></h3>
<pre><code class="language-cangjie">public func nextInt64(): Int64
</code></pre>
<p>功能：获取一个 Int64 类型的随机数。</p>
<p>返回值：</p>
<ul>
<li>Int64 - 一个 Int64 类型的随机数。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/crypto/crypto_package_api/crypto_package_exceptions.html#class-securerandomexception">SecureRandomException</a> - 当生成器不能正确生成随机数或生成随机数失败时，抛出异常。</li>
</ul>
<h3 id="func-nextint64int64"><a class="header" href="#func-nextint64int64">func nextInt64(Int64)</a></h3>
<pre><code class="language-cangjie">public func nextInt64(max: Int64): Int64
</code></pre>
<p>功能：获取一个 Int64 类型且在区间 [0, max) 内的随机数。</p>
<p>参数：</p>
<ul>
<li>max: Int64 - 区间最大值。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Int64 - 一个 Int64 类型的随机数。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 当 max 为非正数时，抛出异常。</li>
<li><a href="crypto/crypto/crypto_package_api/crypto_package_exceptions.html#class-securerandomexception">SecureRandomException</a> - 当生成器不能正确生成随机数或生成随机数失败时，抛出异常。</li>
</ul>
<h3 id="func-nextint8"><a class="header" href="#func-nextint8">func nextInt8()</a></h3>
<pre><code class="language-cangjie">public func nextInt8(): Int8
</code></pre>
<p>功能：获取一个 Int8 类型的随机数。</p>
<p>返回值：</p>
<ul>
<li>Int8 - 一个 Int8 类型的随机数。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/crypto/crypto_package_api/crypto_package_exceptions.html#class-securerandomexception">SecureRandomException</a> - 当生成器不能正确生成随机数或生成随机数失败时，抛出异常。</li>
</ul>
<h3 id="func-nextint8int8"><a class="header" href="#func-nextint8int8">func nextInt8(Int8)</a></h3>
<pre><code class="language-cangjie">public func nextInt8(max: Int8): Int8
</code></pre>
<p>功能：获取一个 Int8 类型且在区间 [0, max) 内的随机数。</p>
<p>参数：</p>
<ul>
<li>max: Int8 - 区间最大值。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Int8 - 一个 Int8 类型的随机数。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 当 max 为非正数时，抛出异常。</li>
<li><a href="crypto/crypto/crypto_package_api/crypto_package_exceptions.html#class-securerandomexception">SecureRandomException</a> - 当生成器不能正确生成随机数或生成随机数失败时，抛出异常。</li>
</ul>
<h3 id="func-nextuint16"><a class="header" href="#func-nextuint16">func nextUInt16()</a></h3>
<pre><code class="language-cangjie">public func nextUInt16(): UInt16
</code></pre>
<p>功能：获取一个 UInt16 类型的随机数。</p>
<p>返回值：</p>
<ul>
<li>UInt16 - 一个 UInt16 类型的随机数。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/crypto/crypto_package_api/crypto_package_exceptions.html#class-securerandomexception">SecureRandomException</a> - 当生成器不能正确生成随机数或生成随机数失败时，抛出异常。</li>
</ul>
<h3 id="func-nextuint16uint16"><a class="header" href="#func-nextuint16uint16">func nextUInt16(UInt16)</a></h3>
<pre><code class="language-cangjie">public func nextUInt16(max: UInt16): UInt16
</code></pre>
<p>功能：获取一个 UInt16 类型且在区间 [0, max) 内的随机数。</p>
<p>参数：</p>
<ul>
<li>max: UInt16 - 区间最大值。</li>
</ul>
<p>返回值：</p>
<ul>
<li>UInt16 - 一个 UInt16 类型的随机数。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 当 max 为 0 时，抛出异常。</li>
<li><a href="crypto/crypto/crypto_package_api/crypto_package_exceptions.html#class-securerandomexception">SecureRandomException</a> - 当生成器不能正确生成随机数或生成随机数失败时，抛出异常。</li>
</ul>
<h3 id="func-nextuint32"><a class="header" href="#func-nextuint32">func nextUInt32()</a></h3>
<pre><code class="language-cangjie">public func nextUInt32(): UInt32
</code></pre>
<p>功能：获取一个 UInt32 类型的随机数。</p>
<p>返回值：</p>
<ul>
<li>UInt32 - 一个 UInt32 类型的随机数。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/crypto/crypto_package_api/crypto_package_exceptions.html#class-securerandomexception">SecureRandomException</a> - 当生成器不能正确生成随机数或生成随机数失败时，抛出异常。</li>
</ul>
<h3 id="func-nextuint32uint32"><a class="header" href="#func-nextuint32uint32">func nextUInt32(UInt32)</a></h3>
<pre><code class="language-cangjie">public func nextUInt32(max: UInt32): UInt32
</code></pre>
<p>功能：获取一个 UInt32 类型且在区间 [0, max) 内的随机数。</p>
<p>参数：</p>
<ul>
<li>max: UInt32 - 区间最大值。</li>
</ul>
<p>返回值：</p>
<ul>
<li>UInt32 - 一个 UInt32 类型的随机数。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 当 max 为 0 时，抛出异常。</li>
<li><a href="crypto/crypto/crypto_package_api/crypto_package_exceptions.html#class-securerandomexception">SecureRandomException</a> - 当生成器不能正确生成随机数或生成随机数失败时，抛出异常。</li>
</ul>
<h3 id="func-nextuint64"><a class="header" href="#func-nextuint64">func nextUInt64()</a></h3>
<pre><code class="language-cangjie">public func nextUInt64(): UInt64
</code></pre>
<p>功能：获取一个 UInt64 类型的随机数。</p>
<p>返回值：</p>
<ul>
<li>UInt64 - 一个 UInt64 类型的随机数。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/crypto/crypto_package_api/crypto_package_exceptions.html#class-securerandomexception">SecureRandomException</a> - 当生成器不能正确生成随机数或生成随机数失败时，抛出异常。</li>
</ul>
<h3 id="func-nextuint64uint64"><a class="header" href="#func-nextuint64uint64">func nextUInt64(UInt64)</a></h3>
<pre><code class="language-cangjie">public func nextUInt64(max: UInt64): UInt64
</code></pre>
<p>功能：获取一个 UInt64 类型且在区间 [0, max) 内的随机数。</p>
<p>参数：</p>
<ul>
<li>max: UInt64 - 区间最大值。</li>
</ul>
<p>返回值：</p>
<ul>
<li>UInt64 - 一个 UInt64 类型的随机数。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 当 max 为 0 时，抛出异常。</li>
<li><a href="crypto/crypto/crypto_package_api/crypto_package_exceptions.html#class-securerandomexception">SecureRandomException</a> - 当生成器不能正确生成随机数或生成随机数失败时，抛出异常。</li>
</ul>
<h3 id="func-nextuint8"><a class="header" href="#func-nextuint8">func nextUInt8()</a></h3>
<pre><code class="language-cangjie">public func nextUInt8(): UInt8
</code></pre>
<p>功能：获取一个 UInt8 类型的随机数。</p>
<p>返回值：</p>
<ul>
<li>UInt8 - 一个 UInt8 类型的随机数。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/crypto/crypto_package_api/crypto_package_exceptions.html#class-securerandomexception">SecureRandomException</a> - 当生成器不能正确生成随机数或生成随机数失败时，抛出异常。</li>
</ul>
<h3 id="func-nextuint8uint8"><a class="header" href="#func-nextuint8uint8">func nextUInt8(UInt8)</a></h3>
<pre><code class="language-cangjie">public func nextUInt8(max: UInt8): UInt8
</code></pre>
<p>功能：获取一个 UInt8 类型且在区间 [0, max) 内的随机数。</p>
<p>参数：</p>
<ul>
<li>max: UInt8 - 区间最大值。</li>
</ul>
<p>返回值：</p>
<ul>
<li>UInt8 - 一个 UInt8 类型的随机数。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 当 max 为 0 时，抛出异常。</li>
<li><a href="crypto/crypto/crypto_package_api/crypto_package_exceptions.html#class-securerandomexception">SecureRandomException</a> - 当生成器不能正确生成随机数或生成随机数失败时，抛出异常。</li>
</ul>
<h2 id="class-sm4"><a class="header" href="#class-sm4">class SM4</a></h2>
<pre><code class="language-cangjie">public class SM4 &lt;: BlockCipher {
    public init(
        optMode: OperationMode,
        key: Array&lt;Byte&gt;,
        iv!: Array&lt;Byte&gt; = Array&lt;Byte&gt;(),
        paddingMode!: PaddingMode = PaddingMode.PKCS7Padding,
        aad!: Array&lt;Byte&gt; = Array&lt;Byte&gt;(),
        tagSize!: Int64 = 16
    )
}
</code></pre>
<p>功能：提供国密SM4对称加解密。</p>
<p>目前 SM4 支持 的加解密工作模式由 <a href="crypto/crypto/crypto_package_api/crypto_package_structs.html#struct-operationmode">OperationMode</a> 定义，目前支持 ECB、CBC、OFB、CFB、CTR、GCM模式。</p>
<p>不同的工作模式可能对应的加解密实现不同，安全性也不同。需要选择和场景适配的加解密工作模式。</p>
<p>iv 初始化向量在 GCM 模式下可以设置推荐长度是12字节，在 CBC、OFB、CFB、CTR 模式下 iv 长度是16字节，在 ECB 模式下 iv 可以不设置。</p>
<p>paddingMode 填充模式模式由 <a href="crypto/crypto/crypto_package_api/crypto_package_structs.html#struct-paddingmode">PaddingMode</a> 定义， 目前支持 NoPadding 非填充、PKCS7Padding PKCS7填充。默认是 PKCS7 填充。</p>
<p>paddingMode 设置对ECB 和 CBC 有效，ECB 和 CBC 分组加解密需要分组长度等于 blockSize。会根据填充模式进行填充。 paddingMode 设置对 OFB、CFB、CTR、GCM 工作模式无效，这些工作模式均无需填充。</p>
<p>如果选择 NoPadding 模式，即不填充。则在 ECB 和 CBC 工作模式下用户需要对数据是否可以分组负责，如果数据不能分组，或者最后一组数据长度不足 blockSize 则会报错。</p>
<p>aad 附加数据，仅在 GCM 模式下使用，由用户填充，参与摘要计算，默认为空。</p>
<p>tagSize 设置摘要长度，仅在 GCM 模式下使用，默认值为 SM4_GCM_TAG_SIZE 16字节，最小不能低于12字节，最大不能超过16字节。</p>
<p>如果是 GCM 工作模式。加密结果的后 tagSize 字节是摘要数据。</p>
<p>使用示例见 <a href="crypto/crypto/crypto_package_api/../crypto_samples/sample_crypto.html#SM4-%E4%BD%BF%E7%94%A8">SM4 使用</a>。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>GCM 模式需要 OpenSSL 3.2 或者以上版本。</p>
</blockquote>
<p>父类型：</p>
<ul>
<li>BlockCipher</li>
</ul>
<h3 id="initoperationmode-arraybyte-arraybyte-paddingmode-arraybyte-int64"><a class="header" href="#initoperationmode-arraybyte-arraybyte-paddingmode-arraybyte-int64">init(OperationMode, Array&lt;Byte&gt;, Array&lt;Byte&gt;, PaddingMode, Array&lt;Byte&gt;, Int64)</a></h3>
<pre><code class="language-cangjie">    public init(
        optMode: OperationMode,
        key: Array&lt;Byte&gt;,
        iv!: Array&lt;Byte&gt; = Array&lt;Byte&gt;(),
        paddingMode!: PaddingMode = PaddingMode.PKCS7Padding,
        aad!: Array&lt;Byte&gt; = Array&lt;Byte&gt;(),
        tagSize!: Int64 = 16
    )
</code></pre>
<p>功能：创建 <a href="crypto/crypto/crypto_package_api/crypto_package_classes.html#class-sm4">SM4</a> 实例，可指定在不同工作模式下参数。</p>
<p>参数：</p>
<ul>
<li>optMode: <a href="crypto/crypto/crypto_package_api/crypto_package_structs.html#struct-operationmode">OperationMode</a> - 设置加解密工作模式。</li>
<li>key: Array&lt;Byte&gt; - 密钥，长度为16字节。</li>
<li>iv!: Array&lt;Byte&gt; - 初始化向量。</li>
<li>paddingMode!: <a href="crypto/crypto/crypto_package_api/crypto_package_structs.html#struct-paddingmode">PaddingMode</a> - 设置填充模式。</li>
<li>aad!: Array&lt;Byte&gt; - 设置附加数据。</li>
<li>tagSize!: Int64 - 设置摘要长度。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/crypto/crypto_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 参数设置不正确，实例化失败。</li>
</ul>
<h3 id="prop-aad"><a class="header" href="#prop-aad">prop aad</a></h3>
<pre><code class="language-cangjie">public prop aad: Array&lt;Byte&gt;
</code></pre>
<p>功能：附加数据。</p>
<p>类型：Array&lt;Byte&gt;</p>
<h3 id="prop-algorithm"><a class="header" href="#prop-algorithm">prop algorithm</a></h3>
<pre><code class="language-cangjie">public prop algorithm: String
</code></pre>
<p>功能：获取分组加解密算法的算法名称。</p>
<p>类型：String</p>
<h3 id="prop-blocksize"><a class="header" href="#prop-blocksize">prop blockSize</a></h3>
<pre><code class="language-cangjie">public prop blockSize: Int64
</code></pre>
<p>功能：分组长度，单位字节。</p>
<p>类型：Int64</p>
<h3 id="prop-keysize"><a class="header" href="#prop-keysize">prop keySize</a></h3>
<pre><code class="language-cangjie">public prop keySize: Int64
</code></pre>
<p>功能：密钥长度。</p>
<p>类型：Int64</p>
<h3 id="prop-key"><a class="header" href="#prop-key">prop key</a></h3>
<pre><code class="language-cangjie">public prop key: Array&lt;Byte&gt;
</code></pre>
<p>功能：密钥。</p>
<p>类型：Array&lt;Byte&gt;</p>
<h3 id="prop-optmode"><a class="header" href="#prop-optmode">prop optMode</a></h3>
<pre><code class="language-cangjie">public prop optMode: OperationMode
</code></pre>
<p>功能：工作模式。</p>
<p>类型：<a href="crypto/crypto/crypto_package_api/crypto_package_structs.html#struct-operationmode">OperationMode</a></p>
<h3 id="prop-paddingmode"><a class="header" href="#prop-paddingmode">prop paddingMode</a></h3>
<pre><code class="language-cangjie">public prop paddingMode: PaddingMode
</code></pre>
<p>功能：填充模式。</p>
<p>类型：<a href="crypto/crypto/crypto_package_api/crypto_package_structs.html#struct-paddingmode">PaddingMode</a></p>
<h3 id="prop-iv"><a class="header" href="#prop-iv">prop iv</a></h3>
<pre><code class="language-cangjie">public prop iv: Array&lt;Byte&gt;
</code></pre>
<p>功能：初始化向量。</p>
<p>类型：Array&lt;Byte&gt;</p>
<h3 id="prop-ivsize"><a class="header" href="#prop-ivsize">prop ivSize</a></h3>
<pre><code class="language-cangjie">public prop ivSize: Int64
</code></pre>
<p>功能：初始化向量长度。</p>
<p>类型：Int64</p>
<h3 id="prop-tagsize"><a class="header" href="#prop-tagsize">prop tagSize</a></h3>
<pre><code class="language-cangjie">public prop tagSize: Int64
</code></pre>
<p>功能：摘要长度。</p>
<p>类型：Int64</p>
<h3 id="func-encryptarraybyte"><a class="header" href="#func-encryptarraybyte">func encrypt(Array&lt;Byte&gt;)</a></h3>
<pre><code class="language-cangjie">public func encrypt(input: Array&lt;Byte&gt;): Array&lt;Byte&gt;
</code></pre>
<p>功能：加密一段数据数据。</p>
<p>参数：</p>
<ul>
<li>input: Array&lt;Byte&gt; - 输入字节序列。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Array&lt;Byte&gt; - 加密后的结果。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/crypto/crypto_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 加密失败，抛出异常。</li>
</ul>
<h3 id="func-encryptarraybyte-arraybyte"><a class="header" href="#func-encryptarraybyte-arraybyte">func encrypt(Array&lt;Byte&gt;, Array&lt;Byte&gt;)</a></h3>
<pre><code class="language-cangjie">public func encrypt(input: Array&lt;Byte&gt;, to!: Array&lt;Byte&gt;): Int64
</code></pre>
<p>功能：加密一段数据数据，指定输出数组长度会影响加解密结果。一般而言选填充模式，指定的密文数组长度不能小于明文数组长度加上一个 blockSize。</p>
<p>参数：</p>
<ul>
<li>input: Array&lt;Byte&gt; - 待进行加密的数据。</li>
<li>to!: Array&lt;Byte&gt; - 输出数组。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Int64 - 输出长度。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/crypto/crypto_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 加密失败，抛出异常。</li>
<li>IllegalArgumentException - 当 to 的 size = 0 时，抛出异常。</li>
</ul>
<h3 id="func-encryptinputstream-outputstream"><a class="header" href="#func-encryptinputstream-outputstream">func encrypt(InputStream, OutputStream)</a></h3>
<pre><code class="language-cangjie">public func encrypt(input: InputStream, output: OutputStream)
</code></pre>
<p>功能：对输入流进行加密，一般如果数据过大无法一次对其加密，可以对数据流进行加密。</p>
<p>参数：</p>
<ul>
<li>input:InputStream  - 待加密的输入数据流。</li>
<li>output: OutputStream - 解密后的输出数据流。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/crypto/crypto_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 加密失败，抛出异常。</li>
</ul>
<h3 id="func-decryptarraybyte"><a class="header" href="#func-decryptarraybyte">func decrypt(Array&lt;Byte&gt;)</a></h3>
<pre><code class="language-cangjie">public func decrypt(input: Array&lt;Byte&gt;): Array&lt;Byte&gt;
</code></pre>
<p>功能：解密一段数据数据。</p>
<p>参数：</p>
<ul>
<li>input: Array&lt;Byte&gt; - 输入字节序列。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Array&lt;Byte&gt; - 解密后的结果。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/crypto/crypto_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 解密失败，抛出异常。</li>
</ul>
<h3 id="func-decryptarraybyte-arraybyte"><a class="header" href="#func-decryptarraybyte-arraybyte">func decrypt(Array&lt;Byte&gt;, Array&lt;Byte&gt;)</a></h3>
<pre><code class="language-cangjie">public func decrypt(input: Array&lt;Byte&gt;,  to!: Array&lt;Byte&gt;): Int64
</code></pre>
<p>功能：解密一段数据数据，指定输出数组长度会影响加解密结果。一般而言，指定的明文数组长度不能小于密文数组长度减去一个 blockSize。</p>
<p>参数：</p>
<ul>
<li>input: Array&lt;Byte&gt; - 待进行解密的数据。</li>
<li>to!: Array&lt;Byte&gt; - 输出数组。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Int64 - 输出长度。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/crypto/crypto_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 解密失败，抛出异常。</li>
<li>IllegalArgumentException - 当 to 的 size = 0 时，抛出异常。</li>
</ul>
<h3 id="func-decryptinputstream-outputstream"><a class="header" href="#func-decryptinputstream-outputstream">func decrypt(InputStream, OutputStream)</a></h3>
<pre><code class="language-cangjie">public func decrypt(input: InputStream, output: OutputStream)
</code></pre>
<p>功能：对输入流进行解密，一般如果数据过大无法一次对其解密，可以对数据流进行解密。</p>
<p>参数：</p>
<ul>
<li>input:InputStream  - 待解密的输入数据流。</li>
<li>output: OutputStream - 解密后的输出数据流。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/crypto/crypto_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 解密失败，抛出异常。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="结构体-1"><a class="header" href="#结构体-1">结构体</a></h1>
<h2 id="struct-operationmode"><a class="header" href="#struct-operationmode">struct OperationMode</a></h2>
<pre><code class="language-cangjie">public struct OperationMode &lt;: ToString &amp; Equatable&lt;OperationMode&gt; {
    public static let ECB
    public static let CBC
    public static let OFB
    public static let CFB
    public static let CTR
    public static let GCM
    public let mode: String
}
</code></pre>
<p>功能: 对称加解密算法的工作模式。</p>
<p>父类型：</p>
<ul>
<li>ToString</li>
<li>Equatable&lt;<a href="crypto/crypto/crypto_package_api/crypto_package_structs.html#struct-operationmode">OperationMode</a>&gt;</li>
</ul>
<h3 id="static-let-ecb"><a class="header" href="#static-let-ecb">static let ECB</a></h3>
<pre><code class="language-cangjie">public static let ECB
</code></pre>
<p>功能：Electronic CodeBook(单子密码本)工作模式， ECB 初始值是 <a href="crypto/crypto/crypto_package_api/crypto_package_structs.html#struct-operationmode">OperationMode</a>(&quot;ECB&quot;)。</p>
<p>类型：<a href="crypto/crypto/crypto_package_api/crypto_package_structs.html#struct-operationmode">OperationMode</a></p>
<h3 id="static-let-cbc"><a class="header" href="#static-let-cbc">static let CBC</a></h3>
<pre><code class="language-cangjie">public static let CBC
</code></pre>
<p>功能：Cipher Block Chaining(密码分组链接)工作模式，CBC 初始值是 <a href="crypto/crypto/crypto_package_api/crypto_package_structs.html#struct-operationmode">OperationMode</a>(&quot;CBC&quot;)。</p>
<p>类型：<a href="crypto/crypto/crypto_package_api/crypto_package_structs.html#struct-operationmode">OperationMode</a></p>
<h3 id="static-let-ofb"><a class="header" href="#static-let-ofb">static let OFB</a></h3>
<pre><code class="language-cangjie">public static let OFB
</code></pre>
<p>功能：Output FeedBack(输出反馈)工作模式，OFB 初始值是 <a href="crypto/crypto/crypto_package_api/crypto_package_structs.html#struct-operationmode">OperationMode</a>(&quot;OFB&quot;)。</p>
<p>类型：<a href="crypto/crypto/crypto_package_api/crypto_package_structs.html#struct-operationmode">OperationMode</a></p>
<h3 id="static-let-cfb"><a class="header" href="#static-let-cfb">static let CFB</a></h3>
<pre><code class="language-cangjie">public static let CFB
</code></pre>
<p>功能：Output FeedBack(密文反馈)工作模式，CFB 初始值是 <a href="crypto/crypto/crypto_package_api/crypto_package_structs.html#struct-operationmode">OperationMode</a>(&quot;CFB&quot;)。</p>
<p>类型：<a href="crypto/crypto/crypto_package_api/crypto_package_structs.html#struct-operationmode">OperationMode</a></p>
<h3 id="static-let-ctr"><a class="header" href="#static-let-ctr">static let CTR</a></h3>
<pre><code class="language-cangjie">public static let CTR
</code></pre>
<p>功能：CounTeR(计数器)工作模式，CTR 初始值是 <a href="crypto/crypto/crypto_package_api/crypto_package_structs.html#struct-operationmode">OperationMode</a>(&quot;CTR&quot;)。</p>
<p>类型：<a href="crypto/crypto/crypto_package_api/crypto_package_structs.html#struct-operationmode">OperationMode</a></p>
<h3 id="static-let-gcm"><a class="header" href="#static-let-gcm">static let GCM</a></h3>
<pre><code class="language-cangjie">public static let GCM
</code></pre>
<p>功能：Galois Counter(伽罗瓦计数器)工作模式，GCM 初始值是 <a href="crypto/crypto/crypto_package_api/crypto_package_structs.html#struct-operationmode">OperationMode</a>(&quot;GCM&quot;)。</p>
<p>类型：<a href="crypto/crypto/crypto_package_api/crypto_package_structs.html#struct-operationmode">OperationMode</a></p>
<h3 id="let-mode"><a class="header" href="#let-mode">let mode</a></h3>
<pre><code class="language-cangjie">public let mode: String
</code></pre>
<p>功能：operation 分组加解密的工作模式，目前支持 ECB、CBC CFB OFB CTR GCM。</p>
<p>类型：String</p>
<h3 id="func-tostring"><a class="header" href="#func-tostring">func toString()</a></h3>
<pre><code class="language-cangjie">public override func toString(): String
</code></pre>
<p>功能：获取工作模式字符串。</p>
<p>返回值：</p>
<ul>
<li>String - 工作模式字符串。</li>
</ul>
<h3 id="func-operationmode"><a class="header" href="#func-operationmode">func ==(OperationMode)</a></h3>
<pre><code class="language-cangjie">public operator override func ==(other: OperationMode): Bool
</code></pre>
<p>功能：工作模式比较是否相同。</p>
<p>参数：</p>
<ul>
<li>other: <a href="crypto/crypto/crypto_package_api/crypto_package_structs.html#struct-operationmode">OperationMode</a> - 工作模式。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - true 相同，false 不相同。</li>
</ul>
<h3 id="func-operationmode-1"><a class="header" href="#func-operationmode-1">func !=(OperationMode)</a></h3>
<pre><code class="language-cangjie">public operator override func !=(other: OperationMode): Bool
</code></pre>
<p>功能：工作模式比较是否不相同。</p>
<p>参数：</p>
<ul>
<li>other: <a href="crypto/crypto/crypto_package_api/crypto_package_structs.html#struct-operationmode">OperationMode</a> - 工作模式。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - true 不相同，false 相同。</li>
</ul>
<h2 id="struct-paddingmode"><a class="header" href="#struct-paddingmode">struct PaddingMode</a></h2>
<pre><code class="language-cangjie">public struct PaddingMode &lt;: Equatable&lt;PaddingMode&gt; {
    public static let NoPadding: PaddingMode
    public static let PKCS7Padding: PaddingMode
    public let paddingType: Int64
}
</code></pre>
<p>功能: 对称加解密算法的填充模式。</p>
<p>父类型：</p>
<ul>
<li>Equatable&lt;<a href="crypto/crypto/crypto_package_api/crypto_package_structs.html#struct-paddingmode">PaddingMode</a>&gt;</li>
</ul>
<h3 id="static-let-nopadding"><a class="header" href="#static-let-nopadding">static let NoPadding</a></h3>
<pre><code class="language-cangjie">public static let NoPadding: PaddingMode
</code></pre>
<p>功能：不填充，NoPadding 初始值是 <a href="crypto/crypto/crypto_package_api/crypto_package_structs.html#struct-paddingmode">PaddingMode</a>(0)。</p>
<p>类型：<a href="crypto/crypto/crypto_package_api/crypto_package_structs.html#struct-paddingmode">PaddingMode</a></p>
<h3 id="static-let-pkcs7padding"><a class="header" href="#static-let-pkcs7padding">static let PKCS7Padding</a></h3>
<pre><code class="language-cangjie">public static let PKCS7Padding: PaddingMode
</code></pre>
<p>功能：采用PKCS7协议填充，PKCS7Padding 初始值是 <a href="crypto/crypto/crypto_package_api/crypto_package_structs.html#struct-paddingmode">PaddingMode</a>(1)。</p>
<p>类型：<a href="crypto/crypto/crypto_package_api/crypto_package_structs.html#struct-paddingmode">PaddingMode</a></p>
<h3 id="let-paddingtype"><a class="header" href="#let-paddingtype">let paddingType</a></h3>
<pre><code class="language-cangjie">public let paddingType: Int64
</code></pre>
<p>功能：分组加解密填充方式，目前支持非填充和 pkcs7 填充。</p>
<p>类型：Int64</p>
<h3 id="func-paddingmode"><a class="header" href="#func-paddingmode">func ==(PaddingMode)</a></h3>
<pre><code class="language-cangjie">public operator override func ==(other: PaddingMode): Bool
</code></pre>
<p>功能：填充模式比较是否相同。</p>
<p>参数：</p>
<ul>
<li>other: <a href="crypto/crypto/crypto_package_api/crypto_package_structs.html#struct-paddingmode">PaddingMode</a> - 填充模式。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - true 相同，false 不相同。</li>
</ul>
<h3 id="func-paddingmode-1"><a class="header" href="#func-paddingmode-1">func !=(PaddingMode)</a></h3>
<pre><code class="language-cangjie">public operator override func !=(other: PaddingMode): Bool
</code></pre>
<p>功能：工作模式比较是否不相同。</p>
<p>参数：</p>
<ul>
<li>other: <a href="crypto/crypto/crypto_package_api/crypto_package_structs.html#struct-paddingmode">PaddingMode</a>  - 填充模式。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - true 不相同，false 相同。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="异常类-3"><a class="header" href="#异常类-3">异常类</a></h1>
<h2 id="class-securerandomexception"><a class="header" href="#class-securerandomexception">class SecureRandomException</a></h2>
<pre><code class="language-cangjie">public class SecureRandomException &lt;: Exception {
    public init()
    public init(message: String)
}
</code></pre>
<p>功能：crypto 包安全随机数的异常类。</p>
<p>父类型：</p>
<ul>
<li>Exception</li>
</ul>
<h3 id="init"><a class="header" href="#init">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：创建默认的  <a href="crypto/crypto/crypto_package_api/crypto_package_exceptions.html#class-securerandomexception">SecureRandomException</a> 实例，异常提示消息为空。</p>
<h3 id="initstring-1"><a class="header" href="#initstring-1">init(String)</a></h3>
<pre><code class="language-cangjie">public init(message: String)
</code></pre>
<p>功能：根据异常信息创建 <a href="crypto/crypto/crypto_package_api/crypto_package_exceptions.html#class-securerandomexception">SecureRandomException</a> 实例。</p>
<p>参数：</p>
<ul>
<li>message: String - 异常提示信息。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="securerandom-使用"><a class="header" href="#securerandom-使用">SecureRandom 使用</a></h1>
<p>Random 创建随机数对象。</p>
<p>示例：</p>
<!-- run -->
<pre><code class="language-cangjie">import stdx.crypto.crypto.*

main() {
    let r = SecureRandom()
    for (_ in 0..10) {
        let flip = r.nextBool()
        println(flip)
    }
    return 0
}
</code></pre>
<p>运行结果：</p>
<blockquote>
<p><strong>说明</strong></p>
<p>可能出现的运行结果如下（true/false 的选择是随机的）。</p>
</blockquote>
<pre><code class="language-text">false
true
false
false
false
true
true
false
false
true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sm4-使用"><a class="header" href="#sm4-使用">SM4 使用</a></h1>
<p>SM4 加解密数据。</p>
<p>示例：</p>
<!-- verify -->
<pre><code class="language-cangjie">import stdx.crypto.crypto.*
import stdx.encoding.hex.fromHexString

main() {
    var plains = &quot;hello cangjie!&quot;
    var key = &quot;1234567890123456&quot;
    var iv = &quot;1234567890123456&quot;
    var sm4 = SM4(OperationMode.CBC, key.toArray(), iv: iv.toArray())
    var enRe = sm4.encrypt(plains.toArray())
    var dd = sm4.decrypt(enRe)
    println(String.fromUtf8(dd))
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-text">hello cangjie!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdxcryptodigest"><a class="header" href="#stdxcryptodigest">stdx.crypto.digest</a></h1>
<h2 id="功能介绍-2"><a class="header" href="#功能介绍-2">功能介绍</a></h2>
<p>digest 包提供常用的消息摘要算法，包括 MD5、SHA1、SHA224、SHA256、SHA384、SHA512、HMAC、SM3等。</p>
<p>使用本包需要外部依赖 OpenSSL 3 的 crypto 动态库文件，故使用前需安装相关工具。</p>
<ul>
<li>
<p>对于 Linux 操作系统，可参考以下方式：</p>
<ul>
<li>如果系统的包管理工具支持安装 OpenSSL 3 开发工具包，可通过这个方式安装，并确保系统安装目录下含有 libcrypto.so 和 libcrypto.so.3 这两个动态库文件，例如 Ubuntu 22.04 系统上可使用 sudo apt install libssl-dev 命令安装 libssl-dev 工具包；</li>
<li>如果无法通过上面的方式安装，可自行下载 OpenSSL 3.x.x 源码编译安装软件包，并确保安装目录下含有 libcrypto.so 和 libcrypto.so.3 这两个动态库文件，然后可选择下面任意一种方式来保证系统链接器可以找到这些文件:
<ul>
<li>在系统未安装 OpenSSL 的场景，安装时选择直接安装到系统路径下；</li>
<li>安装在自定义目录的场景，将这些文件所在目录设置到环境变量 LD_LIBRARY_PATH 以及 LIBRARY_PATH 中。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>对于 Windows 操作系统，可按照以下步骤：</p>
<ul>
<li>自行下载 OpenSSL 3.x.x 源码编译安装 x64 架构软件包或者自行下载安装第三方预编译的供开发人员使用的 OpenSSL 3.x.x 软件包；</li>
<li>确保安装目录下含有 libcrypto.dll.a（或 libcrypto.lib）、libcrypto-3-x64.dll 这两个库文件；</li>
<li>将 libcrypto.dll.a（或 libcrypto.lib）所在的目录路径设置到环境变量 LIBRARY_PATH 中，将 libcrypto-3-x64.dll 所在的目录路径设置到环境变量 PATH 中。</li>
</ul>
</li>
<li>
<p>对于 macOS 操作系统，可参考以下方式：</p>
<ul>
<li>使用 brew install openssl@3 安装，并确保系统安装目录下含有 libcrypto.dylib 和 libcrypto.3.dylib 这两个动态库文件；</li>
<li>如果无法通过上面的方式安装，可自行下载 OpenSSL 3.x.x 源码编译安装软件包，并确保安装目录下含有 libcrypto.dylib 和 libcrypto.3.dylib 这两个动态库文件，然后可选择下面任意一种方式来保证系统链接器可以找到这些文件:
<ul>
<li>在系统未安装 OpenSSL 的场景，安装时选择直接安装到系统路径下；</li>
<li>安装在自定义目录的场景，将这些文件所在目录设置到环境变量 DYLD_LIBRARY_PATH 以及 LIBRARY_PATH 中。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>说明：</strong></p>
<p>如果未安装 OpenSSL 3 软件包或者安装低版本的软件包，程序可能无法使用并抛出相关异常 CryptoException：Can not load openssl library or function xxx。</p>
</blockquote>
<h2 id="api-列表-2"><a class="header" href="#api-列表-2">API 列表</a></h2>
<h3 id="类-4"><a class="header" href="#类-4">类</a></h3>
<div class="table-wrapper"><table><thead><tr><th>类名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="crypto/digest/./digest_package_api/digest_package_classes.html#class-hmac">HMAC</a></td><td>HMAC摘要算法。</td></tr>
<tr><td><a href="crypto/digest/./digest_package_api/digest_package_classes.html#class-md5">MD5</a></td><td>MD5摘要算法。</td></tr>
<tr><td><a href="crypto/digest/./digest_package_api/digest_package_classes.html#class-sha1">SHA1</a></td><td>SHA1摘要算法。</td></tr>
<tr><td><a href="crypto/digest/./digest_package_api/digest_package_classes.html#class-sha224">SHA224</a></td><td>SHA224摘要算法。</td></tr>
<tr><td><a href="crypto/digest/./digest_package_api/digest_package_classes.html#class-sha256">SHA256</a></td><td>SHA256摘要算法。</td></tr>
<tr><td><a href="crypto/digest/./digest_package_api/digest_package_classes.html#class-sha384">SHA384</a></td><td>SHA384摘要算法。</td></tr>
<tr><td><a href="crypto/digest/./digest_package_api/digest_package_classes.html#class-sha512">SHA512</a></td><td>SHA512摘要算法。</td></tr>
<tr><td><a href="crypto/digest/./digest_package_api/digest_package_classes.html#class-sm3">SM3</a></td><td>SM3摘要算法。</td></tr>
</tbody></table>
</div>
<h3 id="结构体-2"><a class="header" href="#结构体-2">结构体</a></h3>
<div class="table-wrapper"><table><thead><tr><th>结构体名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="crypto/digest/./digest_package_api/digest_package_structs.html#struct-hashType">HashType</a></td><td>摘要算法类型。</td></tr>
</tbody></table>
</div>
<h3 id="异常类-4"><a class="header" href="#异常类-4">异常类</a></h3>
<div class="table-wrapper"><table><thead><tr><th>异常类名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="crypto/digest/./digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a></td><td><code>crypto</code> 包的异常类。</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="类-5"><a class="header" href="#类-5">类</a></h1>
<h2 id="class-hmac"><a class="header" href="#class-hmac">class HMAC</a></h2>
<pre><code class="language-cangjie">public class HMAC &lt;: Digest {
    public init(key: Array&lt;Byte&gt;, digest: () -&gt; Digest)
    public init(key: Array&lt;Byte&gt;, algorithm: HashType)
}
</code></pre>
<p>功能：提供 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-hmac">HMAC</a> 算法的实现。目前支持的摘要算法包括 MD5、SHA1、SHA224、SHA256、SHA384、SHA512、SM3。</p>
<p>父类型：</p>
<ul>
<li>Digest</li>
</ul>
<h3 id="prop-algorithm-1"><a class="header" href="#prop-algorithm-1">prop algorithm</a></h3>
<pre><code class="language-cangjie">public prop algorithm: String
</code></pre>
<p>功能：<a href="crypto/digest/digest_package_api/digest_package_classes.html#class-hmac">HMAC</a> 所选 Hash 算法的算法名称。</p>
<p>类型：String</p>
<h3 id="prop-blocksize-1"><a class="header" href="#prop-blocksize-1">prop blockSize</a></h3>
<pre><code class="language-cangjie">public prop blockSize: Int64
</code></pre>
<p>功能：<a href="crypto/digest/digest_package_api/digest_package_classes.html#class-hmac">HMAC</a> 所选 Hash 算法信息块长度，单位字节。</p>
<p>类型：Int64</p>
<h3 id="prop-size"><a class="header" href="#prop-size">prop size</a></h3>
<pre><code class="language-cangjie">public prop size: Int64
</code></pre>
<p>功能：<a href="crypto/digest/digest_package_api/digest_package_classes.html#class-hmac">HMAC</a> 所选 Hash 算法的摘要信息长度，单位字节。</p>
<p>类型：Int64</p>
<h3 id="initarraybyte----digest"><a class="header" href="#initarraybyte----digest">init(Array&lt;Byte&gt;, () -&gt; Digest)</a></h3>
<pre><code class="language-cangjie">public init(key: Array&lt;Byte&gt;, digest: () -&gt; Digest)
</code></pre>
<p>功能：构造函数，创建 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-hmac">HMAC</a> 对象。</p>
<p>参数：</p>
<ul>
<li>key: Array&lt;Byte&gt; - 密钥，建议该参数不小于所选Hash算法摘要的长度。</li>
<li>digest: () -&gt; Digest - hash 算法。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - key 值为空时，抛出异常。</li>
</ul>
<h3 id="initarraybyte-hashtype"><a class="header" href="#initarraybyte-hashtype">init(Array&lt;Byte&gt;, HashType)</a></h3>
<pre><code class="language-cangjie">public init(key: Array&lt;Byte&gt;, algorithm: HashType)
</code></pre>
<p>功能：构造函数，创建 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-hmac">HMAC</a> 对象。</p>
<p>参数：</p>
<ul>
<li>key: Array&lt;Byte&gt; - 密钥，建议该参数不小于所选Hash算法摘要的长度。</li>
<li>algorithm: <a href="crypto/digest/digest_package_api/digest_package_structs.html#struct-hashtype">HashType</a> - hash 算法。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - key 值为空时，抛出异常。</li>
</ul>
<h3 id="static-func-equalarraybyte-arraybyte"><a class="header" href="#static-func-equalarraybyte-arraybyte">static func equal(Array&lt;Byte&gt;, Array&lt;Byte&gt;)</a></h3>
<pre><code class="language-cangjie">public static func equal(mac1: Array&lt;Byte&gt;, mac2: Array&lt;Byte&gt;): Bool
</code></pre>
<p>功能：比较两个信息摘要是否相等，且不泄露比较时间，即比较不采用传统短路原则，从而防止 timing attack 类型的攻击。</p>
<p>参数：</p>
<ul>
<li>mac1: Array&lt;Byte&gt; - 需要比较的信息摘要序列。</li>
<li>mac2: Array&lt;Byte&gt; - 需要比较的信息摘要序列。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - 信息摘要是否相同, true 相同, false 不相同。</li>
</ul>
<h3 id="func-finish"><a class="header" href="#func-finish">func finish()</a></h3>
<pre><code class="language-cangjie">public func finish(): Array&lt;Byte&gt;
</code></pre>
<p>功能：返回生成的信息摘要值，注意调用 finish 后不可以再进行摘要计算，如重新计算需要 reset 重置上下文。</p>
<p>返回值：</p>
<ul>
<li>Array&lt;Byte&gt; - 生成的信息摘要字节序列。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 未重置上下文再次调用 finish 进行摘要计算，抛此异常。</li>
</ul>
<h3 id="func-finisharraybyte"><a class="header" href="#func-finisharraybyte">func finish(Array&lt;Byte&gt;)</a></h3>
<pre><code class="language-cangjie">public func finish(to!: Array&lt;Byte&gt;): Unit
</code></pre>
<p>功能：获取生成的信息摘要值，注意调用 finish 后不可以再进行摘要计算，如重新计算需要 reset 重置上下文。</p>
<p>参数：</p>
<ul>
<li>to!: Array&lt;Byte&gt; - 目标数组。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 未重置上下文再次调用 finish 进行摘要计算或者指定输出数组大小不等于摘要算法信息长度，抛此异常。</li>
</ul>
<h3 id="func-reset"><a class="header" href="#func-reset">func reset()</a></h3>
<pre><code class="language-cangjie">public func reset(): Unit
</code></pre>
<p>功能：重置 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-hmac">HMAC</a> 对象到初始状态，清理 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-hmac">HMAC</a> 上下文。</p>
<p>异常：</p>
<ul>
<li><a href="crypto/digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 当内部错误，重置失败，抛此异常。</li>
</ul>
<h3 id="func-writearraybyte-2"><a class="header" href="#func-writearraybyte-2">func write(Array&lt;Byte&gt;)</a></h3>
<pre><code class="language-cangjie">public func write(buffer: Array&lt;Byte&gt;): Unit 
</code></pre>
<p>功能：使用给定的 buffer 更新 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-hmac">HMAC</a> 对象，在调用 finish 前可以多次更新。</p>
<p>参数：</p>
<ul>
<li>buffer: Array&lt;Byte&gt; - 需要追加的字节序列。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 当 buffer 为空、finish 已经调用生成信息摘要场景，抛此异常。</li>
</ul>
<h2 id="class-md5"><a class="header" href="#class-md5">class MD5</a></h2>
<pre><code class="language-cangjie">public class MD5 &lt;: Digest {
    public init()
}
</code></pre>
<p>功能：提供 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-md5">MD5</a> 算法的实现接口。使用示例见 <a href="crypto/digest/digest_package_api/../digest_samples/sample_digest.html#MD5-%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B">MD5 算法示例</a>。</p>
<p>父类型：</p>
<ul>
<li>Digest</li>
</ul>
<h3 id="prop-algorithm-2"><a class="header" href="#prop-algorithm-2">prop algorithm</a></h3>
<pre><code class="language-cangjie">public prop algorithm: String
</code></pre>
<p>功能：<a href="crypto/digest/digest_package_api/digest_package_classes.html#class-md5">MD5</a> 摘要算法的算法名称。</p>
<p>类型：String</p>
<h3 id="prop-blocksize-2"><a class="header" href="#prop-blocksize-2">prop blockSize</a></h3>
<pre><code class="language-cangjie">public prop blockSize: Int64
</code></pre>
<p>功能：<a href="crypto/digest/digest_package_api/digest_package_classes.html#class-md5">MD5</a> 信息块长度，单位字节。</p>
<p>类型：Int64</p>
<h3 id="prop-size-1"><a class="header" href="#prop-size-1">prop size</a></h3>
<pre><code class="language-cangjie">public prop size: Int64
</code></pre>
<p>功能：<a href="crypto/digest/digest_package_api/digest_package_classes.html#class-md5">MD5</a> 摘要信息长度，单位字节。</p>
<p>类型：Int64</p>
<h3 id="init-1"><a class="header" href="#init-1">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：无参构造函数，创建 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-md5">MD5</a> 对象。</p>
<h3 id="func-finish-1"><a class="header" href="#func-finish-1">func finish()</a></h3>
<pre><code class="language-cangjie">public func finish(): Array&lt;Byte&gt;
</code></pre>
<p>功能：返回生成的 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-md5">MD5</a> 值，注意调用 finish 后 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-md5">MD5</a> 上下文会发生改变，finish 后不可以再进行摘要计算，如重新计算需要 reset 重置上下文。</p>
<p>返回值：</p>
<ul>
<li>Array&lt;Byte&gt; - 生成的 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-md5">MD5</a> 字节序列。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 未重置上下文再次调用 finish 进行摘要计算，抛此异常。</li>
</ul>
<h3 id="func-finisharraybyte-1"><a class="header" href="#func-finisharraybyte-1">func finish(Array&lt;Byte&gt;)</a></h3>
<pre><code class="language-cangjie">public func finish(to!: Array&lt;Byte&gt;): Unit
</code></pre>
<p>功能：获取生成的信息摘要值，注意调用 finish 后不可以再进行摘要计算，如重新计算需要 reset 重置上下文。</p>
<p>参数：</p>
<ul>
<li>to!: Array&lt;Byte&gt; - 目标数组。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 未重置上下文再次调用 finish 进行摘要计算或者指定输出数组大小不等于摘要算法信息长度，抛此异常。</li>
</ul>
<h3 id="func-reset-1"><a class="header" href="#func-reset-1">func reset()</a></h3>
<pre><code class="language-cangjie">public func reset(): Unit
</code></pre>
<p>功能：重置 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-md5">MD5</a> 对象到初始状态，清理 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-md5">MD5</a> 上下文。</p>
<h3 id="func-writearraybyte-3"><a class="header" href="#func-writearraybyte-3">func write(Array&lt;Byte&gt;)</a></h3>
<pre><code class="language-cangjie">public func write(buffer: Array&lt;Byte&gt;): Unit
</code></pre>
<p>功能：使用给定的 buffer 更新 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-md5">MD5</a> 对象，在调用 finish 前可以多次更新。</p>
<p>参数：</p>
<ul>
<li>buffer: Array&lt;Byte&gt; - 输入字节序列。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 已经调用 finish 进行摘要计算后未重置上下文，抛此异常。</li>
</ul>
<h2 id="class-sha1"><a class="header" href="#class-sha1">class SHA1</a></h2>
<pre><code class="language-cangjie">public class SHA1 &lt;: Digest {
    public init()
}
</code></pre>
<p>功能：提供 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha1">SHA1</a> 算法的实现接口。使用示例见 <a href="crypto/digest/digest_package_api/../digest_samples/sample_digest.html#SHA1-%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B">SHA1 算法示例</a>。</p>
<p>父类型：</p>
<ul>
<li>Digest</li>
</ul>
<h3 id="prop-algorithm-3"><a class="header" href="#prop-algorithm-3">prop algorithm</a></h3>
<pre><code class="language-cangjie">public prop algorithm: String
</code></pre>
<p>功能：<a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha1">SHA1</a> 摘要算法的算法名称。</p>
<p>类型：String</p>
<h3 id="prop-blocksize-3"><a class="header" href="#prop-blocksize-3">prop blockSize</a></h3>
<pre><code class="language-cangjie">public prop blockSize: Int64
</code></pre>
<p>功能：<a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha1">SHA1</a> 信息块长度，单位字节。</p>
<p>类型：Int64</p>
<h3 id="prop-size-2"><a class="header" href="#prop-size-2">prop size</a></h3>
<pre><code class="language-cangjie">public prop size: Int64
</code></pre>
<p>功能：<a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha1">SHA1</a> 摘要信息长度，单位字节。</p>
<p>类型：Int64</p>
<h3 id="init-2"><a class="header" href="#init-2">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：无参构造函数，创建 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha1">SHA1</a> 对象。</p>
<h3 id="func-finish-2"><a class="header" href="#func-finish-2">func finish()</a></h3>
<pre><code class="language-cangjie">public func finish(): Array&lt;Byte&gt;
</code></pre>
<p>功能：返回生成的 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha1">SHA1</a> 值，注意调用 finish 后 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha1">SHA1</a> 上下文会发生改变，finish 后不可以再进行摘要计算，如重新计算需要 reset 重置上下文。</p>
<p>返回值：</p>
<ul>
<li>Array&lt;Byte&gt; - 生成的 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha1">SHA1</a> 字节序列。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 未重置上下文再次调用 finish 进行摘要计算，抛此异常。</li>
</ul>
<h3 id="func-finisharraybyte-2"><a class="header" href="#func-finisharraybyte-2">func finish(Array&lt;Byte&gt;)</a></h3>
<pre><code class="language-cangjie">public func finish(to!: Array&lt;Byte&gt;): Unit
</code></pre>
<p>功能：获取生成的信息摘要值，注意调用 finish 后不可以再进行摘要计算，如重新计算需要 reset 重置上下文。</p>
<p>参数：</p>
<ul>
<li>to!: Array&lt;Byte&gt; - 目标数组。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 未重置上下文再次调用 finish 进行摘要计算或者指定输出数组大小不等于摘要算法信息长度，抛此异常。</li>
</ul>
<h3 id="func-reset-2"><a class="header" href="#func-reset-2">func reset()</a></h3>
<pre><code class="language-cangjie">public func reset(): Unit
</code></pre>
<p>功能：重置 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha1">SHA1</a> 对象到初始状态，清理 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha1">SHA1</a> 上下文。</p>
<h3 id="func-writearraybyte-4"><a class="header" href="#func-writearraybyte-4">func write(Array&lt;Byte&gt;)</a></h3>
<pre><code class="language-cangjie">public func write(buffer: Array&lt;Byte&gt;): Unit
</code></pre>
<p>功能：使用给定的 buffer 更新 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha1">SHA1</a> 对象，在调用 finish 前可以多次更新。</p>
<p>参数：</p>
<ul>
<li>buffer: Array&lt;Byte&gt; - 输入字节序列。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 已经调用 finish 进行摘要计算后未重置上下文，抛此异常。</li>
</ul>
<h2 id="class-sha224"><a class="header" href="#class-sha224">class SHA224</a></h2>
<pre><code class="language-cangjie">public class SHA224 &lt;: Digest {
    public init()
}
</code></pre>
<p>功能：提供 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha224">SHA224</a> 算法的实现接口。使用示例见 <a href="crypto/digest/digest_package_api/../digest_samples/sample_digest.html#SHA224-%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B">SHA224 算法示例</a>。</p>
<p>父类型：</p>
<ul>
<li>Digest</li>
</ul>
<h3 id="prop-algorithm-4"><a class="header" href="#prop-algorithm-4">prop algorithm</a></h3>
<pre><code class="language-cangjie">public prop algorithm: String
</code></pre>
<p>功能：<a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha224">SHA224</a> 摘要算法的算法名称。</p>
<p>类型：String</p>
<h3 id="prop-blocksize-4"><a class="header" href="#prop-blocksize-4">prop blockSize</a></h3>
<pre><code class="language-cangjie">public prop blockSize: Int64
</code></pre>
<p>功能：<a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha224">SHA224</a> 信息块长度，单位字节。</p>
<p>类型：Int64</p>
<h3 id="prop-size-3"><a class="header" href="#prop-size-3">prop size</a></h3>
<pre><code class="language-cangjie">public prop size: Int64
</code></pre>
<p>功能：<a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha224">SHA224</a> 摘要信息长度，单位字节。</p>
<p>类型：Int64</p>
<h3 id="init-3"><a class="header" href="#init-3">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：无参构造函数，创建 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha224">SHA224</a> 对象。</p>
<h3 id="func-finish-3"><a class="header" href="#func-finish-3">func finish()</a></h3>
<pre><code class="language-cangjie">public func finish(): Array&lt;Byte&gt;
</code></pre>
<p>功能：返回生成的 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha224">SHA224</a> 值，注意调用 finish 后 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha224">SHA224</a> 上下文会发生改变，finish 后不可以再进行摘要计算，如重新计算需要 reset 重置上下文。</p>
<p>返回值：</p>
<ul>
<li>Array&lt;Byte&gt; - 生成的 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha224">SHA224</a> 字节序列。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 未重置上下文再次调用 finish 进行摘要计算，抛此异常。</li>
</ul>
<h3 id="func-finisharraybyte-3"><a class="header" href="#func-finisharraybyte-3">func finish(Array&lt;Byte&gt;)</a></h3>
<pre><code class="language-cangjie">public func finish(to!: Array&lt;Byte&gt;): Unit
</code></pre>
<p>功能：获取生成的信息摘要值，注意调用 finish 后不可以再进行摘要计算，如重新计算需要 reset 重置上下文。</p>
<p>参数：</p>
<ul>
<li>to!: Array&lt;Byte&gt; - 目标数组。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 未重置上下文再次调用 finish 进行摘要计算或者指定输出数组大小不等于摘要算法信息长度，抛此异常。</li>
</ul>
<h3 id="func-reset-3"><a class="header" href="#func-reset-3">func reset()</a></h3>
<pre><code class="language-cangjie">public func reset(): Unit
</code></pre>
<p>功能：重置 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha224">SHA224</a> 对象到初始状态，清理 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha224">SHA224</a> 上下文。</p>
<h3 id="func-writearraybyte-5"><a class="header" href="#func-writearraybyte-5">func write(Array&lt;Byte&gt;)</a></h3>
<pre><code class="language-cangjie">public func write(buffer: Array&lt;Byte&gt;): Unit
</code></pre>
<p>功能：使用给定的 buffer 更新 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha224">SHA224</a> 对象，在调用 finish 前可以多次更新。</p>
<p>参数：</p>
<ul>
<li>buffer: Array&lt;Byte&gt; - 输入字节序列。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 已经调用 finish 进行摘要计算后未重置上下文，抛此异常。</li>
</ul>
<h2 id="class-sha256"><a class="header" href="#class-sha256">class SHA256</a></h2>
<pre><code class="language-cangjie">public class SHA256 &lt;: Digest {
    public init()
}
</code></pre>
<p>功能：提供 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha256">SHA256</a> 算法的实现接口。使用示例见 <a href="crypto/digest/digest_package_api/../digest_samples/sample_digest.html#SHA256-%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B">SHA256 算法示例</a>。</p>
<p>父类型：</p>
<ul>
<li>Digest</li>
</ul>
<h3 id="prop-algorithm-5"><a class="header" href="#prop-algorithm-5">prop algorithm</a></h3>
<pre><code class="language-cangjie">public prop algorithm: String
</code></pre>
<p>功能：<a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha256">SHA256</a> 摘要算法的算法名称。</p>
<p>类型：String</p>
<h3 id="prop-blocksize-5"><a class="header" href="#prop-blocksize-5">prop blockSize</a></h3>
<pre><code class="language-cangjie">public prop blockSize: Int64
</code></pre>
<p>功能：<a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha256">SHA256</a> 信息块长度，单位字节。</p>
<p>类型：Int64</p>
<h3 id="prop-size-4"><a class="header" href="#prop-size-4">prop size</a></h3>
<pre><code class="language-cangjie">public prop size: Int64
</code></pre>
<p>功能：<a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha256">SHA256</a> 摘要信息长度，单位字节。</p>
<p>类型：Int64</p>
<h3 id="init-4"><a class="header" href="#init-4">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：无参构造函数，创建 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha256">SHA256</a> 对象。</p>
<h3 id="func-finish-4"><a class="header" href="#func-finish-4">func finish()</a></h3>
<pre><code class="language-cangjie">public func finish(): Array&lt;Byte&gt;
</code></pre>
<p>功能：返回生成的 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha256">SHA256</a> 值，注意调用 finish 后 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha256">SHA256</a> 上下文会发生改变，finish 后不可以再进行摘要计算，如重新计算需要 reset 重置上下文。</p>
<p>返回值：</p>
<ul>
<li>Array&lt;Byte&gt; - 生成的 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha256">SHA256</a> 字节序列。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 未重置上下文再次调用 finish 进行摘要计算，抛此异常。</li>
</ul>
<h3 id="func-finisharraybyte-4"><a class="header" href="#func-finisharraybyte-4">func finish(Array&lt;Byte&gt;)</a></h3>
<pre><code class="language-cangjie">public func finish(to!: Array&lt;Byte&gt;): Unit
</code></pre>
<p>功能：获取生成的信息摘要值，注意调用 finish 后不可以再进行摘要计算，如重新计算需要 reset 重置上下文。</p>
<p>参数：</p>
<ul>
<li>to!: Array&lt;Byte&gt; - 目标数组。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 未重置上下文再次调用 finish 进行摘要计算或者指定输出数组大小不等于摘要算法信息长度，抛此异常。</li>
</ul>
<h3 id="func-reset-4"><a class="header" href="#func-reset-4">func reset()</a></h3>
<pre><code class="language-cangjie">public func reset(): Unit
</code></pre>
<p>功能：重置 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha256">SHA256</a> 对象到初始状态，清理 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha256">SHA256</a> 上下文。</p>
<h3 id="func-writearraybyte-6"><a class="header" href="#func-writearraybyte-6">func write(Array&lt;Byte&gt;)</a></h3>
<pre><code class="language-cangjie">public func write(buffer: Array&lt;Byte&gt;): Unit
</code></pre>
<p>功能：使用给定的 buffer 更新 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha256">SHA256</a> 对象，在调用 finish 前可以多次更新。</p>
<p>参数：</p>
<ul>
<li>buffer: Array&lt;Byte&gt; - 输入字节序列。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 已经调用 finish 进行摘要计算后未重置上下文，抛此异常。</li>
</ul>
<h2 id="class-sha384"><a class="header" href="#class-sha384">class SHA384</a></h2>
<pre><code class="language-cangjie">public class SHA384 &lt;: Digest {
    public init()
}
</code></pre>
<p>功能：提供 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha384">SHA384</a> 算法的实现接口。使用示例见 <a href="crypto/digest/digest_package_api/../digest_samples/sample_digest.html#SHA384-%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B">SHA384 算法示例</a>。</p>
<p>父类型：</p>
<ul>
<li>Digest</li>
</ul>
<h3 id="prop-algorithm-6"><a class="header" href="#prop-algorithm-6">prop algorithm</a></h3>
<pre><code class="language-cangjie">public prop algorithm: String
</code></pre>
<p>功能：<a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha384">SHA384</a> 摘要算法的算法名称。</p>
<p>类型：String</p>
<h3 id="prop-blocksize-6"><a class="header" href="#prop-blocksize-6">prop blockSize</a></h3>
<pre><code class="language-cangjie">public prop blockSize: Int64
</code></pre>
<p>功能：<a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha384">SHA384</a> 信息块长度，单位字节。</p>
<p>类型：Int64</p>
<h3 id="prop-size-5"><a class="header" href="#prop-size-5">prop size</a></h3>
<pre><code class="language-cangjie">public prop size: Int64
</code></pre>
<p>功能：<a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha384">SHA384</a> 摘要信息长度，单位字节。</p>
<p>类型：Int64</p>
<h3 id="init-5"><a class="header" href="#init-5">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：无参构造函数，创建 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha384">SHA384</a> 对象。</p>
<h3 id="func-finish-5"><a class="header" href="#func-finish-5">func finish()</a></h3>
<pre><code class="language-cangjie">public func finish(): Array&lt;Byte&gt;
</code></pre>
<p>功能：返回生成的 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha384">SHA384</a> 值，注意调用 finish 后 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha384">SHA384</a> 上下文会发生改变，finish 后不可以再进行摘要计算，如重新计算需要 reset 重置上下文。</p>
<p>返回值：</p>
<ul>
<li>Array&lt;Byte&gt; - 生成的 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha384">SHA384</a> 字节序列。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 未重置上下文再次调用 finish 进行摘要计算，抛此异常。</li>
</ul>
<h3 id="func-finisharraybyte-5"><a class="header" href="#func-finisharraybyte-5">func finish(Array&lt;Byte&gt;)</a></h3>
<pre><code class="language-cangjie">public func finish(to!: Array&lt;Byte&gt;): Unit
</code></pre>
<p>功能：获取生成的信息摘要值，注意调用 finish 后不可以再进行摘要计算，如重新计算需要 reset 重置上下文。</p>
<p>参数：</p>
<ul>
<li>to!: Array&lt;Byte&gt; - 目标数组。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 未重置上下文再次调用 finish 进行摘要计算或者指定输出数组大小不等于摘要算法信息长度，抛此异常。</li>
</ul>
<h3 id="func-reset-5"><a class="header" href="#func-reset-5">func reset()</a></h3>
<pre><code class="language-cangjie">public func reset(): Unit
</code></pre>
<p>功能：重置 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha384">SHA384</a> 对象到初始状态，清理 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha384">SHA384</a> 上下文。</p>
<h3 id="func-writearraybyte-7"><a class="header" href="#func-writearraybyte-7">func write(Array&lt;Byte&gt;)</a></h3>
<pre><code class="language-cangjie">public func write(buffer: Array&lt;Byte&gt;): Unit
</code></pre>
<p>功能：使用给定的 buffer 更新 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha384">SHA384</a> 对象，在调用 finish 前可以多次更新。</p>
<p>参数：</p>
<ul>
<li>buffer: Array&lt;Byte&gt; - 输入字节序列。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 已经调用 finish 进行摘要计算后未重置上下文，抛此异常。</li>
</ul>
<h2 id="class-sha512"><a class="header" href="#class-sha512">class SHA512</a></h2>
<pre><code class="language-cangjie">public class SHA512 &lt;: Digest {
    public init()
}
</code></pre>
<p>功能：提供 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha512">SHA512</a> 算法的实现接口。使用示例见 <a href="crypto/digest/digest_package_api/../digest_samples/sample_digest.html#SHA512-%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B">SHA512 算法示例</a>。</p>
<p>父类型：</p>
<ul>
<li>Digest</li>
</ul>
<h3 id="prop-algorithm-7"><a class="header" href="#prop-algorithm-7">prop algorithm</a></h3>
<pre><code class="language-cangjie">public prop algorithm: String
</code></pre>
<p>功能：<a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha512">SHA512</a> 摘要算法的算法名称。</p>
<p>类型：String</p>
<h3 id="prop-blocksize-7"><a class="header" href="#prop-blocksize-7">prop blockSize</a></h3>
<pre><code class="language-cangjie">public prop blockSize: Int64
</code></pre>
<p>功能：<a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha512">SHA512</a> 信息块长度，单位字节。</p>
<p>类型：Int64</p>
<h3 id="prop-size-6"><a class="header" href="#prop-size-6">prop size</a></h3>
<pre><code class="language-cangjie">public prop size: Int64
</code></pre>
<p>功能：<a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha512">SHA512</a> 摘要信息长度，单位字节。</p>
<p>类型：Int64</p>
<h3 id="init-6"><a class="header" href="#init-6">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：无参构造函数，创建 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha512">SHA512</a> 对象。</p>
<h3 id="func-finish-6"><a class="header" href="#func-finish-6">func finish()</a></h3>
<pre><code class="language-cangjie">public func finish(): Array&lt;Byte&gt;
</code></pre>
<p>功能：返回生成的 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha512">SHA512</a> 值，注意调用 finish 后 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha512">SHA512</a> 上下文会发生改变，finish 后不可以再进行摘要计算，如重新计算需要 reset 重置上下文。</p>
<p>返回值：</p>
<ul>
<li>Array&lt;Byte&gt; - 生成的 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha512">SHA512</a> 字节序列。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 未重置上下文再次调用 finish 进行摘要计算，抛此异常。</li>
</ul>
<h3 id="func-finisharraybyte-6"><a class="header" href="#func-finisharraybyte-6">func finish(Array&lt;Byte&gt;)</a></h3>
<pre><code class="language-cangjie">public func finish(to!: Array&lt;Byte&gt;): Unit
</code></pre>
<p>功能：获取生成的信息摘要值，注意调用 finish 后不可以再进行摘要计算，如重新计算需要 reset 重置上下文。</p>
<p>参数：</p>
<ul>
<li>to!: Array&lt;Byte&gt; - 目标数组。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 未重置上下文再次调用 finish 进行摘要计算或者指定输出数组大小不等于摘要算法信息长度，抛此异常。</li>
</ul>
<h3 id="func-reset-6"><a class="header" href="#func-reset-6">func reset()</a></h3>
<pre><code class="language-cangjie">public func reset(): Unit
</code></pre>
<p>功能：重置 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha512">SHA512</a> 对象到初始状态，清理 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha512">SHA512</a> 上下文。</p>
<h3 id="func-writearraybyte-8"><a class="header" href="#func-writearraybyte-8">func write(Array&lt;Byte&gt;)</a></h3>
<pre><code class="language-cangjie">public func write(buffer: Array&lt;Byte&gt;): Unit
</code></pre>
<p>功能：使用给定的 buffer 更新 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha512">SHA512</a> 对象，在调用 finish 前可以多次更新。</p>
<p>参数：</p>
<ul>
<li>buffer: Array&lt;Byte&gt; - 输入字节序列。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 已经调用 finish 进行摘要计算后未重置上下文，抛此异常。</li>
</ul>
<h2 id="class-sm3"><a class="header" href="#class-sm3">class SM3</a></h2>
<pre><code class="language-cangjie">public class SM3 &lt;: Digest {
    public init()
}
</code></pre>
<p>功能：提供 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sm3">SM3</a> 算法的实现接口。使用示例见 <a href="crypto/digest/digest_package_api/../digest_samples/sample_digest.html#SM3-%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B">SM3 算法示例</a>。</p>
<p>父类型：</p>
<ul>
<li>Digest</li>
</ul>
<h3 id="prop-algorithm-8"><a class="header" href="#prop-algorithm-8">prop algorithm</a></h3>
<pre><code class="language-cangjie">public prop algorithm: String
</code></pre>
<p>功能：<a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sm3">SM3</a> 摘要算法的算法名称。</p>
<p>类型：String</p>
<h3 id="prop-blocksize-8"><a class="header" href="#prop-blocksize-8">prop blockSize</a></h3>
<pre><code class="language-cangjie">public prop blockSize: Int64
</code></pre>
<p>功能：<a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sm3">SM3</a> 信息块长度，单位字节。</p>
<p>类型：Int64</p>
<h3 id="prop-size-7"><a class="header" href="#prop-size-7">prop size</a></h3>
<pre><code class="language-cangjie">public prop size: Int64
</code></pre>
<p>功能：<a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sm3">SM3</a> 摘要信息长度，单位字节。</p>
<p>类型：Int64</p>
<h3 id="init-7"><a class="header" href="#init-7">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：无参构造函数，创建 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sm3">SM3</a> 对象。</p>
<h3 id="func-finish-7"><a class="header" href="#func-finish-7">func finish()</a></h3>
<pre><code class="language-cangjie">public func finish(): Array&lt;Byte&gt;
</code></pre>
<p>功能：返回生成的 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sm3">SM3</a> 值，注意调用 finish 后 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sm3">SM3</a> 上下文会发生改变，finish 后不可以再进行摘要计算，如重新计算需要 reset 重置上下文。</p>
<p>返回值：</p>
<ul>
<li>Array&lt;Byte&gt; - 生成的 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sm3">SM3</a> 字节序列。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 未重置上下文再次调用 finish 进行摘要计算，抛此异常。</li>
</ul>
<h3 id="func-finisharraybyte-7"><a class="header" href="#func-finisharraybyte-7">func finish(Array&lt;Byte&gt;)</a></h3>
<pre><code class="language-cangjie">public func finish(to!: Array&lt;Byte&gt;): Unit
</code></pre>
<p>功能：获取生成的信息摘要值，注意调用 finish 后不可以再进行摘要计算，如重新计算需要 reset 重置上下文。</p>
<p>参数：</p>
<ul>
<li>to!: Array&lt;Byte&gt; - 目标数组。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 未重置上下文再次调用 finish 进行摘要计算或者指定输出数组大小不等于摘要算法信息长度，抛此异常。</li>
</ul>
<h3 id="func-reset-7"><a class="header" href="#func-reset-7">func reset()</a></h3>
<pre><code class="language-cangjie">public func reset(): Unit
</code></pre>
<p>功能：重置 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sm3">SM3</a> 对象到初始状态，清理 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sm3">SM3</a> 上下文。</p>
<h3 id="func-writearraybyte-9"><a class="header" href="#func-writearraybyte-9">func write(Array&lt;Byte&gt;)</a></h3>
<pre><code class="language-cangjie">public func write(buffer: Array&lt;Byte&gt;): Unit
</code></pre>
<p>功能：使用给定的 buffer 更新 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sm3">SM3</a> 对象，在调用 finish 前可以多次更新。</p>
<p>参数：</p>
<ul>
<li>buffer: Array&lt;Byte&gt; - 输入字节序列。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 已经调用 finish 进行摘要计算后未重置上下文，抛此异常。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="结构体-3"><a class="header" href="#结构体-3">结构体</a></h1>
<h2 id="struct-hashtype"><a class="header" href="#struct-hashtype">struct HashType</a></h2>
<pre><code class="language-cangjie">public struct HashType &lt;: ToString &amp; Equatable&lt;HashType&gt;
</code></pre>
<p>功能: 此类为 Hash 算法类别结构体，<a href="crypto/digest/digest_package_api/digest_package_classes.html#class-md5">MD5</a>、<a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha1">SHA1</a>、<a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha224">SHA224</a>、<a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha256">SHA256</a>、<a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha384">SHA384</a>、<a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha512">SHA512</a>均为常用摘要算法。</p>
<p>父类型：</p>
<ul>
<li>ToString</li>
<li>Equatable&lt;<a href="crypto/digest/digest_package_api/digest_package_structs.html#struct-hashtype">HashType</a>&gt;</li>
</ul>
<h3 id="prop-md5"><a class="header" href="#prop-md5">prop MD5</a></h3>
<pre><code class="language-cangjie">public static prop MD5: HashType
</code></pre>
<p>功能：返回 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-md5">MD5</a> 类型。</p>
<p>类型：<a href="crypto/digest/digest_package_api/digest_package_structs.html#struct-hashtype">HashType</a></p>
<h3 id="prop-sha1"><a class="header" href="#prop-sha1">prop SHA1</a></h3>
<pre><code class="language-cangjie">public static prop SHA1: HashType
</code></pre>
<p>功能：返回 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha1">SHA1</a> 类型。</p>
<p>类型：<a href="crypto/digest/digest_package_api/digest_package_structs.html#struct-hashtype">HashType</a></p>
<h3 id="prop-sha224"><a class="header" href="#prop-sha224">prop SHA224</a></h3>
<pre><code class="language-cangjie">public static prop SHA224: HashType
</code></pre>
<p>功能：返回 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha224">SHA224</a> 类型。</p>
<p>类型：<a href="crypto/digest/digest_package_api/digest_package_structs.html#struct-hashtype">HashType</a></p>
<h3 id="prop-sha256"><a class="header" href="#prop-sha256">prop SHA256</a></h3>
<pre><code class="language-cangjie">public static prop SHA256: HashType
</code></pre>
<p>功能：返回 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha256">SHA256</a> 类型。</p>
<p>类型：<a href="crypto/digest/digest_package_api/digest_package_structs.html#struct-hashtype">HashType</a></p>
<h3 id="prop-sha384"><a class="header" href="#prop-sha384">prop SHA384</a></h3>
<pre><code class="language-cangjie">public static prop SHA384: HashType
</code></pre>
<p>功能：返回 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha384">SHA384</a> 类型。</p>
<p>类型：<a href="crypto/digest/digest_package_api/digest_package_structs.html#struct-hashtype">HashType</a></p>
<h3 id="prop-sha512"><a class="header" href="#prop-sha512">prop SHA512</a></h3>
<pre><code class="language-cangjie">public static prop SHA512: HashType
</code></pre>
<p>功能：返回 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sha512">SHA512</a> 类型。</p>
<p>类型：<a href="crypto/digest/digest_package_api/digest_package_structs.html#struct-hashtype">HashType</a></p>
<h3 id="prop-sm3"><a class="header" href="#prop-sm3">prop SM3</a></h3>
<pre><code class="language-cangjie">public static prop SM3: HashType
</code></pre>
<p>功能：返回 <a href="crypto/digest/digest_package_api/digest_package_classes.html#class-sm3">SM3</a> 类型。</p>
<p>类型：<a href="crypto/digest/digest_package_api/digest_package_structs.html#struct-hashtype">HashType</a></p>
<h3 id="func-tostring-1"><a class="header" href="#func-tostring-1">func toString()</a></h3>
<pre><code class="language-cangjie">public func toString(): String
</code></pre>
<p>功能：获取 Hash 算法名称。</p>
<p>返回值：</p>
<ul>
<li>String - Hash 算法名称。</li>
</ul>
<h3 id="operator-func-hashtype"><a class="header" href="#operator-func-hashtype">operator func ==(HashType)</a></h3>
<pre><code class="language-cangjie">public operator override func ==(other: HashType): Bool
</code></pre>
<p>功能：判断两 <a href="crypto/digest/digest_package_api/digest_package_structs.html#struct-hashtype">HashType</a> 是否引用同一实例。</p>
<p>参数：</p>
<ul>
<li>other: <a href="crypto/digest/digest_package_api/digest_package_structs.html#struct-hashtype">HashType</a> - 对比的 HashType。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - 相同返回 <code>true</code>；否则，返回 <code>false</code>。</li>
</ul>
<h3 id="operator-func-hashtype-1"><a class="header" href="#operator-func-hashtype-1">operator func !=(HashType)</a></h3>
<pre><code class="language-cangjie">public operator override func !=(other: HashType): Bool
</code></pre>
<p>功能：判断两 <a href="crypto/digest/digest_package_api/digest_package_structs.html#struct-hashtype">HashType</a> 是否引用不同实例。</p>
<p>参数：</p>
<ul>
<li>other: <a href="crypto/digest/digest_package_api/digest_package_structs.html#struct-hashtype">HashType</a> - 对比的 HashType。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - 不相同返回 <code>true</code>；否则，返回 <code>false</code>。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="异常类-5"><a class="header" href="#异常类-5">异常类</a></h1>
<h2 id="class-cryptoexception"><a class="header" href="#class-cryptoexception">class CryptoException</a></h2>
<pre><code class="language-cangjie">public class CryptoException &lt;: Exception {
    public init()
    public init(message: String)
}
</code></pre>
<p>功能：此类为摘要和加解密出现错误时抛出的异常。</p>
<p>父类型：</p>
<ul>
<li>Exception</li>
</ul>
<h3 id="init-8"><a class="header" href="#init-8">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：无参构造函数，构造<a href="crypto/digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a>异常。</p>
<h3 id="initstring-2"><a class="header" href="#initstring-2">init(String)</a></h3>
<pre><code class="language-cangjie">public init(message: String)
</code></pre>
<p>功能：根据异常信息构造 <a href="crypto/digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> 异常类对象。</p>
<p>参数：</p>
<ul>
<li>message: String - 异常信息。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="digest-使用"><a class="header" href="#digest-使用">digest 使用</a></h1>
<h2 id="md5-算法示例"><a class="header" href="#md5-算法示例">MD5 算法示例</a></h2>
<h3 id="调用-md5-成员函数"><a class="header" href="#调用-md5-成员函数">调用 MD5 成员函数</a></h3>
<p>示例：</p>
<!-- verify -->
<pre><code class="language-cangjie">import stdx.crypto.digest.*
import std.convert.*
import std.crypto.digest.*
import stdx.encoding.hex.*

main() {
    var str: String = &quot;helloworld&quot;
    var md5Instance = MD5()
    md5Instance.write(str.toArray())
    var md: Array&lt;Byte&gt; = md5Instance.finish()
    var result: String = toHexString(md)
    println(result)
    return 0
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-text">fc5e038d38a57032085441e7fe7010b0
</code></pre>
<h2 id="sha1-算法示例"><a class="header" href="#sha1-算法示例">SHA1 算法示例</a></h2>
<h3 id="调用-sha1-成员函数"><a class="header" href="#调用-sha1-成员函数">调用 SHA1 成员函数</a></h3>
<p>示例：</p>
<!-- verify -->
<pre><code class="language-cangjie">import stdx.crypto.digest.*
import std.convert.*
import std.crypto.digest.*
import stdx.encoding.hex.*

main() {
    var str: String = &quot;helloworld&quot;
    var sha1Instance = SHA1()
    sha1Instance.write(str.toArray())
    var md: Array&lt;Byte&gt; = sha1Instance.finish()
    var result: String = toHexString(md)
    println(result)
    return 0
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-text">6adfb183a4a2c94a2f92dab5ade762a47889a5a1
</code></pre>
<h2 id="sha224-算法示例"><a class="header" href="#sha224-算法示例">SHA224 算法示例</a></h2>
<h3 id="调用-sha224-成员函数"><a class="header" href="#调用-sha224-成员函数">调用 SHA224 成员函数</a></h3>
<p>示例：</p>
<!-- verify -->
<pre><code class="language-cangjie">import stdx.crypto.digest.*
import std.convert.*
import std.crypto.digest.*
import stdx.encoding.hex.*

main() {
    var str: String = &quot;helloworld&quot;
    var sha224Instance = SHA224()
    sha224Instance.write(str.toArray())
    var md: Array&lt;Byte&gt; = sha224Instance.finish()
    var result: String = toHexString(md)
    println(result)
    return 0
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-text">b033d770602994efa135c5248af300d81567ad5b59cec4bccbf15bcc
</code></pre>
<h2 id="sha256-算法示例"><a class="header" href="#sha256-算法示例">SHA256 算法示例</a></h2>
<h3 id="调用-sha256-成员函数"><a class="header" href="#调用-sha256-成员函数">调用 SHA256 成员函数</a></h3>
<p>示例：</p>
<!-- verify -->
<pre><code class="language-cangjie">import stdx.crypto.digest.*
import std.convert.*
import std.crypto.digest.*
import stdx.encoding.hex.*

main() {
    var str: String = &quot;helloworld&quot;
    var sha256Instance = SHA256()
    sha256Instance.write(str.toArray())
    var md: Array&lt;Byte&gt; = sha256Instance.finish()
    var result: String = toHexString(md)
    println(result)
    return 0
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-text">936a185caaa266bb9cbe981e9e05cb78cd732b0b3280eb944412bb6f8f8f07af
</code></pre>
<h2 id="sha384-算法示例"><a class="header" href="#sha384-算法示例">SHA384 算法示例</a></h2>
<h3 id="调用-sha384-成员函数"><a class="header" href="#调用-sha384-成员函数">调用 SHA384 成员函数</a></h3>
<p>示例：</p>
<!-- verify -->
<pre><code class="language-cangjie">import stdx.crypto.digest.*
import std.convert.*
import std.crypto.digest.*
import stdx.encoding.hex.*

main() {
    var str: String = &quot;helloworld&quot;
    var sha384Instance = SHA384()
    sha384Instance.write(str.toArray())
    var md: Array&lt;Byte&gt; = sha384Instance.finish()
    var result: String = toHexString(md)
    println(result)
    return 0
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-text">97982a5b1414b9078103a1c008c4e3526c27b41cdbcf80790560a40f2a9bf2ed4427ab1428789915ed4b3dc07c454bd9
</code></pre>
<h2 id="sha512-算法示例"><a class="header" href="#sha512-算法示例">SHA512 算法示例</a></h2>
<h3 id="调用-sha512-成员函数"><a class="header" href="#调用-sha512-成员函数">调用 SHA512 成员函数</a></h3>
<p>示例：</p>
<!-- verify -->
<pre><code class="language-cangjie">import stdx.crypto.digest.*
import std.convert.*
import std.crypto.digest.*
import stdx.encoding.hex.*

main() {
    var str: String = &quot;helloworld&quot;
    var sha512Instance = SHA512()
    sha512Instance.write(str.toArray())
    var md: Array&lt;Byte&gt; = sha512Instance.finish()
    var result: String = toHexString(md)
    println(result)
    return 0
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-text">1594244d52f2d8c12b142bb61f47bc2eaf503d6d9ca8480cae9fcf112f66e4967dc5e8fa98285e36db8af1b8ffa8b84cb15e0fbcf836c3deb803c13f37659a60
</code></pre>
<h2 id="hmac-算法示例"><a class="header" href="#hmac-算法示例">HMAC 算法示例</a></h2>
<blockquote>
<p><strong>说明</strong></p>
<p>目前只支持HMAC-SHA512。</p>
</blockquote>
<h3 id="调用-hmac-sha512-成员函数"><a class="header" href="#调用-hmac-sha512-成员函数">调用 HMAC-SHA512 成员函数</a></h3>
<p>示例：</p>
<!-- verify -->
<pre><code class="language-cangjie">import stdx.crypto.digest.*
import stdx.encoding.hex.*

main() {
    var algorithm: HashType = HashType.SHA512
    var key: Array&lt;UInt8&gt; = &quot;cangjie&quot;.toArray()
    var data1: Array&lt;UInt8&gt; = &quot;123&quot;.toArray()
    var data2: Array&lt;UInt8&gt; = &quot;456&quot;.toArray()
    var data3: Array&lt;UInt8&gt; = &quot;789&quot;.toArray()
    var data4: Array&lt;UInt8&gt; = &quot;123456789&quot;.toArray()
    var hmac = HMAC(key, algorithm)
    hmac.write(data1)
    hmac.write(data2)
    hmac.write(data3)
    var md1: Array&lt;Byte&gt; = hmac.finish()
    var result1: String = toHexString(md1)
    println(result1)

    hmac.reset()
    hmac.write(data4)
    var md2: Array&lt;Byte&gt; = hmac.finish()
    var result2: String = toHexString(md2)
    println(result2)
    println(HMAC.equal(md1, md2))
    return 0
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-text">2bafeb53b60a119d38793a886c7744f5027d7eaa3702351e75e4ff9bf255e3ce296bf41f80adda2861e81bd8efc52219df821852d84a17fb625e3965ebf2fdd9
2bafeb53b60a119d38793a886c7744f5027d7eaa3702351e75e4ff9bf255e3ce296bf41f80adda2861e81bd8efc52219df821852d84a17fb625e3965ebf2fdd9
true
</code></pre>
<h2 id="sm3-算法示例"><a class="header" href="#sm3-算法示例">SM3 算法示例</a></h2>
<h3 id="调用-sm3-成员函数"><a class="header" href="#调用-sm3-成员函数">调用 SM3 成员函数</a></h3>
<p>示例：</p>
<!-- verify -->
<pre><code class="language-cangjie">import stdx.crypto.digest.*
import std.convert.*
import std.crypto.digest.*
import stdx.encoding.hex.*

main() {
    var str: String = &quot;helloworld&quot;
    var sm3Instance = SM3()
    sm3Instance.write(str.toArray())
    var md: Array&lt;Byte&gt; = sm3Instance.finish()
    var result: String = toHexString(md)
    println(result)
    return 0
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-text">c70c5f73da4e8b8b73478af54241469566f6497e16c053a03a0170fa00078283
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdxcryptokeys"><a class="header" href="#stdxcryptokeys">stdx.crypto.keys</a></h1>
<h2 id="功能介绍-3"><a class="header" href="#功能介绍-3">功能介绍</a></h2>
<p>keys 包提供非对称加密和签名算法，包括 RSA 和 SM2 非对称加密算法以及 ECDSA 签名算法。</p>
<p>使用本包需要外部依赖 OpenSSL 3 的 crypto 动态库文件，故使用前需安装相关工具。</p>
<ul>
<li>
<p>对于 Linux 操作系统，可参考以下方式：</p>
<ul>
<li>如果系统的包管理工具支持安装 OpenSSL 3 开发工具包，可通过这个方式安装，并确保系统安装目录下含有 libcrypto.so 和 libcrypto.so.3 这两个动态库文件，例如 Ubuntu 22.04 系统上可使用 sudo apt install libssl-dev 命令安装 libssl-dev 工具包；</li>
<li>如果无法通过上面的方式安装，可自行下载 OpenSSL 3.x.x 源码编译安装软件包，并确保安装目录下含有 libcrypto.so 和 libcrypto.so.3 这两个动态库文件，然后可选择下面任意一种方式来保证系统链接器可以找到这些文件:
<ul>
<li>在系统未安装 OpenSSL 的场景，安装时选择直接安装到系统路径下；</li>
<li>安装在自定义目录的场景，将这些文件所在目录设置到环境变量 LD_LIBRARY_PATH 以及 LIBRARY_PATH 中。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>对于 Windows 操作系统，可按照以下步骤：</p>
<ul>
<li>自行下载 OpenSSL 3.x.x 源码编译安装 x64 架构软件包或者自行下载安装第三方预编译的供开发人员使用的 OpenSSL 3.x.x 软件包；</li>
<li>确保安装目录下含有 libcrypto.dll.a（或 libcrypto.lib）、libcrypto-3-x64.dll 这两个库文件；</li>
<li>将 libcrypto.dll.a（或 libcrypto.lib）所在的目录路径设置到环境变量 LIBRARY_PATH 中，将 libcrypto-3-x64.dll 所在的目录路径设置到环境变量 PATH 中。</li>
</ul>
</li>
<li>
<p>对于 macOS 操作系统，可参考以下方式：</p>
<ul>
<li>使用 brew install openssl@3 安装，并确保系统安装目录下含有 libcrypto.dylib 和 libcrypto.3.dylib 这两个动态库文件；</li>
<li>如果无法通过上面的方式安装，可自行下载 OpenSSL 3.x.x 源码编译安装软件包，并确保安装目录下含有 libcrypto.dylib 和 libcrypto.3.dylib 这两个动态库文件，然后可选择下面任意一种方式来保证系统链接器可以找到这些文件:
<ul>
<li>在系统未安装 OpenSSL 的场景，安装时选择直接安装到系统路径下；</li>
<li>安装在自定义目录的场景，将这些文件所在目录设置到环境变量 DYLD_LIBRARY_PATH 以及 LIBRARY_PATH 中。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>说明：</strong></p>
<p>如果未安装 OpenSSL 3 软件包或者安装低版本的软件包，程序可能无法使用并抛出相关异常 CryptoException：Can not load openssl library or function xxx。</p>
</blockquote>
<h2 id="api-列表-3"><a class="header" href="#api-列表-3">API 列表</a></h2>
<h3 id="类-6"><a class="header" href="#类-6">类</a></h3>
<div class="table-wrapper"><table><thead><tr><th>类名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="crypto/keys/./keys_package_api/keys_package_classes.html#class-ecdsaprivateKey">ECDSAPrivateKey</a></td><td>ECDSA私钥类。</td></tr>
<tr><td><a href="crypto/keys/./keys_package_api/keys_package_classes.html#class-ecdsapublicKey">ECDSAPublicKey</a></td><td>ECDSA公钥类。</td></tr>
<tr><td><a href="crypto/keys/./keys_package_api/keys_package_classes.html#class-rsaprivateKey">RSAPrivateKey</a></td><td>RSA私钥类。</td></tr>
<tr><td><a href="crypto/keys/./keys_package_api/keys_package_classes.html#class-rsapublicKey">RSAPublicKey</a></td><td>RSA公钥类。</td></tr>
<tr><td><a href="crypto/keys/./keys_package_api/keys_package_classes.html#class-sm2privateKey">SM2PrivateKey</a></td><td>SM2私钥类。</td></tr>
<tr><td><a href="crypto/keys/./keys_package_api/keys_package_classes.html#class-sm2publicKey">SM2PublicKey</a></td><td>SM2公钥类。</td></tr>
</tbody></table>
</div>
<h3 id="枚举-2"><a class="header" href="#枚举-2">枚举</a></h3>
<div class="table-wrapper"><table><thead><tr><th>枚举名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="crypto/keys/./keys_package_api/keys_package_enums.html#enum-curve">Curve</a></td><td>枚举类型 Curve 用于选择生成 ECDSA 密钥时使用的椭圆曲线类型。</td></tr>
<tr><td><a href="crypto/keys/./keys_package_api/keys_package_enums.html#enum-padoption">PadOption</a></td><td>用于设置 RSA 的填充模式。</td></tr>
</tbody></table>
</div>
<h3 id="结构体-4"><a class="header" href="#结构体-4">结构体</a></h3>
<div class="table-wrapper"><table><thead><tr><th>结构体名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="crypto/keys/./keys_package_api/keys_package_structs.html#struct-oaepoption">OAEPOption</a></td><td>最优非对称加密填充。</td></tr>
<tr><td><a href="crypto/keys/./keys_package_api/keys_package_structs.html#struct-pssoption">PSSOption</a></td><td>概率签名方案。</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="类-7"><a class="header" href="#类-7">类</a></h1>
<h2 id="class-ecdsaprivatekey"><a class="header" href="#class-ecdsaprivatekey">class ECDSAPrivateKey</a></h2>
<pre><code class="language-cangjie">public class ECDSAPrivateKey &lt;: PrivateKey {
    public init(curve: Curve)
}
</code></pre>
<p>功能：ECDSA 私钥类，提供生成 ECDSA 私钥能力，ECDSA 的私钥支持签名操作，同时支持 PEM 和 DER 格式的编码解码。使用示例见 <a href="crypto/keys/keys_package_api/../keys_samples/sample_keys.html#ECDSA-%E5%AF%86%E9%92%A5%E7%A4%BA%E4%BE%8B">ECDSA 密钥示例</a>。</p>
<p>父类型：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../x509/x509_package_api/x509_package_interfaces.html#interface-privatekey">PrivateKey</a></li>
</ul>
<h3 id="initcurve"><a class="header" href="#initcurve">init(Curve)</a></h3>
<pre><code class="language-cangjie">public init(curve: Curve)
</code></pre>
<p>功能：init 初始化生成私钥。</p>
<p>参数：</p>
<ul>
<li>curve: <a href="crypto/keys/keys_package_api/keys_package_enums.html#enum-curve">Curve</a> - 椭圆曲线类型。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 初始化失败，抛出异常。</li>
</ul>
<h3 id="static-func-decodederderblob"><a class="header" href="#static-func-decodederderblob">static func decodeDer(DerBlob)</a></h3>
<pre><code class="language-cangjie">public static func decodeDer(blob: DerBlob): ECDSAPrivateKey
</code></pre>
<p>功能：将私钥从 DER 格式解码。</p>
<p>参数：</p>
<ul>
<li>blob: <a href="crypto/keys/keys_package_api/../../x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a> - 二进制格式的私钥对象。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/keys_package_classes.html#class-ecdsaprivatekey">ECDSAPrivateKey</a> - 解码出的 ECDSA 私钥。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 解码失败，抛出异常。</li>
</ul>
<h3 id="static-func-decodederderblob-string"><a class="header" href="#static-func-decodederderblob-string">static func decodeDer(DerBlob, ?String)</a></h3>
<pre><code class="language-cangjie">public static func decodeDer(blob: DerBlob, password!: ?String): ECDSAPrivateKey
</code></pre>
<p>功能：将加密的私钥从 DER 格式解码。</p>
<p>参数：</p>
<ul>
<li>blob: <a href="crypto/keys/keys_package_api/../../x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a> - 二进制格式的私钥对象。</li>
<li>password!: ?String - 解密私钥需要提供的密码，密码为 None 时则不解密。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/keys_package_classes.html#class-ecdsaprivatekey">ECDSAPrivateKey</a> - 解码出的 ECDSA 私钥。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 解码失败、解密失败或者参数密码为空字符串，抛出异常。</li>
</ul>
<h3 id="static-func-decodefrompemstring"><a class="header" href="#static-func-decodefrompemstring">static func decodeFromPem(String)</a></h3>
<pre><code class="language-cangjie">public static func decodeFromPem(text: String): ECDSAPrivateKey
</code></pre>
<p>功能：将私钥从 PEM 格式解码。</p>
<p>参数：</p>
<ul>
<li>text: String - PEM 格式的私钥字符流。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/keys_package_classes.html#class-ecdsaprivatekey">ECDSAPrivateKey</a> - 解码出的 ECDSA 私钥。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 解码失败、字符流不符合 PEM 格式或文件头不符合私钥头标准时，抛出异常。</li>
</ul>
<h3 id="static-func-decodefrompemstring-string"><a class="header" href="#static-func-decodefrompemstring-string">static func decodeFromPem(String, ?String)</a></h3>
<pre><code class="language-cangjie">public static func decodeFromPem(text: String, password!: ?String): ECDSAPrivateKey
</code></pre>
<p>功能：将私钥从PEM 格式解码。</p>
<p>参数：</p>
<ul>
<li>text: String - PEM 格式的私钥字符流。</li>
<li>password!: ?String - 解密私钥需要提供的密码，密码为 None 时则不解密。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/keys_package_classes.html#class-ecdsaprivatekey">ECDSAPrivateKey</a> - 解码出的 ECDSA 私钥。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 解码失败、解密失败、参数密码为空字符串、字符流不符合 PEM 格式或文件头不符合私钥头标准时，抛出异常。</li>
</ul>
<h3 id="func-encodetoder"><a class="header" href="#func-encodetoder">func encodeToDer()</a></h3>
<pre><code class="language-cangjie">public override func encodeToDer(): DerBlob
</code></pre>
<p>功能：将私钥编码为 DER 格式。</p>
<p>返回值：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a> - 编码后的 Der 格式私钥。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 编码失败，抛出异常。</li>
</ul>
<h3 id="func-encodetoderstring"><a class="header" href="#func-encodetoderstring">func encodeToDer(?String)</a></h3>
<pre><code class="language-cangjie">public func encodeToDer(password!: ?String): DerBlob
</code></pre>
<p>功能：使用 AES-256-CBC 加密私钥，将私钥编码为 DER 格式。</p>
<p>参数：</p>
<ul>
<li>password!: ?String - 加密私钥需要提供的密码，密码为 None 时则不加密。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a> - 编码后的 DER 格式私钥。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 编码失败、加密失败或者参数密码为空字符串，抛出异常。</li>
</ul>
<h3 id="func-encodetopem"><a class="header" href="#func-encodetopem">func encodeToPem()</a></h3>
<pre><code class="language-cangjie">public override func encodeToPem(): PemEntry
</code></pre>
<p>功能：将私钥编码为 PEM 格式。</p>
<p>返回值：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../x509/x509_package_api/x509_package_structs.html#struct-pementry">PemEntry</a> - 私钥 PEM 格式的对象。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 编码失败，抛出异常。</li>
</ul>
<h3 id="func-signarraybyte"><a class="header" href="#func-signarraybyte">func sign(Array&lt;Byte&gt;)</a></h3>
<pre><code class="language-cangjie">public func sign(digest: Array&lt;Byte&gt;): Array&lt;Byte&gt;
</code></pre>
<p>功能：sign 对数据的摘要结果进行签名。</p>
<p>参数：</p>
<ul>
<li>digest: Array&lt;Byte&gt; - 数据的摘要结果。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Array&lt;Byte&gt; - 签名后的数据。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 签名失败，抛出异常。</li>
</ul>
<h3 id="func-tostring-2"><a class="header" href="#func-tostring-2">func toString</a></h3>
<pre><code class="language-cangjie">public override func toString(): String
</code></pre>
<p>功能：输出私钥种类。</p>
<p>返回值：</p>
<ul>
<li>String - 密钥类别描述。</li>
</ul>
<h2 id="class-ecdsapublickey"><a class="header" href="#class-ecdsapublickey">class ECDSAPublicKey</a></h2>
<pre><code class="language-cangjie">public class ECDSAPublicKey &lt;: PublicKey {
    public init(pri: ECDSAPrivateKey)
}
</code></pre>
<p>功能：ECDSA 公钥类，提供生成 ECDSA 公钥能力，ECDSA 公钥支持验证签名操作，支持 PEM 和 DER 格式的编码解码。使用示例见 <a href="crypto/keys/keys_package_api/../keys_samples/sample_keys.html#ECDSA-%E5%AF%86%E9%92%A5%E7%A4%BA%E4%BE%8B">ECDSA 密钥示例</a>。</p>
<p>父类型：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../x509/x509_package_api/x509_package_interfaces.html#interface-publickey">PublicKey</a></li>
</ul>
<h3 id="initecdsaprivatekey"><a class="header" href="#initecdsaprivatekey">init(ECDSAPrivateKey)</a></h3>
<pre><code class="language-cangjie">public init(pri: ECDSAPrivateKey)
</code></pre>
<p>功能：init 初始化公钥，从私钥中获取对应的公钥。</p>
<p>参数：</p>
<ul>
<li>pri: <a href="crypto/keys/keys_package_api/keys_package_classes.html#class-ecdsaprivatekey">ECDSAPrivateKey</a> - ECDSA 私钥。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 初始化失败，抛出异常。</li>
</ul>
<h3 id="static-func-decodederderblob-1"><a class="header" href="#static-func-decodederderblob-1">static func decodeDer(DerBlob)</a></h3>
<pre><code class="language-cangjie">public static func decodeDer(blob: DerBlob): ECDSAPublicKey
</code></pre>
<p>功能：将公钥从 DER 格式解码。</p>
<p>参数：</p>
<ul>
<li>blob: <a href="crypto/keys/keys_package_api/../../x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a> - 二进制格式的公钥对象。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/keys_package_classes.html#class-ecdsapublickey">ECDSAPublicKey</a> - 解码出的 ECDSA 公钥。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 编码失败，抛出异常。</li>
</ul>
<h3 id="static-func-decodefrompemstring-1"><a class="header" href="#static-func-decodefrompemstring-1">static func decodeFromPem(String)</a></h3>
<pre><code class="language-cangjie">public static func decodeFromPem(text: String): ECDSAPublicKey
</code></pre>
<p>功能：将公钥从 PEM 格式解码。</p>
<p>参数：</p>
<ul>
<li>text: String - PEM 格式的公钥字符流。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/keys_package_classes.html#class-ecdsapublickey">ECDSAPublicKey</a> - 解码出的 ECDSA 公钥。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 解码失败、字符流不符合 PEM 格式或文件头不符合公钥头标准时，抛出异常。</li>
</ul>
<h3 id="func-encodetoder-1"><a class="header" href="#func-encodetoder-1">func encodeToDer()</a></h3>
<pre><code class="language-cangjie">public override func encodeToDer(): DerBlob
</code></pre>
<p>功能：将公钥编码为 DER 格式。</p>
<p>返回值：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a> - 编码后的 Der 格式公钥。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 编码失败，抛出异常。</li>
</ul>
<h3 id="func-encodetopem-1"><a class="header" href="#func-encodetopem-1">func encodeToPem()</a></h3>
<pre><code class="language-cangjie">public override func encodeToPem(): PemEntry
</code></pre>
<p>功能：将公钥编码为 PEM 格式。</p>
<p>返回值：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../x509/x509_package_api/x509_package_structs.html#struct-pementry">PemEntry</a> - <a href="crypto/keys/keys_package_api/../../x509/x509_package_api/x509_package_structs.html#struct-pementry">PemEntry</a> 对象。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 编码失败，抛出异常。</li>
</ul>
<h3 id="func-tostring-3"><a class="header" href="#func-tostring-3">func toString</a></h3>
<pre><code class="language-cangjie">public override func toString(): String
</code></pre>
<p>功能：输出公钥种类。</p>
<p>返回值：</p>
<ul>
<li>String - 密钥类别描述。</li>
</ul>
<h3 id="func-verifyarraybyte-arraybyte"><a class="header" href="#func-verifyarraybyte-arraybyte">func verify(Array&lt;Byte&gt;, Array&lt;Byte&gt;)</a></h3>
<pre><code class="language-cangjie">public func verify(digest: Array&lt;Byte&gt;, sig: Array&lt;Byte&gt;): Bool
</code></pre>
<p>功能：verify 验证签名结果。</p>
<p>参数：</p>
<ul>
<li>digest: Array&lt;Byte&gt; - 数据的摘要结果。</li>
<li>sig: Array&lt;Byte&gt; - 数据的签名结果。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - 返回 true 表示验证成功，false 失败。</li>
</ul>
<h2 id="class-rsaprivatekey"><a class="header" href="#class-rsaprivatekey">class RSAPrivateKey</a></h2>
<pre><code class="language-cangjie">public class RSAPrivateKey &lt;: PrivateKey{
    public init(bits: Int32)
    public init(bits: Int32, e: BigInt)
}
</code></pre>
<p>功能：RSA 私钥类，提供生成 RSA 私钥能力，RSA 私钥支持签名和解密操作，支持 PEM 和 DER 格式的编码解码，符合 PKCS1 标准。使用示例见 <a href="crypto/keys/keys_package_api/../keys_samples/sample_keys.html#RSA-%E5%AF%86%E9%92%A5%E7%A4%BA%E4%BE%8B">RSA 密钥示例</a>。</p>
<p>父类型：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../x509/x509_package_api/x509_package_interfaces.html#interface-privatekey">PrivateKey</a></li>
</ul>
<h3 id="initint32"><a class="header" href="#initint32">init(Int32)</a></h3>
<pre><code class="language-cangjie">public init(bits: Int32)
</code></pre>
<p>功能：init 初始化生成私钥，公钥指数默认值为 65537，业界推荐。公钥指数e的大小直接影响了RSA算法的安全性和加密效率。通常情况下，e的值越小，加密速度越快，但安全性越低。</p>
<p>参数：</p>
<ul>
<li>bits: Int32 - 密钥长度，需要大于等于 512 位，并且小于等于 16384 位。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 密钥长度不符合要求或初始化失败，抛出异常。</li>
</ul>
<h3 id="initint32-bigint"><a class="header" href="#initint32-bigint">init(Int32, BigInt)</a></h3>
<pre><code class="language-cangjie">public init(bits: Int32, e: BigInt)
</code></pre>
<p>功能：init 初始化生成私钥，允许用户指定公共指数。</p>
<p>参数：</p>
<ul>
<li>bits: Int32 - 密钥长度，需要大于等于 512 位，并且小于等于 16384 位，推荐使用的密钥长度不小于 3072 位。</li>
<li>e: BigInt - 公钥公共指数，范围是 [3, 2^256-1] 的奇数。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 密钥长度不符合要求、公钥公共指数值不符合要求或初始化失败，抛出异常。</li>
</ul>
<h3 id="static-func-decodederderblob-2"><a class="header" href="#static-func-decodederderblob-2">static func decodeDer(DerBlob)</a></h3>
<pre><code class="language-cangjie">public static func decodeDer(blob: DerBlob): RSAPrivateKey
</code></pre>
<p>功能：将私钥从 DER 格式解码。</p>
<p>参数：</p>
<ul>
<li>blob: <a href="crypto/keys/keys_package_api/../../x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a> - 二进制格式的私钥对象。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/keys_package_classes.html#class-rsaprivatekey">RSAPrivateKey</a> - 解码出的 RSA 私钥。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 解码失败，抛出异常。</li>
</ul>
<h3 id="static-func-decodederderblob-string-1"><a class="header" href="#static-func-decodederderblob-string-1">static func decodeDer(DerBlob, ?String)</a></h3>
<pre><code class="language-cangjie">public static func decodeDer(blob: DerBlob, password!: ?String): RSAPrivateKey
</code></pre>
<p>功能：将加密的私钥从 DER 格式解码。</p>
<p>参数：</p>
<ul>
<li>blob: <a href="crypto/keys/keys_package_api/../../x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a> - 二进制格式的私钥对象。</li>
<li>password!: ?String - 解密私钥需要提供的密码，密码为 None 时则不解密。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/keys_package_classes.html#class-rsaprivatekey">RSAPrivateKey</a> - 解码出的 RSA 私钥。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 解码失败、解密失败或者参数密码为空字符串，抛出异常。</li>
</ul>
<h3 id="static-func-decodefrompemstring-2"><a class="header" href="#static-func-decodefrompemstring-2">static func decodeFromPem(String)</a></h3>
<pre><code class="language-cangjie">public static func decodeFromPem(text: String): RSAPrivateKey
</code></pre>
<p>功能：将私钥从 PEM 格式解码。</p>
<p>参数：</p>
<ul>
<li>text: String - PEM 格式的私钥字符流。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/keys_package_classes.html#class-rsaprivatekey">RSAPrivateKey</a> - 解码出的 RSA 私钥。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 解码失败、解密失败、字符流不符合 PEM 格式或文件头不符合私钥头标准时，抛出异常。</li>
</ul>
<h3 id="static-func-decodefrompemstring-string-1"><a class="header" href="#static-func-decodefrompemstring-string-1">static func decodeFromPem(String, ?String)</a></h3>
<pre><code class="language-cangjie">public static func decodeFromPem(text: String, password!: ?String): RSAPrivateKey
</code></pre>
<p>功能：将私钥从 PEM 格式解码。</p>
<p>参数：</p>
<ul>
<li>text: String - PEM 格式的私钥字符流。</li>
<li>password!: ?String - 解密私钥需要提供的密码，密码为 None 时则不解密。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/keys_package_classes.html#class-rsaprivatekey">RSAPrivateKey</a> - 解码出的 RSA 私钥。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 解码失败、解密失败、参数密码为空字符串、字符流不符合 PEM 格式或文件头不符合私钥头标准时，抛出异常。</li>
</ul>
<h3 id="func-decryptinputstream-outputstream-padoption"><a class="header" href="#func-decryptinputstream-outputstream-padoption">func decrypt(InputStream, OutputStream, PadOption)</a></h3>
<pre><code class="language-cangjie">public func decrypt(input: InputStream, output: OutputStream, padType!: PadOption): Unit
</code></pre>
<p>功能：decrypt 解密出原始数据。</p>
<p>参数：</p>
<ul>
<li>input: InputStream - 加密的数据。</li>
<li>output: OutputStream - 解密后的数据。</li>
<li>padType!: <a href="crypto/keys/keys_package_api/keys_package_enums.html#enum-padoption">PadOption</a> - 填充模式，可以选择 PKCS1 或 OAEP 模式，不支持 PSS 模式，在对安全场景要求较高的情况下，推荐使用 OAEP 填充模式。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 设置填充模式失败或解密失败，抛出异常。</li>
</ul>
<h3 id="func-encodetoder-2"><a class="header" href="#func-encodetoder-2">func encodeToDer()</a></h3>
<pre><code class="language-cangjie">public override func encodeToDer(): DerBlob
</code></pre>
<p>功能：将私钥编码为 DER 格式。</p>
<p>返回值：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a> - 编码后的 DER 格式私钥。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 编码失败，抛出异常。</li>
</ul>
<h3 id="func-encodetoderstring-1"><a class="header" href="#func-encodetoderstring-1">func encodeToDer(?String)</a></h3>
<pre><code class="language-cangjie">public func encodeToDer(password!: ?String): DerBlob
</code></pre>
<p>功能：使用 AES-256-CBC 加密私钥，将私钥编码为 DER 格式。</p>
<p>参数：</p>
<ul>
<li>password!: ?String - 加密私钥需要提供的密码，密码为 None 时则不加密。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a> - 编码后的 DER 格式私钥。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 编码失败、加密失败或者参数密码为空字符串，抛出异常。</li>
</ul>
<h3 id="func-encodetopem-2"><a class="header" href="#func-encodetopem-2">func encodeToPem()</a></h3>
<pre><code class="language-cangjie">public override func encodeToPem(): PemEntry
</code></pre>
<p>功能：将私钥编码为 PEM 格式。</p>
<p>返回值：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../x509/x509_package_api/x509_package_structs.html#struct-pementry">PemEntry</a> - 私钥 PEM 格式的对象。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 编码失败，抛出异常。</li>
</ul>
<h3 id="func-signdigest-arraybyte-padoption"><a class="header" href="#func-signdigest-arraybyte-padoption">func sign(Digest, Array&lt;Byte&gt;, PadOption)</a></h3>
<pre><code class="language-cangjie">public func sign(hash: Digest, digest: Array&lt;Byte&gt;, padType!: PadOption): Array&lt;Byte&gt;
</code></pre>
<p>功能：对数据的摘要结果进行签名。</p>
<p>参数：</p>
<ul>
<li>hash: Digest - 摘要方法，获取 digest 结果使用的摘要方法。</li>
<li>digest: Array&lt;Byte&gt; - 数据的摘要结果。</li>
<li>padType!: <a href="crypto/keys/keys_package_api/keys_package_enums.html#enum-padoption">PadOption</a> - 填充模式，可以选择 PKCS1 或 PSS 模式，不支持 OAEP 模式，在对安全场景要求较高的情况下，推荐使用 PSS 填充模式。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Array&lt;Byte&gt; - 签名后的数据。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 设置摘要方法失败、设置填充模式失败或签名失败，抛出异常。</li>
</ul>
<h3 id="func-tostring-4"><a class="header" href="#func-tostring-4">func toString()</a></h3>
<pre><code class="language-cangjie">public override func toString(): String
</code></pre>
<p>功能：输出私钥种类。</p>
<p>返回值：</p>
<ul>
<li>String - 密钥类别描述。</li>
</ul>
<h2 id="class-rsapublickey"><a class="header" href="#class-rsapublickey">class RSAPublicKey</a></h2>
<pre><code class="language-cangjie">public class RSAPublicKey &lt;: PublicKey {
    public init(pri: RSAPrivateKey)
}
</code></pre>
<p>功能：RSA 公钥类，提供生成 RSA 公钥能力，RSA 公钥支持验证签名和加密操作，支持 PEM 和 DER 格式的编码解码。使用示例见 <a href="crypto/keys/keys_package_api/../keys_samples/sample_keys.html#RSA-%E5%AF%86%E9%92%A5%E7%A4%BA%E4%BE%8B">RSA 密钥示例</a>。</p>
<p>父类型：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../x509/x509_package_api/x509_package_interfaces.html#interface-publickey">PublicKey</a></li>
</ul>
<h3 id="initrsaprivatekey"><a class="header" href="#initrsaprivatekey">init(RSAPrivateKey)</a></h3>
<pre><code class="language-cangjie">public init(pri: RSAPrivateKey)
</code></pre>
<p>功能：init 初始化公钥，从私钥中获取对应的公钥。</p>
<p>参数：</p>
<ul>
<li>pri: <a href="crypto/keys/keys_package_api/keys_package_classes.html#class-rsaprivatekey">RSAPrivateKey</a> - RSA私钥。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 初始化失败，抛出异常。</li>
</ul>
<h3 id="static-func-decodederderblob-3"><a class="header" href="#static-func-decodederderblob-3">static func decodeDer(DerBlob)</a></h3>
<pre><code class="language-cangjie">public static func decodeDer(blob: DerBlob): RSAPublicKey
</code></pre>
<p>功能：将公钥从 DER 格式解码。</p>
<p>参数：</p>
<ul>
<li>blob: <a href="crypto/keys/keys_package_api/../../x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a> - 二进制格式的公钥对象。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/keys_package_classes.html#class-rsapublickey">RSAPublicKey</a> - 解码出的 RSA 公钥。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 解码失败，抛出异常。</li>
</ul>
<h3 id="static-func-decodefrompemstring-3"><a class="header" href="#static-func-decodefrompemstring-3">static func decodeFromPem(String)</a></h3>
<pre><code class="language-cangjie">public static func decodeFromPem(text: String): RSAPublicKey
</code></pre>
<p>功能：将公钥从PEM 格式解码。</p>
<p>参数：</p>
<ul>
<li>text: String - PEM 格式的公钥字符流。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/keys_package_classes.html#class-rsapublickey">RSAPublicKey</a> - 解码出的 RSA 公钥。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 解码失败、字符流不符合 PEM 格式或文件头不符合公钥头标准时，抛出异常。</li>
</ul>
<h3 id="func-encodetoder-3"><a class="header" href="#func-encodetoder-3">func encodeToDer()</a></h3>
<pre><code class="language-cangjie">public override func encodeToDer(): DerBlob
</code></pre>
<p>功能：将公钥编码为 DER 格式。</p>
<p>返回值：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a> - 编码后的 Der 格式公钥。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 编码失败，抛出异常。</li>
</ul>
<h3 id="func-encodetopem-3"><a class="header" href="#func-encodetopem-3">func encodeToPem()</a></h3>
<pre><code class="language-cangjie">public override func encodeToPem(): PemEntry
</code></pre>
<p>功能：将公钥编码为 PEM 格式。</p>
<p>返回值：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../x509/x509_package_api/x509_package_structs.html#struct-pementry">PemEntry</a> - 返回 <a href="crypto/keys/keys_package_api/../../x509/x509_package_api/x509_package_structs.html#struct-pementry">PemEntry</a> 对象。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 编码失败，抛出异常。</li>
</ul>
<h3 id="func-encryptinputstream-outputstream-padoption"><a class="header" href="#func-encryptinputstream-outputstream-padoption">func encrypt(InputStream, OutputStream, PadOption)</a></h3>
<pre><code class="language-cangjie">public func encrypt(input: InputStream, output: OutputStream, padType!: PadOption): Unit
</code></pre>
<p>功能：encrypt 给一段数据进行加密。</p>
<p>参数：</p>
<ul>
<li>input: InputStream - 需要加密的数据。</li>
<li>output: OutputStream - 加密后的数据。</li>
<li>padType!: <a href="crypto/keys/keys_package_api/keys_package_enums.html#enum-padoption">PadOption</a> - 填充模式，可以选择 PKCS1 或 OAEP 模式，不支持 PSS 模式，在对安全场景要求较高的情况下，推荐使用 OAEP 填充模式。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 设置填充模式失败或加密失败，抛出异常。</li>
</ul>
<h3 id="func-tostring-5"><a class="header" href="#func-tostring-5">func toString()</a></h3>
<pre><code class="language-cangjie">public override func toString(): String
</code></pre>
<p>功能：输出公钥种类。</p>
<p>返回值：</p>
<ul>
<li>String - 密钥类别描述。</li>
</ul>
<h3 id="func-verifydigest-arraybyte-arraybyte-padoption"><a class="header" href="#func-verifydigest-arraybyte-arraybyte-padoption">func verify(Digest, Array&lt;Byte&gt;, Array&lt;Byte&gt;, PadOption)</a></h3>
<pre><code class="language-cangjie">public func verify(hash: Digest, digest: Array&lt;Byte&gt;, sig: Array&lt;Byte&gt;, padType!: PadOption): Bool
</code></pre>
<p>功能：verify 验证签名结果。</p>
<p>参数：</p>
<ul>
<li>hash: Digest  - 摘要方法，获取 digest 结果使用的摘要方法。</li>
<li>digest: Array&lt;Byte&gt; - 数据的摘要结果。</li>
<li>sig: Array&lt;Byte&gt; - 数据的签名结果。</li>
<li>padType!: <a href="crypto/keys/keys_package_api/keys_package_enums.html#enum-padoption">PadOption</a> - 填充模式，可以选择 PKCS1 或 PSS 模式，不支持 OAEP 模式，在对安全场景要求较高的情况下，推荐使用 PSS 填充模式。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - 返回 true 表示验证成功，false 失败。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 设置填充模式失败或验证失败，抛出异常。</li>
</ul>
<h2 id="class-sm2privatekey"><a class="header" href="#class-sm2privatekey">class SM2PrivateKey</a></h2>
<pre><code class="language-cangjie">public class SM2PrivateKey &lt;: PrivateKey {
    public init()
}
</code></pre>
<p>功能：SM2 私钥类，提供生成 SM2 私钥能力，SM2 私钥支持签名和解密操作，支持 PEM 和 DER 格式的编码解码，符合 PKCS1 标准。使用示例见 <a href="crypto/keys/keys_package_api/../keys_samples/sample_keys.html#SM2-%E5%AF%86%E9%92%A5%E7%A4%BA%E4%BE%8B">SM2 密钥示例</a>。</p>
<p>父类型：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../x509/x509_package_api/x509_package_interfaces.html#interface-privatekey">PrivateKey</a></li>
</ul>
<h3 id="init-9"><a class="header" href="#init-9">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：init 初始化生成私钥。</p>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 初始化失败，抛出异常。</li>
</ul>
<h3 id="static-func-decodederderblob-4"><a class="header" href="#static-func-decodederderblob-4">static func decodeDer(DerBlob)</a></h3>
<pre><code class="language-cangjie">public static func decodeDer(blob: DerBlob): SM2PrivateKey
</code></pre>
<p>功能：将私钥从 DER 格式解码。</p>
<p>参数：</p>
<ul>
<li>blob: <a href="crypto/keys/keys_package_api/../../x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a> - 二进制格式的私钥对象。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/keys_package_classes.html#class-sm2privatekey">SM2PrivateKey</a> - 解码出的 SM2 私钥。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 解码失败，抛出异常。</li>
</ul>
<h3 id="static-func-decodederderblob-string-2"><a class="header" href="#static-func-decodederderblob-string-2">static func decodeDer(DerBlob, ?String)</a></h3>
<pre><code class="language-cangjie">public static func decodeDer(blob: DerBlob, password!: ?String): SM2PrivateKey
</code></pre>
<p>功能：将加密的私钥从 DER 格式解码。</p>
<p>参数：</p>
<ul>
<li>blob: <a href="crypto/keys/keys_package_api/../../x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a> - 二进制格式的私钥对象。</li>
<li>password!: ?String - 解密私钥需要提供的密码，密码为 None 时则不解密。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/keys_package_classes.html#class-sm2privatekey">SM2PrivateKey</a> - 解码出的 SM2 私钥。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 解码失败、解密失败或者参数密码为空字符串，抛出异常。</li>
</ul>
<h3 id="static-func-decodefrompemstring-4"><a class="header" href="#static-func-decodefrompemstring-4">static func decodeFromPem(String)</a></h3>
<pre><code class="language-cangjie">public static func decodeFromPem(text: String): SM2PrivateKey
</code></pre>
<p>功能：将私钥从 PEM 格式解码。</p>
<p>参数：</p>
<ul>
<li>text: String - PEM 格式的私钥字符流。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/keys_package_classes.html#class-sm2privatekey">SM2PrivateKey</a> - 解码出的 SM2 私钥。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 解码失败、解密失败、字符流不符合 PEM 格式或文件头不符合私钥头标准时，抛出异常。</li>
</ul>
<h3 id="static-func-decodefrompemstring-string-2"><a class="header" href="#static-func-decodefrompemstring-string-2">static func decodeFromPem(String, ?String)</a></h3>
<pre><code class="language-cangjie">public static func decodeFromPem(text: String, password!: ?String): SM2PrivateKey
</code></pre>
<p>功能：将私钥从 PEM 格式解码。</p>
<p>参数：</p>
<ul>
<li>text: String - PEM 格式的私钥字符流。</li>
<li>password!: ?String - 解密私钥需要提供的密码，密码为 None 时则不解密。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/keys_package_classes.html#class-sm2privatekey">SM2PrivateKey</a> - 解码出的 SM2 私钥。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 解码失败、解密失败、参数密码为空字符串、字符流不符合 PEM 格式或文件头不符合私钥头标准时，抛出异常。</li>
</ul>
<h3 id="func-decryptarraybyte-1"><a class="header" href="#func-decryptarraybyte-1">func decrypt(Array&lt;Byte&gt;)</a></h3>
<pre><code class="language-cangjie">public func decrypt(input: Array&lt;Byte&gt;): Array&lt;Byte&gt;
</code></pre>
<p>功能：decrypt 解密出原始数据，待解密密文需要遵循 ASN.1 编码规则。</p>
<p>参数：</p>
<ul>
<li>input: Array&lt;Byte&gt; - 加密的数据。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Array&lt;Byte&gt; - 解密后的数据。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 解密失败，抛出异常。</li>
</ul>
<h3 id="func-encodetoder-4"><a class="header" href="#func-encodetoder-4">func encodeToDer()</a></h3>
<pre><code class="language-cangjie">public func encodeToDer(): DerBlob
</code></pre>
<p>功能：将私钥编码为 DER 格式。</p>
<p>返回值：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a> - 编码后的 DER 格式私钥。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 编码失败，抛出异常。</li>
</ul>
<h3 id="func-encodetoderstring-2"><a class="header" href="#func-encodetoderstring-2">func encodeToDer(?String)</a></h3>
<pre><code class="language-cangjie">public func encodeToDer(password!: ?String): DerBlob
</code></pre>
<p>功能：使用 AES-256-CBC 加密私钥，将私钥编码为 DER 格式。</p>
<p>参数：</p>
<ul>
<li>password!: ?String - 加密私钥需要提供的密码，密码为 None 时则不加密。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a> - 编码后的 DER 格式公钥。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 编码失败、加密失败或者参数密码为空字符串，抛出异常。</li>
</ul>
<h3 id="func-encodetopemstring"><a class="header" href="#func-encodetopemstring">func encodeToPem(?String)</a></h3>
<pre><code class="language-cangjie">public func encodeToPem(password!: ?String): PemEntry 
</code></pre>
<p>功能：将加密的私钥编码为 PEM 格式。</p>
<p>参数：</p>
<ul>
<li>password!: ?String - 加密私钥需要提供的密码，密码为 None 时则不加密。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../x509/x509_package_api/x509_package_structs.html#struct-pementry">PemEntry</a> - 私钥 PEM 格式的对象。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 编码失败、加密失败或者参数密码为空字符串，抛出异常。</li>
</ul>
<h3 id="func-encodetopem-4"><a class="header" href="#func-encodetopem-4">func encodeToPem()</a></h3>
<pre><code class="language-cangjie">public func encodeToPem(): PemEntry
</code></pre>
<p>功能：将私钥编码为 PEM 格式。</p>
<p>返回值：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../x509/x509_package_api/x509_package_structs.html#struct-pementry">PemEntry</a> - 私钥 PEM 格式的对象。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 编码失败，抛出异常。</li>
</ul>
<h3 id="func-signarraybyte-1"><a class="header" href="#func-signarraybyte-1">func sign(Array&lt;Byte&gt;)</a></h3>
<pre><code class="language-cangjie">public func sign(data: Array&lt;Byte&gt;): Array&lt;Byte&gt;
</code></pre>
<p>功能：sign 对数据进行签名，SM2 采用<a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_classes.html#class-sm3">SM3</a>数据摘要算法。</p>
<p>参数：</p>
<ul>
<li>data: Array&lt;Byte&gt; - 数据。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Array&lt;Byte&gt; - 签名后的数据。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 签名失败，抛出异常。</li>
</ul>
<h3 id="func-tostring-6"><a class="header" href="#func-tostring-6">func toString</a></h3>
<pre><code class="language-cangjie">public override func toString(): String
</code></pre>
<p>功能：输出私钥种类。</p>
<p>返回值：</p>
<ul>
<li>String - 密钥类别描述。</li>
</ul>
<h2 id="class-sm2publickey"><a class="header" href="#class-sm2publickey">class SM2PublicKey</a></h2>
<pre><code class="language-cangjie">public class SM2PublicKey &lt;: PublicKey {
    public init(pri: SM2PrivateKey)
}
</code></pre>
<p>功能：SM2 公钥类，提供生成 SM2 公钥能力，SM2 公钥支持验证签名和加密操作，支持 PEM 和 DER 格式的编码解码。使用示例见 <a href="crypto/keys/keys_package_api/../keys_samples/sample_keys.html#SM2-%E5%AF%86%E9%92%A5%E7%A4%BA%E4%BE%8B">SM2 密钥示例</a>。</p>
<p>父类型：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../x509/x509_package_api/x509_package_interfaces.html#interface-publickey">PublicKey</a></li>
</ul>
<h3 id="initsm2privatekey"><a class="header" href="#initsm2privatekey">init(SM2PrivateKey)</a></h3>
<pre><code class="language-cangjie">public init(pri: SM2PrivateKey)
</code></pre>
<p>功能：init 初始化公钥，从私钥中获取对应的公钥。</p>
<p>参数：</p>
<ul>
<li>pri: <a href="crypto/keys/keys_package_api/keys_package_classes.html#class-sm2privatekey">SM2PrivateKey</a> - SM2 私钥。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 初始化失败，抛出异常。</li>
</ul>
<h3 id="static-func-decodederderblob-5"><a class="header" href="#static-func-decodederderblob-5">static func decodeDer(DerBlob)</a></h3>
<pre><code class="language-cangjie">public static func decodeDer(blob: DerBlob): SM2PublicKey
</code></pre>
<p>功能：将公钥从 DER 格式解码。</p>
<p>参数：</p>
<ul>
<li>blob: <a href="crypto/keys/keys_package_api/../../x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a> - 二进制格式的公钥对象。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/keys_package_classes.html#class-sm2publickey">SM2PublicKey</a> - 解码出的 SM2 公钥。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 解码失败，抛出异常。</li>
</ul>
<h3 id="static-func-decodefrompemstring-5"><a class="header" href="#static-func-decodefrompemstring-5">static func decodeFromPem(String)</a></h3>
<pre><code class="language-cangjie">public static func decodeFromPem(text: String): SM2PublicKey
</code></pre>
<p>功能：将公钥从PEM 格式解码。</p>
<p>参数：</p>
<ul>
<li>text: String - PEM 格式的公钥字符流。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/keys_package_classes.html#class-sm2publickey">SM2PublicKey</a> - 解码出的 SM2 公钥。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 解码失败、字符流不符合 PEM 格式或文件头不符合公钥头标准时，抛出异常。</li>
</ul>
<h3 id="func-encodetoder-5"><a class="header" href="#func-encodetoder-5">func encodeToDer()</a></h3>
<pre><code class="language-cangjie">public func encodeToDer(): DerBlob
</code></pre>
<p>功能：将公钥编码为 DER 格式。</p>
<p>返回值：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a> - 编码后的 Der 格式公钥。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 编码失败，抛出异常。</li>
</ul>
<h3 id="func-encodetopem-5"><a class="header" href="#func-encodetopem-5">func encodeToPem()</a></h3>
<pre><code class="language-cangjie">public func encodeToPem(): PemEntry
</code></pre>
<p>功能：将公钥编码为 PEM 格式。</p>
<p>返回值：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../x509/x509_package_api/x509_package_structs.html#struct-pementry">PemEntry</a> - 返回 <a href="crypto/keys/keys_package_api/../../x509/x509_package_api/x509_package_structs.html#struct-pementry">PemEntry</a> 对象。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 编码失败，抛出异常。</li>
</ul>
<h3 id="func-encryptarraybyte-1"><a class="header" href="#func-encryptarraybyte-1">func encrypt(Array&lt;Byte&gt;)</a></h3>
<pre><code class="language-cangjie">public func encrypt(input: Array&lt;Byte&gt;): Array&lt;Byte&gt; 
</code></pre>
<p>功能：encrypt 给一段数据进行加密，输出密文遵循 ASN.1 编码规则。</p>
<p>参数：</p>
<ul>
<li>input: Array&lt;Byte&gt; - 需要加密的数据。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Array&lt;Byte&gt; - 加密后的数据。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 加密失败，抛出异常。</li>
</ul>
<h3 id="func-tostring-7"><a class="header" href="#func-tostring-7">func toString()</a></h3>
<pre><code class="language-cangjie">public override func toString(): String
</code></pre>
<p>功能：输出公钥种类。</p>
<p>返回值：</p>
<ul>
<li>String - 密钥类别描述。</li>
</ul>
<h3 id="func-verifyarraybyte-arraybyte-1"><a class="header" href="#func-verifyarraybyte-arraybyte-1">func verify(Array&lt;Byte&gt;, Array&lt;Byte&gt;)</a></h3>
<pre><code class="language-cangjie">public func verify(data: Array&lt;Byte&gt;, sig: Array&lt;Byte&gt;): Bool
</code></pre>
<p>功能：verify 验证签名结果。</p>
<p>参数：</p>
<ul>
<li>data: Array&lt;Byte&gt; - 数据。</li>
<li>sig: Array&lt;Byte&gt; - 数据的签名结果。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - 返回 true 表示验证成功，false 失败。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 设置填充模式失败或验证失败，抛出异常。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="枚举-3"><a class="header" href="#枚举-3">枚举</a></h1>
<h2 id="enum-curve"><a class="header" href="#enum-curve">enum Curve</a></h2>
<pre><code class="language-cangjie">public enum Curve {
    | P224 | P256 | P384 | P521 | BP256 | BP320 | BP384 | BP512
}
</code></pre>
<p>功能：枚举类型 <a href="crypto/keys/keys_package_api/keys_package_enums.html#enum-curve">Curve</a> 用于选择生成 ECDSA 密钥时使用的椭圆曲线类型。</p>
<p>椭圆曲线是一种数学曲线，常用于加密算法中的密钥生成。在密码学中，椭圆曲线密码算法是一种基于椭圆曲线的公钥密码算法。它的基本思想是利用椭圆曲线上的点集构成一个计算困难性，来实现公钥密码的安全性。</p>
<p><a href="crypto/keys/keys_package_api/keys_package_enums.html#enum-curve">Curve</a> 枚举类型支持 NIST P-224，NIST P-256，NIST P-384，NIST P-521，Brainpool P-256，Brainpool P-320，Brainpool P-384，Brainpool P-512 八种椭圆曲线。</p>
<ul>
<li>
<p>NIST P-224：基于椭圆曲线的加密算法，使用224位的素数作为模数，安全性较高，适用于轻量级应用。</p>
</li>
<li>
<p>NIST P-256：基于椭圆曲线的加密算法，使用256位的素数作为模数，安全性较高，适用于中等级应用。</p>
</li>
<li>
<p>NIST P-384：基于椭圆曲线的加密算法，使用384位的素数作为模数，安全性非常高，适用于高级别应用。</p>
</li>
<li>
<p>NIST P-521：基于椭圆曲线的加密算法，使用521位的素数作为模数，安全性非常高，适用于极高级别应用。</p>
</li>
<li>
<p>Brainpool P-256：基于椭圆曲线的加密算法，使用256位的素数作为模数，安全性较高，但比NIST P-256更快。</p>
</li>
<li>
<p>Brainpool P-320：基于椭圆曲线的加密算法，使用320位的素数作为模数，安全性非常高，但比NIST P-384更快。</p>
</li>
<li>
<p>Brainpool P-384：基于椭圆曲线的加密算法，使用384位的素数作为模数，安全性非常高，但比NIST P-384更快。</p>
</li>
<li>
<p>Brainpool P-512：基于椭圆曲线的加密算法，使用512位的素数作为模数，安全性非常高，但比NIST P-521更快</p>
</li>
</ul>
<h3 id="bp256"><a class="header" href="#bp256">BP256</a></h3>
<pre><code class="language-cangjie">BP256
</code></pre>
<p>功能：使用 Brainpool P-256 椭圆曲线初始化 <a href="crypto/keys/keys_package_api/keys_package_enums.html#enum-curve">Curve</a> 实例。</p>
<h3 id="bp320"><a class="header" href="#bp320">BP320</a></h3>
<pre><code class="language-cangjie">BP320
</code></pre>
<p>功能：使用 Brainpool P-320 椭圆曲线初始化 <a href="crypto/keys/keys_package_api/keys_package_enums.html#enum-curve">Curve</a> 实例。</p>
<h3 id="bp384"><a class="header" href="#bp384">BP384</a></h3>
<pre><code class="language-cangjie">BP384
</code></pre>
<p>功能：使用 Brainpool P-384 椭圆曲线初始化 <a href="crypto/keys/keys_package_api/keys_package_enums.html#enum-curve">Curve</a> 实例。</p>
<h3 id="bp512"><a class="header" href="#bp512">BP512</a></h3>
<pre><code class="language-cangjie">BP512
</code></pre>
<p>功能：使用 Brainpool P-512 椭圆曲线初始化 <a href="crypto/keys/keys_package_api/keys_package_enums.html#enum-curve">Curve</a> 实例。</p>
<h3 id="p224"><a class="header" href="#p224">P224</a></h3>
<pre><code class="language-cangjie">P224
</code></pre>
<p>功能：使用 NIST P-224 椭圆曲线初始化 <a href="crypto/keys/keys_package_api/keys_package_enums.html#enum-curve">Curve</a> 实例。</p>
<h3 id="p256"><a class="header" href="#p256">P256</a></h3>
<pre><code class="language-cangjie">P256
</code></pre>
<p>功能：使用 NIST P-256 椭圆曲线初始化 <a href="crypto/keys/keys_package_api/keys_package_enums.html#enum-curve">Curve</a> 实例。</p>
<h3 id="p384"><a class="header" href="#p384">P384</a></h3>
<pre><code class="language-cangjie">P384
</code></pre>
<p>功能：使用 NIST P-384 椭圆曲线初始化 <a href="crypto/keys/keys_package_api/keys_package_enums.html#enum-curve">Curve</a> 实例。</p>
<h3 id="p521"><a class="header" href="#p521">P521</a></h3>
<pre><code class="language-cangjie">P521
</code></pre>
<p>功能：使用 NIST P-521 椭圆曲线初始化 <a href="crypto/keys/keys_package_api/keys_package_enums.html#enum-curve">Curve</a> 实例。</p>
<h2 id="enum-padoption"><a class="header" href="#enum-padoption">enum PadOption</a></h2>
<pre><code class="language-cangjie">public enum PadOption {
    | OAEP(OAEPOption) | PSS(PSSOption) | PKCS1
}
</code></pre>
<p>功能：用于设置 RSA 的填充模式。</p>
<p>RSA 有三种常用的填充模式：</p>
<p>OAEP 为最优非对称加密填充，只能用于加密解密；
PSS 为概率签名方案，只能用于签名和验证；
PKCS1 是一种普通的填充模式，用于填充数据长度，可以用于加密、解密、签名和验证。
RSA 的 PKCS1 填充模式是在早期的 PKCS #1 v1.5 规范中定义的填充模式，当前对使用 PKCS1 填充模式的攻击较为成熟，容易被攻击者解密或伪造签名，建议采用 PKCS #1 v2 版本中更加安全的 PSS 或 OAEP 填充模式。</p>
<h3 id="oaepoaepoption"><a class="header" href="#oaepoaepoption">OAEP(OAEPOption)</a></h3>
<pre><code class="language-cangjie">OAEP(OAEPOption)
</code></pre>
<p>功能：使用最优非对称加密初始化 <a href="crypto/keys/keys_package_api/keys_package_enums.html#enum-padoption">PadOption</a> 实例。</p>
<h3 id="pkcs1"><a class="header" href="#pkcs1">PKCS1</a></h3>
<pre><code class="language-cangjie">PKCS1
</code></pre>
<p>功能：使用 PKCS #1 公钥密码学标准初始化 <a href="crypto/keys/keys_package_api/keys_package_enums.html#enum-padoption">PadOption</a> 实例。</p>
<h3 id="psspssoption"><a class="header" href="#psspssoption">PSS(PSSOption)</a></h3>
<pre><code class="language-cangjie">PSS(PSSOption)
</code></pre>
<p>功能：使用概率签名方案初始化 <a href="crypto/keys/keys_package_api/keys_package_enums.html#enum-padoption">PadOption</a> 实例。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="结构体-5"><a class="header" href="#结构体-5">结构体</a></h1>
<h2 id="struct-oaepoption"><a class="header" href="#struct-oaepoption">struct OAEPOption</a></h2>
<pre><code class="language-cangjie">public struct OAEPOption {
    public init(hash: Digest, mgfHash: Digest, label!: String = &quot;&quot;)
}
</code></pre>
<p>功能：此结构体为 <a href="crypto/keys/keys_package_api/./keys_package_enums.html#enum-padoption">OAEP</a>  填充模式需要设置的参数。</p>
<h3 id="initdigest-digest-string"><a class="header" href="#initdigest-digest-string">init(Digest, Digest, String)</a></h3>
<pre><code class="language-cangjie">public init(hash: Digest, mgfHash: Digest, label!: String = &quot;&quot;)
</code></pre>
<p>功能：初始化 OAEP 填充参数。</p>
<p>参数：</p>
<ul>
<li>hash: Digest - 摘要方法，用于对 label 进行摘要。</li>
<li>mgfHash: Digest - 摘要方法，用于设置 MGF1 函数中的摘要方法。</li>
<li>label!: String - label 是可选参数，默认为空字符串，可以通过设置 label 来区分不同的加密操作。</li>
</ul>
<h2 id="struct-pssoption"><a class="header" href="#struct-pssoption">struct PSSOption</a></h2>
<pre><code class="language-cangjie">public struct PSSOption {
    public init(saltLen: Int32)
}
</code></pre>
<p>功能: 此结构体为 <a href="crypto/keys/keys_package_api/./keys_package_enums.html#enum-padoption">PSS</a> 填充模式需要设置的参数。</p>
<h3 id="initint32-1"><a class="header" href="#initint32-1">init(Int32)</a></h3>
<pre><code class="language-cangjie(Int32)">public init(saltLen: Int32)
</code></pre>
<p>功能：初始化 PSS 填充参数。</p>
<p>参数：</p>
<ul>
<li>saltLen: Int32 - 随机盐长度，长度应大于等于 0，小于等于（RSA 长度 - 摘要长度 - 2），长度单位为字节，长度过长会导致签名失败。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/keys/keys_package_api/../../digest/digest_package_api/digest_package_exceptions.html#class-cryptoexception">CryptoException</a> - 随机盐长度小于 0，抛出异常。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keys-使用"><a class="header" href="#keys-使用">keys 使用</a></h1>
<h2 id="rsa-密钥示例"><a class="header" href="#rsa-密钥示例">RSA 密钥示例</a></h2>
<h3 id="生成-rsa-公钥及私钥并使用公钥的-oaep-填充模式加密用私钥的-oaep-填充模式解密"><a class="header" href="#生成-rsa-公钥及私钥并使用公钥的-oaep-填充模式加密用私钥的-oaep-填充模式解密">生成 rsa 公钥及私钥，并使用公钥的 OAEP 填充模式加密，用私钥的 OAEP 填充模式解密</a></h3>
<p>示例：</p>
<!-- verify -->
<pre><code class="language-cangjie">import stdx.crypto.keys.*
import stdx.crypto.digest.*
import std.io.*
import std.crypto.digest.*

main() {
    var rsaPri = RSAPrivateKey(2048)
    var rsaPub = RSAPublicKey(rsaPri)

    var str: String = &quot;hello world, hello cangjie&quot;
    var bas1 = ByteBuffer()
    var bas2 = ByteBuffer()
    var bas3 = ByteBuffer()
    bas1.write(str.toArray())

    var encOpt = OAEPOption(SHA1(), SHA256())
    rsaPub.encrypt(bas1, bas2, padType: OAEP(encOpt))
    var encOpt2 = OAEPOption(SHA1(), SHA256())
    rsaPri.decrypt(bas2, bas3, padType: OAEP(encOpt2))

    var buf = Array&lt;Byte&gt;(str.size, repeat: 0)
    bas3.read(buf)
    if (str.toArray() == buf) {
        println(&quot;success&quot;)
    } else {
        println(&quot;fail&quot;)
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-text">success
</code></pre>
<h3 id="从文件中读取-rsa-公钥和私钥并使用私钥的-pkcs1-填充模式签名用公钥的-pkcs1-填充模式验证签名结果"><a class="header" href="#从文件中读取-rsa-公钥和私钥并使用私钥的-pkcs1-填充模式签名用公钥的-pkcs1-填充模式验证签名结果">从文件中读取 rsa 公钥和私钥，并使用私钥的 PKCS1 填充模式签名，用公钥的 PKCS1 填充模式验证签名结果</a></h3>
<p><strong>说明：</strong>
&gt;</p>
<blockquote>
<ul>
<li>需要自行准备公私钥文件。</li>
</ul>
</blockquote>
<p>示例：</p>
<!-- compile -->
<pre><code class="language-cangjie">import stdx.crypto.keys.*
import stdx.crypto.digest.*
import std.crypto.digest.*
import std.fs.*
import std.io.*
 
main() {
    var pemPri = String.fromUtf8(readToEnd(File(&quot;./files/rsaPri.pem&quot;, Read)))
    var rsaPri = RSAPrivateKey.decodeFromPem(pemPri)
 
    var pemPub = String.fromUtf8(readToEnd(File(&quot;./files/rsaPub.pem&quot;, Read)))
    var rsaPub = RSAPublicKey.decodeFromPem(pemPub)
 
    var str: String = &quot;helloworld&quot;
    var sha512Instance = SHA512()
    sha512Instance.write(str.toArray())
    var md: Array&lt;Byte&gt; = sha512Instance.finish()
 
    var sig = rsaPri.sign(sha512Instance, md, padType: PKCS1)
    if (rsaPub.verify(sha512Instance, md, sig, padType: PKCS1)){
        println(&quot;verify successful&quot;)
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-text">verify successful
</code></pre>
<h2 id="ecdsa-密钥示例"><a class="header" href="#ecdsa-密钥示例">ECDSA 密钥示例</a></h2>
<h3 id="生成-ecdsa-公钥及私钥并使用私钥签名公钥验证签名结果"><a class="header" href="#生成-ecdsa-公钥及私钥并使用私钥签名公钥验证签名结果">生成 ECDSA 公钥及私钥，并使用私钥签名，公钥验证签名结果</a></h3>
<p>示例：</p>
<!-- verify -->
<pre><code class="language-cangjie">import stdx.crypto.keys.*
import stdx.crypto.digest.*
import std.convert.*
import std.crypto.digest.*

main() {
    var ecPri = ECDSAPrivateKey(P224)
    var ecPub = ECDSAPublicKey(ecPri)

    var str: String = &quot;helloworld&quot;
    var sha512Instance = SHA512()
    sha512Instance.write(str.toArray())
    var md: Array&lt;Byte&gt; = sha512Instance.finish()

    var sig = ecPri.sign(md)
    if (ecPub.verify(md, sig)) {
        println(&quot;verify successful&quot;)
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-text">verify successful
</code></pre>
<h2 id="sm2-密钥示例"><a class="header" href="#sm2-密钥示例">SM2 密钥示例</a></h2>
<h3 id="生成-sm2-公钥及私钥并使用私钥签名公钥验证签名结果"><a class="header" href="#生成-sm2-公钥及私钥并使用私钥签名公钥验证签名结果">生成 SM2 公钥及私钥，并使用私钥签名，公钥验证签名结果</a></h3>
<p>示例：</p>
<!-- verify -->
<pre><code class="language-cangjie">import stdx.crypto.keys.*
import stdx.crypto.digest.*
import std.convert.*
import std.crypto.digest.*
import std.fs.*
import std.io.*

main(): Unit {
    /* 无参生成公钥私钥 */
    let sm2PrivateKey = SM2PrivateKey()
    let sm2PublicKey = SM2PublicKey(sm2PrivateKey)

    /* 公钥和私钥导出 */
    let priPem = sm2PrivateKey.encodeToPem()
    let file1: File = File(&quot;./sm2Pri.pem&quot;, Write)
    file1.write(priPem.encode().toArray())
    file1.close()

    let pubPem = sm2PublicKey.encodeToPem()
    let file2: File = File(&quot;./sm2Pub.pem&quot;, Write)
    file2.write(pubPem.encode().toArray())
    file2.close()

    /* 公钥加密，私钥解密 */
    let str: String = &quot;helloworld&quot;
    let encresult = sm2PublicKey.encrypt(str.toArray())
    let decresult = sm2PrivateKey.decrypt(encresult)
    println(String.fromUtf8(decresult))

    /* 私钥签名，公钥验证 */
    let strSig: String = &quot;helloworld&quot;
    let sigRe = sm2PrivateKey.sign(strSig.toArray())
    let verifyre = sm2PublicKey.verify(strSig.toArray(), sigRe)
    println(verifyre)

    /* 私钥公钥导入 */
    let pemPri = String.fromUtf8(readToEnd(File(&quot;./sm2Pri.pem&quot;, Read)))
    let sm2PrivateKeyNew = SM2PrivateKey.decodeFromPem(pemPri)
    println(sm2PrivateKeyNew)
    let pemPub = String.fromUtf8(readToEnd(File(&quot;./sm2Pub.pem&quot;, Read)))
    let sm2PublicKeyNew = SM2PublicKey.decodeFromPem(pemPub)
    println(sm2PublicKeyNew)
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-text">helloworld
true
SM2 PRIVATE KEY
SM2 PUBLIC KEY
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdxcryptox509"><a class="header" href="#stdxcryptox509">stdx.crypto.x509</a></h1>
<h2 id="功能介绍-4"><a class="header" href="#功能介绍-4">功能介绍</a></h2>
<p>x509 包提供处理数字证书功能，提供包括解析和序列化 X509 证书、验证证书、创建自签名证书、创建和验证证书链等主要功能。</p>
<p>使用本包需要外部依赖 OpenSSL 3 的 crypto 动态库文件，故使用前需安装相关工具。</p>
<ul>
<li>
<p>对于 Linux 操作系统，可参考以下方式：</p>
<ul>
<li>如果系统的包管理工具支持安装 OpenSSL 3 开发工具包，可通过这个方式安装，并确保系统安装目录下含有 libcrypto.so 和 libcrypto.so.3 这两个动态库文件，例如 Ubuntu 22.04 系统上可使用 sudo apt install libssl-dev 命令安装 libssl-dev 工具包；</li>
<li>如果无法通过上面的方式安装，可自行下载 OpenSSL 3.x.x 源码编译安装软件包，并确保安装目录下含有 libcrypto.so 和 libcrypto.so.3 这两个动态库文件，然后可选择下面任意一种方式来保证系统链接器可以找到这些文件:
<ul>
<li>在系统未安装 OpenSSL 的场景，安装时选择直接安装到系统路径下；</li>
<li>安装在自定义目录的场景，将这些文件所在目录设置到环境变量 LD_LIBRARY_PATH 以及 LIBRARY_PATH 中。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>对于 Windows 操作系统，可按照以下步骤：</p>
<ul>
<li>自行下载 OpenSSL 3.x.x 源码编译安装 x64 架构软件包或者自行下载安装第三方预编译的供开发人员使用的 OpenSSL 3.x.x 软件包；</li>
<li>确保安装目录下含有 libcrypto.dll.a(或 libcrypto.lib)、libcrypto-3-x64.dll 这两个库文件；</li>
<li>将 libcrypto.dll.a(或 libcrypto.lib) 所在的目录路径设置到环境变量 LIBRARY_PATH 中，将 libcrypto-3-x64.dll 所在的目录路径设置到环境变量 PATH 中。</li>
</ul>
</li>
<li>
<p>对于 macOS 操作系统，可参考以下方式：</p>
<ul>
<li>使用 brew install openssl@3 安装，并确保系统安装目录下含有 libcrypto.dylib 和 libcrypto.3.dylib 这两个动态库文件；</li>
<li>如果无法通过上面的方式安装，可自行下载 OpenSSL 3.x.x 源码编译安装软件包，并确保安装目录下含有 libcrypto.dylib 和 libcrypto.3.dylib 这两个动态库文件，然后可选择下面任意一种方式来保证系统链接器可以找到这些文件:
<ul>
<li>在系统未安装 OpenSSL 的场景，安装时选择直接安装到系统路径下；</li>
<li>安装在自定义目录的场景，将这些文件所在目录设置到环境变量 DYLD_LIBRARY_PATH 以及 LIBRARY_PATH 中。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>说明：</strong></p>
<p>如果未安装 OpenSSL 3 软件包或者安装低版本的软件包，程序可能无法使用并抛出相关异常 X509Exception: Can not load openssl library or function xxx。</p>
</blockquote>
<h2 id="api-列表-4"><a class="header" href="#api-列表-4">API 列表</a></h2>
<h3 id="类型别名"><a class="header" href="#类型别名">类型别名</a></h3>
<div class="table-wrapper"><table><thead><tr><th>类型别名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="crypto/x509/./x509_package_api/x509_package_type.html#type-ip">IP</a></td><td>x509 用 Array&lt;Byte&gt; 来记录 IP。</td></tr>
</tbody></table>
</div>
<h3 id="接口"><a class="header" href="#接口">接口</a></h3>
<div class="table-wrapper"><table><thead><tr><th>接口名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="crypto/x509/./x509_package_api/x509_package_interfaces.html#interface-dhparamters">DHParamters</a></td><td>提供 DH 密钥接口。</td></tr>
<tr><td><a href="crypto/x509/./x509_package_api/x509_package_interfaces.html#interface-key">Key</a></td><td>提供密钥接口。</td></tr>
<tr><td><a href="crypto/x509/./x509_package_api/x509_package_interfaces.html#interface-privateKey">PrivateKey</a></td><td>提供私钥接口。</td></tr>
<tr><td><a href="crypto/x509/./x509_package_api/x509_package_interfaces.html#interface-publicKey">PublicKey</a></td><td>提供公钥接口。</td></tr>
</tbody></table>
</div>
<h3 id="类-8"><a class="header" href="#类-8">类</a></h3>
<div class="table-wrapper"><table><thead><tr><th>类名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="crypto/x509/./x509_package_api/x509_package_classes.html#class-x509certificate">X509Certificate</a></td><td>X509 数字证书是一种用于加密通信的数字证书。</td></tr>
<tr><td><a href="crypto/x509/./x509_package_api/x509_package_classes.html#class-x509certificaterequest">X509CertificateRequest</a></td><td>数字证书签名请求。</td></tr>
<tr><td><a href="crypto/x509/./x509_package_api/x509_package_classes.html#class-X509name">X509Name</a></td><td>证书实体可辨识名称。</td></tr>
</tbody></table>
</div>
<h3 id="枚举-4"><a class="header" href="#枚举-4">枚举</a></h3>
<div class="table-wrapper"><table><thead><tr><th>枚举名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="crypto/x509/./x509_package_api/x509_package_enums.html#enum-publicKeyalgorithm">PublicKeyAlgorithm</a></td><td>数字证书中包含的公钥信息。</td></tr>
<tr><td><a href="crypto/x509/./x509_package_api/x509_package_enums.html#enum-signaturealgorithm">SignatureAlgorithm</a></td><td>证书签名算法。</td></tr>
</tbody></table>
</div>
<h3 id="结构体-6"><a class="header" href="#结构体-6">结构体</a></h3>
<div class="table-wrapper"><table><thead><tr><th>结构体名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="crypto/x509/./x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a></td><td>Crypto 支持配置二进制证书流。</td></tr>
<tr><td><a href="crypto/x509/./x509_package_api/x509_package_structs.html#struct-extkeyusage">ExtKeyUsage</a></td><td>数字证书扩展字段。</td></tr>
<tr><td><a href="crypto/x509/./x509_package_api/x509_package_structs.html#struct-keyusage">KeyUsage</a></td><td>数字证书扩展字段中通常会包含携带公钥的用法说明。</td></tr>
<tr><td><a href="crypto/x509/./x509_package_api/x509_package_structs.html#struct-pem">Pem</a></td><td>Pem 结构体。</td></tr>
<tr><td><a href="crypto/x509/./x509_package_api/x509_package_structs.html#struct-pementry">PemEntry</a></td><td>PEM 文本格式。</td></tr>
<tr><td><a href="crypto/x509/./x509_package_api/x509_package_structs.html#struct-serialnumber">SerialNumber</a></td><td>数字证书的序列号。</td></tr>
<tr><td><a href="crypto/x509/./x509_package_api/x509_package_structs.html#struct-signature">Signature</a></td><td>数字证书的签名。</td></tr>
<tr><td><a href="crypto/x509/./x509_package_api/x509_package_structs.html#struct-verifyoption">VerifyOption</a></td><td>校验选项。</td></tr>
<tr><td><a href="crypto/x509/./x509_package_api/x509_package_structs.html#struct-x509certificateinfo">X509CertificateInfo</a></td><td>证书信息。</td></tr>
<tr><td><a href="crypto/x509/./x509_package_api/x509_package_structs.html#struct-X509certificaterequestinfo">X509CertificateRequestInfo</a></td><td>证书请求信息。</td></tr>
</tbody></table>
</div>
<h3 id="异常类-6"><a class="header" href="#异常类-6">异常类</a></h3>
<div class="table-wrapper"><table><thead><tr><th>异常类名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="crypto/x509/./x509_package_api/x509_package_exceptions.html#class-x509exception">X509Exception</a></td><td><code>x509</code> 包的异常类。</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="类型别名-1"><a class="header" href="#类型别名-1">类型别名</a></h1>
<h2 id="type-ip"><a class="header" href="#type-ip">type IP</a></h2>
<pre><code class="language-cangjie">public type IP = Array&lt;Byte&gt;
</code></pre>
<p>功能：x509包用 Array&lt;Byte&gt; 来记录 <a href="crypto/x509/x509_package_api/x509_package_type.html#type-ip">IP</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="接口-1"><a class="header" href="#接口-1">接口</a></h1>
<h2 id="interface-dhparamters"><a class="header" href="#interface-dhparamters">interface DHParamters</a></h2>
<pre><code class="language-cangjie">public interface DHParamters &lt;: Key {
    override func encodeToPem(): PemEntry
    static func decodeDer(blob: DerBlob): DHParamters
    static func decodeFromPem(text: String): DHParamters
}
</code></pre>
<p>功能：提供 DH 参数接口。</p>
<p>父类型：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/x509_package_interfaces.html#interface-key">Key</a></li>
</ul>
<h3 id="static-func-decodederderblob-6"><a class="header" href="#static-func-decodederderblob-6">static func decodeDer(DerBlob)</a></h3>
<pre><code class="language-cangjie">static func decodeDer(blob: DerBlob): DHParamters
</code></pre>
<p>功能：将 DH 密钥参数从 DER 格式解码。</p>
<blockquote>
<p><strong>说明：</strong></p>
<ul>
<li>DH（Diffie-Hellman）密钥交换协议是一种确保共享KEY安全穿越不安全网络的方法。</li>
<li>DER 和 PEM 是两种常见的编码格式。</li>
</ul>
</blockquote>
<p>参数：</p>
<ul>
<li>blob: <a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a> - DER 格式的 DH 密钥参数对象。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/x509_package_interfaces.html#interface-dhparamters">DHParamters</a> - 由 DER 格式解码出的 DH 密钥参数。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/./x509_package_exceptions.html#class-x509exception">X509Exception</a> - 当 DER 格式的 DH 密钥参数内容不正确，无法解析时抛出异常。</li>
</ul>
<h3 id="static-func-decodefrompemstring-6"><a class="header" href="#static-func-decodefrompemstring-6">static func decodeFromPem(String)</a></h3>
<pre><code class="language-cangjie">static func decodeFromPem(text: String): DHParamters
</code></pre>
<p>功能：将 DH 密钥参数从 PEM 格式解码。</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>PEM 是用 ASCLL（BASE64）编码的证书。</p>
</blockquote>
<p>参数：</p>
<ul>
<li>text: String - PEM 格式的 DH 密钥参数字符流。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/x509_package_interfaces.html#interface-dhparamters">DHParamters</a> - 由 PEM 格式解码出的 DH 密钥参数。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/./x509_package_exceptions.html#class-x509exception">X509Exception</a> - 字符流不符合 PEM 格式时，或文件头不符合 DH 密钥参数头标准 (&quot;-----BEGIN DH PARAMETERS-----&quot;)时抛出异常。</li>
</ul>
<h3 id="func-encodetopem-6"><a class="header" href="#func-encodetopem-6">func encodeToPem()</a></h3>
<pre><code class="language-cangjie">override func encodeToPem(): PemEntry
</code></pre>
<p>功能：将 DH 密钥参数编码为 PEM 格式。</p>
<p>返回值：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-pementry">PemEntry</a> - DH 密钥参数数据 PEM 格式编码生成的对象。</li>
</ul>
<h2 id="interface-key"><a class="header" href="#interface-key">interface Key</a></h2>
<pre><code class="language-cangjie">public interface Key &lt;: ToString {
    func encodeToDer(): DerBlob
    func encodeToPem(): PemEntry
    static func decodeDer(encoded: DerBlob): Key
    static func decodeFromPem(text: String): Key
}
</code></pre>
<p>功能：提供密钥接口。 公钥用于签名验证或加密，私钥用于签名或解密，公钥和私钥必须相互匹配并形成一对。 该类为密钥类，无具体实现，供 <a href="crypto/x509/x509_package_api/x509_package_interfaces.html#interface-privatekey">PrivateKey</a>/<a href="crypto/x509/x509_package_api/x509_package_interfaces.html#interface-publickey">PublicKey</a> 及用户扩展接口。</p>
<p>父类型：</p>
<ul>
<li>ToString</li>
</ul>
<h3 id="static-func-decodederderblob-7"><a class="header" href="#static-func-decodederderblob-7">static func decodeDer(DerBlob)</a></h3>
<pre><code class="language-cangjie">static func decodeDer(encoded: DerBlob): Key
</code></pre>
<p>功能：将密钥从 DER 格式解码。</p>
<p>参数：</p>
<ul>
<li>encoded: <a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a> - DER 格式的对象。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/x509_package_interfaces.html#interface-key">Key</a> - 由 DER 格式解码出的密钥。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/./x509_package_exceptions.html#class-x509exception">X509Exception</a> - 当 DER 格式的私钥内容不正确，无法解析时抛出异常。</li>
</ul>
<h3 id="static-func-decodefrompemstring-7"><a class="header" href="#static-func-decodefrompemstring-7">static func decodeFromPem(String)</a></h3>
<pre><code class="language-cangjie">static func decodeFromPem(text: String): Key
</code></pre>
<p>功能：将密钥从 PEM 格式解码。</p>
<p>参数：</p>
<ul>
<li>text: String - PEM 格式的字符流。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/x509_package_interfaces.html#interface-key">Key</a> - 由 PEM 格式解码出的密钥。</li>
</ul>
<h3 id="func-encodetoder-6"><a class="header" href="#func-encodetoder-6">func encodeToDer()</a></h3>
<pre><code class="language-cangjie">func encodeToDer(): DerBlob
</code></pre>
<p>功能：将密钥编码为 DER 格式。</p>
<p>返回值：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a> - 密钥数据 DER 格式编码生成的对象。</li>
</ul>
<h3 id="func-encodetopem-7"><a class="header" href="#func-encodetopem-7">func encodeToPem()</a></h3>
<pre><code class="language-cangjie">func encodeToPem(): PemEntry
</code></pre>
<p>功能：将密钥编码为 PEM 格式。</p>
<p>返回值：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-pementry">PemEntry</a> - 密钥数据 PEM 格式编码生成的对象。</li>
</ul>
<h2 id="interface-privatekey"><a class="header" href="#interface-privatekey">interface PrivateKey</a></h2>
<pre><code class="language-cangjie">public interface PrivateKey &lt;: Key {
    static func decodeDer(blob: DerBlob): PrivateKey
    static func decodeFromPem(text: String): PrivateKey
    static func decodeDer(blob: DerBlob, password!: ?String): PrivateKey
    static func decodeFromPem(text: String, password!: ?String): PrivateKey
    func encodeToDer(password!: ?String): DerBlob
    override func encodeToPem(): PemEntry
    func encodeToPem(password!: ?String): PemEntry
}
</code></pre>
<p>功能：提供私钥接口。</p>
<p>父类型：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/x509_package_interfaces.html#interface-key">Key</a></li>
</ul>
<h3 id="static-func-decodederderblob-8"><a class="header" href="#static-func-decodederderblob-8">static func decodeDer(DerBlob)</a></h3>
<pre><code class="language-cangjie">static func decodeDer(blob: DerBlob): PrivateKey
</code></pre>
<p>功能：将私钥从 DER 格式解码。</p>
<p>参数：</p>
<ul>
<li>blob: <a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a> - DER 格式的私钥对象。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/x509_package_interfaces.html#interface-privatekey">PrivateKey</a> - 由 DER 格式解码出的私钥。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/./x509_package_exceptions.html#class-x509exception">X509Exception</a> - 当 DER 格式的私钥内容不正确，无法解析时抛出异常。</li>
</ul>
<h3 id="static-func-decodederderblob-string-3"><a class="header" href="#static-func-decodederderblob-string-3">static func decodeDer(DerBlob, ?String)</a></h3>
<pre><code class="language-cangjie">static func decodeDer(blob: DerBlob, password!: ?String): PrivateKey 
</code></pre>
<p>功能：将 DER 格式的私钥解密解码成 <a href="crypto/x509/x509_package_api/x509_package_interfaces.html#interface-privatekey">PrivateKey</a> 对象，密码为 None 时则不解密。</p>
<p>参数：</p>
<ul>
<li>blob: <a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a> - DER 格式的私钥。</li>
<li>password!: ?String - 解密密码。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/x509_package_interfaces.html#interface-privatekey">PrivateKey</a> - 解密解码后的私钥对象。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/./x509_package_exceptions.html#class-x509exception">X509Exception</a> - 解密解码失败，或者 <code>password</code> 为空字符串。</li>
</ul>
<h3 id="static-func-decodefrompemstring-8"><a class="header" href="#static-func-decodefrompemstring-8">static func decodeFromPem(String)</a></h3>
<pre><code class="language-cangjie">static func decodeFromPem(text: String): PrivateKey
</code></pre>
<p>功能：将私钥从 PEM 格式解码。</p>
<p>参数：</p>
<ul>
<li>text: String - PEM 格式的私钥字符流。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/x509_package_interfaces.html#interface-privatekey">PrivateKey</a> - 由 PEM 格式解码出的私钥。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/./x509_package_exceptions.html#class-x509exception">X509Exception</a> - 字符流不符合 PEM 格式时，或文件头不符合公钥头标准时抛出异常。</li>
</ul>
<h3 id="static-func-decodefrompemstring-string-3"><a class="header" href="#static-func-decodefrompemstring-string-3">static func decodeFromPem(String, ?String)</a></h3>
<pre><code class="language-cangjie">static func decodeFromPem(text: String, password!: ?String): PrivateKey 
</code></pre>
<p>功能：将 PEM 格式的私钥解密解码成 <a href="crypto/x509/x509_package_api/x509_package_interfaces.html#interface-privatekey">PrivateKey</a> 对象，密码为 None 时则不解密。</p>
<p>参数：</p>
<ul>
<li>text: String - PEM 格式的私钥。</li>
<li>password!: ?String - 解密密码。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/x509_package_interfaces.html#interface-privatekey">PrivateKey</a> - 解密解码后的私钥对象。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/./x509_package_exceptions.html#class-x509exception">X509Exception</a> - 解密解码失败，或者 <code>password</code> 为空字符串。</li>
</ul>
<h3 id="func-encodetoderstring-3"><a class="header" href="#func-encodetoderstring-3">func encodeToDer(?String)</a></h3>
<pre><code class="language-cangjie">func encodeToDer(password!: ?String): DerBlob
</code></pre>
<p>功能：将私钥加密编码成 DER 格式，密码为 None 时则不加密。</p>
<p>参数：</p>
<ul>
<li>password!: ?String - 加密密码。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a> - 加密后的 DER 格式的私钥。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/./x509_package_exceptions.html#class-x509exception">X509Exception</a> - 加密失败，或者 <code>password</code> 为空字符串。</li>
</ul>
<h3 id="func-encodetopem-8"><a class="header" href="#func-encodetopem-8">func encodeToPem()</a></h3>
<pre><code class="language-cangjie">override func encodeToPem(): PemEntry
</code></pre>
<p>功能：将私钥编码成 PEM 格式。</p>
<p>返回值：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-pementry">PemEntry</a> - 编码后的 PEM 格式的私钥。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/./x509_package_exceptions.html#class-x509exception">X509Exception</a> - 编码失败。</li>
</ul>
<h3 id="func-encodetopemstring-1"><a class="header" href="#func-encodetopemstring-1">func encodeToPem(?String)</a></h3>
<pre><code class="language-cangjie">func encodeToPem(password!: ?String): PemEntry
</code></pre>
<p>功能：将私钥加密编码成 PEM 格式，密码为 None 时则不加密。</p>
<p>参数：</p>
<ul>
<li>password!: ?String - 加密密码。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-pementry">PemEntry</a> - 加密后的 PEM 格式的私钥。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/./x509_package_exceptions.html#class-x509exception">X509Exception</a> - 加密失败，或者 <code>password</code> 为空字符串。</li>
</ul>
<h2 id="interface-publickey"><a class="header" href="#interface-publickey">interface PublicKey</a></h2>
<pre><code class="language-cangjie">public interface PublicKey &lt;: Key {
    override func encodeToPem(): PemEntry
    static func decodeDer(blob: DerBlob): PublicKey
    static func decodeFromPem(text: String): PublicKey
}
</code></pre>
<p>功能：公钥接口。</p>
<p>父类型：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/x509_package_interfaces.html#interface-key">Key</a></li>
</ul>
<h3 id="static-func-decodederderblob-9"><a class="header" href="#static-func-decodederderblob-9">static func decodeDer(DerBlob)</a></h3>
<pre><code class="language-cangjie">static func decodeDer(blob: DerBlob): PublicKey
</code></pre>
<p>功能：将公钥从 DER 格式解码。</p>
<p>参数：</p>
<ul>
<li>blob: <a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a> - DER 格式的公钥对象。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/x509_package_interfaces.html#interface-publickey">PublicKey</a> - 由 DER 格式解码出的公钥。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/./x509_package_exceptions.html#class-x509exception">X509Exception</a> - 当 DER 格式的公钥内容不正确，无法解析时抛出异常。</li>
</ul>
<h3 id="static-func-decodefrompemstring-9"><a class="header" href="#static-func-decodefrompemstring-9">static func decodeFromPem(String)</a></h3>
<pre><code class="language-cangjie">static func decodeFromPem(text: String): PublicKey
</code></pre>
<p>功能：将公钥从 PEM 格式解码。</p>
<p>参数：</p>
<ul>
<li>text: String - PEM 格式的公钥字符流。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/x509_package_interfaces.html#interface-publickey">PublicKey</a> - 由 PEM 格式解码出的公钥。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/./x509_package_exceptions.html#class-x509exception">X509Exception</a> - 字符流不符合 PEM 格式时，或文件头不符合公钥头标准时抛出异常。</li>
</ul>
<h3 id="func-encodetopem-9"><a class="header" href="#func-encodetopem-9">func encodeToPem()</a></h3>
<pre><code class="language-cangjie">override func encodeToPem(): PemEntry
</code></pre>
<p>功能：将公钥编码为 PEM 格式。</p>
<p>返回值：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-pementry">PemEntry</a> - 公钥数据 PEM 格式编码生成的对象。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="x509-包"><a class="header" href="#x509-包">x509 包</a></h1>
<h2 id="class-x509certificate"><a class="header" href="#class-x509certificate">class X509Certificate</a></h2>
<pre><code class="language-cangjie">public class X509Certificate &lt;: Equatable&lt;X509Certificate&gt; &amp; Hashable &amp; ToString {
    public init(
        certificateInfo: X509CertificateInfo,
        parent!: X509Certificate,
        publicKey!: PublicKey,
        privateKey!: PrivateKey,
        signatureAlgorithm!: ?SignatureAlgorithm = None
    )
}
</code></pre>
<p>功能：X509 数字证书是一种用于加密通信的数字证书，它是公钥基础设施（PKI）的核心组件之一。X509 数字证书包含了一个实体的公钥和身份信息，用于验证该实体的身份和确保通信的安全性。</p>
<p>父类型：</p>
<ul>
<li>Equatable&lt;<a href="crypto/x509/x509_package_api/x509_package_classes.html#class-x509certificate">X509Certificate</a>&gt;</li>
<li>Hashable</li>
<li>ToString</li>
</ul>
<h3 id="prop-dnsnames"><a class="header" href="#prop-dnsnames">prop dnsNames</a></h3>
<pre><code class="language-cangjie">public prop dnsNames: Array&lt;String&gt;
</code></pre>
<p>功能：解析数字证书备选名称中的域名。</p>
<p>类型：Array&lt;String&gt;</p>
<h3 id="prop-emailaddresses"><a class="header" href="#prop-emailaddresses">prop emailAddresses</a></h3>
<pre><code class="language-cangjie">public prop emailAddresses: Array&lt;String&gt;
</code></pre>
<p>功能：解析数字证书备选名称中的 email 地址。</p>
<p>类型：Array&lt;String&gt;</p>
<h3 id="prop-extkeyusage"><a class="header" href="#prop-extkeyusage">prop extKeyUsage</a></h3>
<pre><code class="language-cangjie">public prop extKeyUsage: ExtKeyUsage
</code></pre>
<p>功能：解析数字证书中的扩展密钥用法。</p>
<p>类型：<a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-extkeyusage">ExtKeyUsage</a></p>
<h3 id="prop-issuer"><a class="header" href="#prop-issuer">prop issuer</a></h3>
<pre><code class="language-cangjie">public prop issuer: X509Name
</code></pre>
<p>功能：解析数字证书的颁发者信息。</p>
<p>类型：<a href="crypto/x509/x509_package_api/x509_package_classes.html#class-x509name">X509Name</a></p>
<h3 id="prop-ipaddresses"><a class="header" href="#prop-ipaddresses">prop IPAddresses</a></h3>
<pre><code class="language-cangjie">public prop IPAddresses: Array&lt;IP&gt;
</code></pre>
<p>功能：解析数字证书备选名称中的 <a href="crypto/x509/x509_package_api/x509_package_type.html#type-ip">IP</a> 地址。</p>
<p>类型：Array&lt;<a href="crypto/x509/x509_package_api/x509_package_type.html#type-ip">IP</a>&gt;</p>
<h3 id="prop-keyusage"><a class="header" href="#prop-keyusage">prop keyUsage</a></h3>
<pre><code class="language-cangjie">public prop keyUsage: KeyUsage
</code></pre>
<p>功能：解析数字证书中的密钥用法。</p>
<p>类型：<a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-keyusage">KeyUsage</a></p>
<h3 id="prop-notafter"><a class="header" href="#prop-notafter">prop notAfter</a></h3>
<pre><code class="language-cangjie">public prop notAfter: DateTime
</code></pre>
<p>功能：解析数字证书的有效期截止时间。</p>
<p>类型：DateTime</p>
<h3 id="prop-notbefore"><a class="header" href="#prop-notbefore">prop notBefore</a></h3>
<pre><code class="language-cangjie">public prop notBefore: DateTime
</code></pre>
<p>功能：解析数字证书的有效期开始时间。</p>
<p>类型：DateTime</p>
<h3 id="prop-publickey"><a class="header" href="#prop-publickey">prop publicKey</a></h3>
<pre><code class="language-cangjie">public prop publicKey: PublicKey
</code></pre>
<p>功能：解析数字证书的公钥。</p>
<p>类型：<a href="crypto/x509/x509_package_api/x509_package_interfaces.html#interface-publickey">PublicKey</a></p>
<h3 id="prop-publickeyalgorithm"><a class="header" href="#prop-publickeyalgorithm">prop publicKeyAlgorithm</a></h3>
<pre><code class="language-cangjie">public prop publicKeyAlgorithm: PublicKeyAlgorithm
</code></pre>
<p>功能：解析数字证书的公钥算法。</p>
<p>类型：<a href="crypto/x509/x509_package_api/x509_package_enums.html#enum-publickeyalgorithm">PublicKeyAlgorithm</a></p>
<h3 id="prop-serialnumber"><a class="header" href="#prop-serialnumber">prop serialNumber</a></h3>
<pre><code class="language-cangjie">public prop serialNumber: SerialNumber
</code></pre>
<p>功能：解析数字证书的序列号。</p>
<p>类型：<a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-serialnumber">SerialNumber</a></p>
<h3 id="prop-signature"><a class="header" href="#prop-signature">prop signature</a></h3>
<pre><code class="language-cangjie">public prop signature: Signature
</code></pre>
<p>功能：解析数字证书的签名。</p>
<p>类型：<a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-signature">Signature</a></p>
<h3 id="prop-signaturealgorithm"><a class="header" href="#prop-signaturealgorithm">prop signatureAlgorithm</a></h3>
<pre><code class="language-cangjie">public prop signatureAlgorithm: SignatureAlgorithm
</code></pre>
<p>功能：解析数字证书的签名算法。</p>
<p>类型：<a href="crypto/x509/x509_package_api/./x509_package_enums.html#enum-signaturealgorithm">SignatureAlgorithm</a></p>
<h3 id="prop-subject"><a class="header" href="#prop-subject">prop subject</a></h3>
<pre><code class="language-cangjie">public prop subject: X509Name
</code></pre>
<p>功能：解析数字证书的使用者信息。</p>
<p>类型：<a href="crypto/x509/x509_package_api/x509_package_classes.html#class-x509name">X509Name</a></p>
<h3 id="initx509certificateinfo-x509certificate-publickey-privatekey-signaturealgorithm"><a class="header" href="#initx509certificateinfo-x509certificate-publickey-privatekey-signaturealgorithm">init(X509CertificateInfo, X509Certificate, PublicKey, PrivateKey, ?SignatureAlgorithm)</a></h3>
<pre><code class="language-cangjie">public init(
    certificateInfo: X509CertificateInfo,
    parent!: X509Certificate,
    publicKey!: PublicKey,
    privateKey!: PrivateKey,
    signatureAlgorithm!: ?SignatureAlgorithm = None
)
</code></pre>
<p>功能：创建数字证书对象。</p>
<p>参数：</p>
<ul>
<li>certificateInfo: <a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-x509certificateinfo">X509CertificateInfo</a> - 数字证书配置信息。</li>
<li>parent!: <a href="crypto/x509/x509_package_api/x509_package_classes.html#class-x509certificate">X509Certificate</a> - 颁发者证书。</li>
<li>publicKey!: <a href="crypto/x509/x509_package_api/x509_package_interfaces.html#interface-publickey">PublicKey</a> - 申请人公钥，仅支持 RSA、ECDSA 和 DSA 公钥。</li>
<li>privateKey!: <a href="crypto/x509/x509_package_api/x509_package_interfaces.html#interface-privatekey">PrivateKey</a> - 颁发者私钥，仅支持 RSA、ECDSA 和 DSA 私钥。</li>
<li>signatureAlgorithm!: ?<a href="crypto/x509/x509_package_api/./x509_package_enums.html#enum-signaturealgorithm">SignatureAlgorithm</a> - 证书签名算法，默认值为 None，使用默认值时默认的摘要类型是 <a href="crypto/x509/x509_package_api/../../digest/digest_package_api/digest_package_classes.html#class-sha256">SHA256</a>。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/./x509_package_exceptions.html#class-x509exception">X509Exception</a> - 公钥或私钥类型不支持、私钥类型和证书签名算法中的私钥类型不匹配或数字证书信息设置失败时，抛出异常。</li>
</ul>
<h3 id="static-func-decodefromderderblob"><a class="header" href="#static-func-decodefromderderblob">static func decodeFromDer(DerBlob)</a></h3>
<pre><code class="language-cangjie">public static func decodeFromDer(der: DerBlob): X509Certificate
</code></pre>
<p>功能：将 DER 格式的数字证书解码。</p>
<p>参数：</p>
<ul>
<li>der: <a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a> - DER 格式的二进制数据。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/x509_package_classes.html#class-x509certificate">X509Certificate</a> - 由 DER 格式解码出的数字证书。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/./x509_package_exceptions.html#class-x509exception">X509Exception</a> - 数据为空时，或数据不是有效的数字证书 DER 格式时抛出异常。</li>
</ul>
<h3 id="static-func-decodefrompemstring-10"><a class="header" href="#static-func-decodefrompemstring-10">static func decodeFromPem(String)</a></h3>
<pre><code class="language-cangjie">public static func decodeFromPem(pem: String): Array&lt;X509Certificate&gt;
</code></pre>
<p>功能：将数字证书从 PEM 格式解码。</p>
<p>参数：</p>
<ul>
<li>pem: String - PEM 格式的数字证书字符流。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Array&lt;<a href="crypto/x509/x509_package_api/x509_package_classes.html#class-x509certificate">X509Certificate</a>&gt; - 由 PEM 格式解码出的数字证书数组。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/./x509_package_exceptions.html#class-x509exception">X509Exception</a> - 字符流不符合 PEM 格式时，或文件头不符合数字证书头标准时抛出异常。</li>
</ul>
<h3 id="func-encodetoder-7"><a class="header" href="#func-encodetoder-7">func encodeToDer()</a></h3>
<pre><code class="language-cangjie">public func encodeToDer(): DerBlob
</code></pre>
<p>功能：将数字证书编码成 Der 格式。</p>
<p>返回值：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a> - 编码后的 Der 格式的数字证书。</li>
</ul>
<h3 id="func-encodetopem-10"><a class="header" href="#func-encodetopem-10">func encodeToPem()</a></h3>
<pre><code class="language-cangjie">public func encodeToPem(): PemEntry
</code></pre>
<p>功能：将数字证书编码成 PEM 格式。</p>
<p>返回值：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-pementry">PemEntry</a> - 编码后的 PEM 格式的数字证书。</li>
</ul>
<h3 id="func-hashcode"><a class="header" href="#func-hashcode">func hashCode()</a></h3>
<pre><code class="language-cangjie">public override func hashCode(): Int64
</code></pre>
<p>功能：返回证书哈希值。</p>
<p>返回值：</p>
<ul>
<li>Int64 - 对证书对象进行哈希计算后得到的结果。</li>
</ul>
<h3 id="static-func-systemrootcerts"><a class="header" href="#static-func-systemrootcerts">static func systemRootCerts()</a></h3>
<pre><code class="language-cangjie">public static func systemRootCerts(): Array&lt;X509Certificate&gt;
</code></pre>
<p>功能：返回操作系统的根证书，支持 Linux，MacOS 和 Windows 平台。</p>
<p>返回值：</p>
<ul>
<li>Array&lt;<a href="crypto/x509/x509_package_api/x509_package_classes.html#class-x509certificate">X509Certificate</a>&gt; - 操作系统的根证书链。</li>
</ul>
<h3 id="func-tostring-8"><a class="header" href="#func-tostring-8">func toString()</a></h3>
<pre><code class="language-cangjie">public override func toString(): String
</code></pre>
<p>功能：生成证书名称字符串，包含证书的使用者信息、有效期以及颁发者信息。</p>
<p>返回值：</p>
<ul>
<li>String - 证书名称字符串。</li>
</ul>
<h3 id="func-verifyverifyoption"><a class="header" href="#func-verifyverifyoption">func verify(VerifyOption)</a></h3>
<pre><code class="language-cangjie">public func verify(verifyOption: VerifyOption): Bool
</code></pre>
<p>功能：根据验证选项验证当前证书的有效性。</p>
<p>验证优先级：</p>
<ol>
<li>优先验证有效期；</li>
<li>可选验证 DNS 域名；</li>
<li>最后根据根证书和中间证书验证其有效性。</li>
</ol>
<p>参数：</p>
<ul>
<li>verifyOption: <a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-verifyoption">VerifyOption</a> - 证书验证选项。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - 证书有效返回 true，否则返回 false。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/./x509_package_exceptions.html#class-x509exception">X509Exception</a> - 检验过程中失败，比如内存分配异常等内部错误，则抛出异常。</li>
</ul>
<h3 id="operator-func-x509certificate"><a class="header" href="#operator-func-x509certificate">operator func !=(X509Certificate)</a></h3>
<pre><code class="language-cangjie">public override operator func !=(other: X509Certificate): Bool
</code></pre>
<p>功能：判不等。</p>
<p>参数：</p>
<ul>
<li>other: <a href="crypto/x509/x509_package_api/x509_package_classes.html#class-x509certificate">X509Certificate</a> - 被比较的证书对象。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - 若证书不同，返回 true；否则，返回 false。</li>
</ul>
<h3 id="operator-func-x509certificate-1"><a class="header" href="#operator-func-x509certificate-1">operator func ==(X509Certificate)</a></h3>
<pre><code class="language-cangjie">public override operator func ==(other: X509Certificate): Bool
</code></pre>
<p>功能：判等。</p>
<p>参数：</p>
<ul>
<li>other: <a href="crypto/x509/x509_package_api/x509_package_classes.html#class-x509certificate">X509Certificate</a> - 被比较的证书对象。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - 若证书相同，返回 true；否则，返回 false。</li>
</ul>
<h2 id="class-x509certificaterequest"><a class="header" href="#class-x509certificaterequest">class X509CertificateRequest</a></h2>
<pre><code class="language-cangjie">public class X509CertificateRequest &lt;: Hashable &amp; ToString {
    public init(
        privateKey: PrivateKey,
        certificateRequestInfo!: ?X509CertificateRequestInfo = None,
        signatureAlgorithm!: ?SignatureAlgorithm = None
    )
}
</code></pre>
<p>功能：数字证书签名请求。</p>
<p>父类型：</p>
<ul>
<li>Hashable</li>
<li>ToString</li>
</ul>
<h3 id="prop-ipaddresses-1"><a class="header" href="#prop-ipaddresses-1">prop IPAddresses</a></h3>
<pre><code class="language-cangjie">public prop IPAddresses: Array&lt;IP&gt;
</code></pre>
<p>功能：解析数字证书签名请求备选名称中的 <a href="crypto/x509/x509_package_api/x509_package_type.html#type-ip">IP</a> 地址。</p>
<p>类型：Array&lt;<a href="crypto/x509/x509_package_api/x509_package_type.html#type-ip">IP</a>&gt;</p>
<h3 id="prop-dnsnames-1"><a class="header" href="#prop-dnsnames-1">prop dnsNames</a></h3>
<pre><code class="language-cangjie">public prop dnsNames: Array&lt;String&gt;
</code></pre>
<p>功能：解析数字证书签名请求备选名称中的域名。</p>
<p>类型：Array&lt;String&gt;</p>
<h3 id="prop-emailaddresses-1"><a class="header" href="#prop-emailaddresses-1">prop emailAddresses</a></h3>
<pre><code class="language-cangjie">public prop emailAddresses: Array&lt;String&gt;
</code></pre>
<p>功能：解析数字证书签名请求备选名称中的 email 地址。</p>
<p>类型：Array&lt;String&gt;</p>
<h3 id="prop-publickey-1"><a class="header" href="#prop-publickey-1">prop publicKey</a></h3>
<pre><code class="language-cangjie">public prop publicKey: PublicKey
</code></pre>
<p>功能：解析数字证书签名请求的公钥。</p>
<p>类型：<a href="crypto/x509/x509_package_api/x509_package_interfaces.html#interface-publickey">PublicKey</a></p>
<h3 id="prop-publickeyalgorithm-1"><a class="header" href="#prop-publickeyalgorithm-1">prop publicKeyAlgorithm</a></h3>
<pre><code class="language-cangjie">public prop publicKeyAlgorithm: PublicKeyAlgorithm
</code></pre>
<p>功能：解析数字证书签名请求的公钥算法。</p>
<p>类型：<a href="crypto/x509/x509_package_api/x509_package_enums.html#enum-publickeyalgorithm">PublicKeyAlgorithm</a></p>
<h3 id="prop-signature-1"><a class="header" href="#prop-signature-1">prop signature</a></h3>
<pre><code class="language-cangjie">public prop signature: Signature
</code></pre>
<p>功能：解析数字证书签名请求的签名。</p>
<p>类型：<a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-signature">Signature</a></p>
<h3 id="prop-signaturealgorithm-1"><a class="header" href="#prop-signaturealgorithm-1">prop signatureAlgorithm</a></h3>
<pre><code class="language-cangjie">public prop signatureAlgorithm: SignatureAlgorithm
</code></pre>
<p>功能：解析数字证书签名请求的签名算法。</p>
<p>类型：<a href="crypto/x509/x509_package_api/./x509_package_enums.html#enum-signaturealgorithm">SignatureAlgorithm</a></p>
<h3 id="prop-subject-1"><a class="header" href="#prop-subject-1">prop subject</a></h3>
<pre><code class="language-cangjie">public prop subject: X509Name
</code></pre>
<p>功能：解析数字证书签名请求的使用者信息。</p>
<p>类型：<a href="crypto/x509/x509_package_api/x509_package_classes.html#class-x509name">X509Name</a></p>
<h3 id="initprivatekey-x509certificaterequestinfo-signaturealgorithm"><a class="header" href="#initprivatekey-x509certificaterequestinfo-signaturealgorithm">init(PrivateKey, ?X509CertificateRequestInfo, ?SignatureAlgorithm)</a></h3>
<pre><code class="language-cangjie">public init(
    privateKey: PrivateKey,
    certificateRequestInfo!: ?X509CertificateRequestInfo = None,
    signatureAlgorithm!: ?SignatureAlgorithm = None
)
</code></pre>
<p>功能：创建数字证书签名请求对象。</p>
<p>参数：</p>
<ul>
<li>privateKey: <a href="crypto/x509/x509_package_api/x509_package_interfaces.html#interface-privatekey">PrivateKey</a> - 私钥，仅支持 RSA、ECDSA 和 DSA 私钥。</li>
<li>certificateRequestInfo!: ?<a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-x509certificaterequestinfo">X509CertificateRequestInfo</a> - 数字证书签名信息，默认值为 None。</li>
<li>signatureAlgorithm!: ?<a href="crypto/x509/x509_package_api/./x509_package_enums.html#enum-signaturealgorithm">SignatureAlgorithm</a> - 证书签名算法，默认值为 None，使用默认值时默认的摘要类型是 <a href="crypto/x509/x509_package_api/../../digest/digest_package_api/digest_package_classes.html#class-sha256">SHA256</a>。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/./x509_package_exceptions.html#class-x509exception">X509Exception</a> - 私钥类型不支持、私钥类型和证书签名算法中的私钥类型不匹配或数字证书签名信息设置失败时，抛出异常。</li>
</ul>
<h3 id="static-func-decodefromderderblob-1"><a class="header" href="#static-func-decodefromderderblob-1">static func decodeFromDer(DerBlob)</a></h3>
<pre><code class="language-cangjie">public static func decodeFromDer(der: DerBlob): X509CertificateRequest
</code></pre>
<p>功能：将 DER 格式的数字证书签名请求解码。</p>
<p>参数：</p>
<ul>
<li>der: <a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a> - DER 格式的二进制数据。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/x509_package_classes.html#class-x509certificaterequest">X509CertificateRequest</a> - 由 DER 格式解码出的数字证书签名请求。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/./x509_package_exceptions.html#class-x509exception">X509Exception</a> - 数据为空时，或数据不是有效的数字证书签名请求 DER 格式时抛出异常。</li>
</ul>
<h3 id="static-func-decodefrompemstring-11"><a class="header" href="#static-func-decodefrompemstring-11">static func decodeFromPem(String)</a></h3>
<pre><code class="language-cangjie">public static func decodeFromPem(pem: String): Array&lt;X509CertificateRequest&gt;
</code></pre>
<p>功能：将数字证书签名请求从 PEM 格式解码。</p>
<p>参数：</p>
<ul>
<li>pem: String - PEM 格式的数字证书签名请求字符流。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Array&lt;<a href="crypto/x509/x509_package_api/x509_package_classes.html#class-x509certificaterequest">X509CertificateRequest</a>&gt; - 由 PEM 格式解码出的数字证书签名请求数组。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/./x509_package_exceptions.html#class-x509exception">X509Exception</a> - 字符流不符合 PEM 格式时，或文件头不符合数字证书签名请求头标准时抛出异常。</li>
</ul>
<h3 id="func-encodetoder-8"><a class="header" href="#func-encodetoder-8">func encodeToDer()</a></h3>
<pre><code class="language-cangjie">public func encodeToDer(): DerBlob
</code></pre>
<p>功能：将数字证书签名请求编码成 Der 格式。</p>
<p>返回值：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a> - 编码后的 Der 格式的数字证书签名请求。</li>
</ul>
<h3 id="func-encodetopem-11"><a class="header" href="#func-encodetopem-11">func encodeToPem()</a></h3>
<pre><code class="language-cangjie">public func encodeToPem(): PemEntry
</code></pre>
<p>功能：将数字证书签名请求编码成 PEM 格式。</p>
<p>返回值：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-pementry">PemEntry</a> - 编码后的 PEM 格式的数字证书签名请求。</li>
</ul>
<h3 id="func-hashcode-1"><a class="header" href="#func-hashcode-1">func hashCode()</a></h3>
<pre><code class="language-cangjie">public override func hashCode(): Int64
</code></pre>
<p>功能：返回证书签名请求哈希值。</p>
<p>返回值：</p>
<ul>
<li>Int64 - 对证书签名请求对象进行哈希计算后得到的结果。</li>
</ul>
<h3 id="func-tostring-9"><a class="header" href="#func-tostring-9">func toString()</a></h3>
<pre><code class="language-cangjie">public override func toString(): String
</code></pre>
<p>功能：生成证书签名请求名称字符串，包含证书签名请求的使用者信息。</p>
<p>返回值：</p>
<ul>
<li>String - 证书签名请求名称字符串。</li>
</ul>
<h2 id="class-x509name"><a class="header" href="#class-x509name">class X509Name</a></h2>
<pre><code class="language-cangjie">public class X509Name &lt;: ToString {
    public init(
        countryName!: ?String = None,
        provinceName!: ?String = None,
        localityName!: ?String = None,
        organizationName!: ?String = None,
        organizationalUnitName!: ?String = None,
        commonName!: ?String = None,
        email!: ?String = None
    )
}
</code></pre>
<p>功能：证书实体可辨识名称（Distinguished Name）是数字证书中的一个重要组成部分，作用是确保证书的持有者身份的真实性和可信度，同时也是数字证书验证的重要依据之一。</p>
<p><a href="crypto/x509/x509_package_api/x509_package_classes.html#class-x509name">X509Name</a> 通常包含证书实体的国家或地区名称（Country Name）、州或省名称（State or Province Name）、城市名称（Locality Name）、组织名称（Organization Name）、组织单位名称（Organizational Unit Name）、通用名称（Common Name）。有时也会包含 email 地址。</p>
<p>父类型：</p>
<ul>
<li>ToString</li>
</ul>
<h3 id="prop-commonname"><a class="header" href="#prop-commonname">prop commonName</a></h3>
<pre><code class="language-cangjie">public prop commonName: ?String
</code></pre>
<p>功能：返回证书实体的通用名称。</p>
<p>类型：?String</p>
<h3 id="prop-countryname"><a class="header" href="#prop-countryname">prop countryName</a></h3>
<pre><code class="language-cangjie">public prop countryName: ?String
</code></pre>
<p>功能：返回证书实体的国家或地区名称。</p>
<p>类型：?String</p>
<h3 id="prop-email"><a class="header" href="#prop-email">prop email</a></h3>
<pre><code class="language-cangjie">public prop email: ?String
</code></pre>
<p>功能：返回证书实体的 email 地址。</p>
<p>类型：?String</p>
<h3 id="prop-localityname"><a class="header" href="#prop-localityname">prop localityName</a></h3>
<pre><code class="language-cangjie">public prop localityName: ?String
</code></pre>
<p>功能：返回证书实体的城市名称。</p>
<p>类型：?String</p>
<h3 id="prop-organizationname"><a class="header" href="#prop-organizationname">prop organizationName</a></h3>
<pre><code class="language-cangjie">public prop organizationName: ?String
</code></pre>
<p>功能：返回证书实体的组织名称。</p>
<p>类型：?String</p>
<h3 id="prop-organizationalunitname"><a class="header" href="#prop-organizationalunitname">prop organizationalUnitName</a></h3>
<pre><code class="language-cangjie">public prop organizationalUnitName: ?String
</code></pre>
<p>功能：返回证书实体的组织单位名称。</p>
<p>类型：?String</p>
<h3 id="prop-provincename"><a class="header" href="#prop-provincename">prop provinceName</a></h3>
<pre><code class="language-cangjie">public prop provinceName: ?String
</code></pre>
<p>功能：返回证书实体的州或省名称。</p>
<p>类型：?String</p>
<h3 id="initstring-string-string-string-string-string-string"><a class="header" href="#initstring-string-string-string-string-string-string">init(?String, ?String, ?String, ?String, ?String, ?String, ?String)</a></h3>
<pre><code class="language-cangjie">    public init(
        countryName!: ?String = None,
        provinceName!: ?String = None,
        localityName!: ?String = None,
        organizationName!: ?String = None,
        organizationalUnitName!: ?String = None,
        commonName!: ?String = None,
        email!: ?String = None
    )
</code></pre>
<p>功能：构造 <a href="crypto/x509/x509_package_api/x509_package_classes.html#class-x509name">X509Name</a> 对象。</p>
<p>参数：</p>
<ul>
<li>countryName!: ?String - 国家或地区名称，默认值为 None。</li>
<li>provinceName!: ?String - 州或省名称，默认值为 None。</li>
<li>localityName!: ?String - 城市名称，默认值为 None。</li>
<li>organizationName!: ?String - 组织名称，默认值为 None。</li>
<li>organizationalUnitName!: ?String - 组织单位名称，默认值为 None。</li>
<li>commonName!: ?String - 通用名称，默认值为 None。</li>
<li>email!: ?String - email 地址，默认值为 None。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/./x509_package_exceptions.html#class-x509exception">X509Exception</a> - 设置证书实体可辨识名称时失败，比如内存分配异常等内部错误，则抛出异常。</li>
</ul>
<h3 id="func-tostring-10"><a class="header" href="#func-tostring-10">func toString()</a></h3>
<pre><code class="language-cangjie">public override func toString(): String
</code></pre>
<p>功能：生成证书实体名称字符串。</p>
<p>返回值：</p>
<ul>
<li>String - 证书实体名称字符串，包含实体名称中存在的字段信息。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="枚举-5"><a class="header" href="#枚举-5">枚举</a></h1>
<h2 id="enum-publickeyalgorithm"><a class="header" href="#enum-publickeyalgorithm">enum PublicKeyAlgorithm</a></h2>
<pre><code class="language-cangjie">public enum PublicKeyAlgorithm &lt;: Equatable&lt;PublicKeyAlgorithm&gt; &amp; ToString {
    RSA | DSA | ECDSA | UnknownPublicKeyAlgorithm
}
</code></pre>
<p>功能：数字证书中包含的公钥信息，目前支持的种类有：RSA、DSA、ECDSA。</p>
<p>父类型：</p>
<ul>
<li>Equatable&lt;<a href="crypto/x509/x509_package_api/x509_package_enums.html#enum-publickeyalgorithm">PublicKeyAlgorithm</a>&gt;</li>
<li>ToString</li>
</ul>
<h3 id="dsa"><a class="header" href="#dsa">DSA</a></h3>
<pre><code class="language-cangjie">DSA
</code></pre>
<p>功能：DSA 公钥算法。</p>
<h3 id="ecdsa"><a class="header" href="#ecdsa">ECDSA</a></h3>
<pre><code class="language-cangjie">ECDSA
</code></pre>
<p>功能：ECDSA 公钥算法。</p>
<h3 id="rsa"><a class="header" href="#rsa">RSA</a></h3>
<pre><code class="language-cangjie">RSA
</code></pre>
<p>功能：RSA 公钥算法。</p>
<h3 id="unknownpublickeyalgorithm"><a class="header" href="#unknownpublickeyalgorithm">UnknownPublicKeyAlgorithm</a></h3>
<pre><code class="language-cangjie">UnknownPublicKeyAlgorithm
</code></pre>
<p>功能：未知公钥算法。</p>
<h3 id="func-tostring-11"><a class="header" href="#func-tostring-11">func toString()</a></h3>
<pre><code class="language-cangjie">public override func toString(): String
</code></pre>
<p>功能：生成证书携带的公钥算法名称字符串。</p>
<p>返回值：</p>
<ul>
<li>String - 证书携带的公钥算法名称字符串。</li>
</ul>
<h3 id="operator-func-publickeyalgorithm"><a class="header" href="#operator-func-publickeyalgorithm">operator func !=(PublicKeyAlgorithm)</a></h3>
<pre><code class="language-cangjie">public override operator func !=(other: PublicKeyAlgorithm): Bool
</code></pre>
<p>功能：判不等。</p>
<p>参数：</p>
<ul>
<li>other: <a href="crypto/x509/x509_package_api/x509_package_enums.html#enum-publickeyalgorithm">PublicKeyAlgorithm</a> - 被比较的公钥算法。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - 若公钥算法不同，返回 true；否则，返回 false。</li>
</ul>
<h3 id="operator-func-publickeyalgorithm-1"><a class="header" href="#operator-func-publickeyalgorithm-1">operator func ==(PublicKeyAlgorithm)</a></h3>
<pre><code class="language-cangjie">public override operator func ==(other: PublicKeyAlgorithm): Bool
</code></pre>
<p>功能：判等。</p>
<p>参数：</p>
<ul>
<li>other: <a href="crypto/x509/x509_package_api/x509_package_enums.html#enum-publickeyalgorithm">PublicKeyAlgorithm</a> - 被比较的公钥算法。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - 若公钥算法相同，返回 true；否则，返回 false。</li>
</ul>
<h2 id="enum-signaturealgorithm"><a class="header" href="#enum-signaturealgorithm">enum SignatureAlgorithm</a></h2>
<pre><code class="language-cangjie">public enum SignatureAlgorithm &lt;: Equatable&lt;SignatureAlgorithm&gt; &amp; ToString {
    | MD2WithRSA | MD5WithRSA | SHA1WithRSA | SHA256WithRSA | SHA384WithRSA
    | SHA512WithRSA | DSAWithSHA1 | DSAWithSHA256 | ECDSAWithSHA1 | ECDSAWithSHA256
    | ECDSAWithSHA384 | ECDSAWithSHA512 | UnknownSignatureAlgorithm
}
</code></pre>
<p>功能：证书签名算法（<a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-signature">Signature</a> Algorithm）是用于数字证书签名的算法，它是一种将数字证书中的公钥和其他信息进行加密的算法，以确保数字证书的完整性和真实性。</p>
<p>目前支持签名算法的种类包括：MD2WithRSA 、MD5WithRSA 、SHA1WithRSA 、SHA256WithRSA 、SHA384WithRSA、SHA512WithRSA、DSAWithSHA1、DSAWithSHA256、ECDSAWithSHA1、ECDSAWithSHA256、ECDSAWithSHA384 和 ECDSAWithSHA512。</p>
<p>父类型：</p>
<ul>
<li>Equatable&lt;<a href="crypto/x509/x509_package_api/x509_package_enums.html#enum-signaturealgorithm">SignatureAlgorithm</a>&gt;</li>
<li>ToString</li>
</ul>
<h3 id="dsawithsha1"><a class="header" href="#dsawithsha1">DSAWithSHA1</a></h3>
<pre><code class="language-cangjie">DSAWithSHA1
</code></pre>
<p>功能：DSAwithSHA1 签名算法。</p>
<h3 id="dsawithsha256"><a class="header" href="#dsawithsha256">DSAWithSHA256</a></h3>
<pre><code class="language-cangjie">DSAWithSHA256
</code></pre>
<p>功能：DSAwithSHA256 签名算法。</p>
<h3 id="ecdsawithsha1"><a class="header" href="#ecdsawithsha1">ECDSAWithSHA1</a></h3>
<pre><code class="language-cangjie">ECDSAWithSHA1
</code></pre>
<p>功能：ECDSAwithSHA1 签名算法。</p>
<h3 id="ecdsawithsha256"><a class="header" href="#ecdsawithsha256">ECDSAWithSHA256</a></h3>
<pre><code class="language-cangjie">ECDSAWithSHA256
</code></pre>
<p>功能：ECDSAwithSHA256 签名算法。</p>
<h3 id="ecdsawithsha384"><a class="header" href="#ecdsawithsha384">ECDSAWithSHA384</a></h3>
<pre><code class="language-cangjie">ECDSAWithSHA384
</code></pre>
<p>功能：ECDSAwithSHA384 签名算法。</p>
<h3 id="ecdsawithsha512"><a class="header" href="#ecdsawithsha512">ECDSAWithSHA512</a></h3>
<pre><code class="language-cangjie">ECDSAWithSHA512
</code></pre>
<p>功能：ECDSAwithSHA512 签名算法。</p>
<h3 id="md2withrsa"><a class="header" href="#md2withrsa">MD2WithRSA</a></h3>
<pre><code class="language-cangjie">MD2WithRSA
</code></pre>
<p>功能：MD2withRSA 签名算法。</p>
<h3 id="md5withrsa"><a class="header" href="#md5withrsa">MD5WithRSA</a></h3>
<pre><code class="language-cangjie">MD5WithRSA
</code></pre>
<p>功能：MD5withRSA 签名算法。</p>
<h3 id="sha1withrsa"><a class="header" href="#sha1withrsa">SHA1WithRSA</a></h3>
<pre><code class="language-cangjie">SHA1WithRSA
</code></pre>
<p>功能：SHA1withRSA签名算法。</p>
<h3 id="sha256withrsa"><a class="header" href="#sha256withrsa">SHA256WithRSA</a></h3>
<pre><code class="language-cangjie">SHA256WithRSA
</code></pre>
<p>功能：SHA256withRSA 签名算法。</p>
<h3 id="sha384withrsa"><a class="header" href="#sha384withrsa">SHA384WithRSA</a></h3>
<pre><code class="language-cangjie">SHA384WithRSA
</code></pre>
<p>功能：SHA384withRSA 签名算法。</p>
<h3 id="sha512withrsa"><a class="header" href="#sha512withrsa">SHA512WithRSA</a></h3>
<pre><code class="language-cangjie">SHA512WithRSA
</code></pre>
<p>功能：SHA512withRSA 签名算法。</p>
<h3 id="unknownsignaturealgorithm"><a class="header" href="#unknownsignaturealgorithm">UnknownSignatureAlgorithm</a></h3>
<pre><code class="language-cangjie">UnknownSignatureAlgorithm
</code></pre>
<p>功能：未知签名算法。</p>
<h3 id="func-tostring-12"><a class="header" href="#func-tostring-12">func toString()</a></h3>
<pre><code class="language-cangjie">public override func toString(): String
</code></pre>
<p>功能：生成证书签名算法名称字符串。</p>
<p>返回值：</p>
<ul>
<li>String - 证书签名算法名称字符串。</li>
</ul>
<h3 id="operator-func--signaturealgorithm"><a class="header" href="#operator-func--signaturealgorithm">operator func != (SignatureAlgorithm)</a></h3>
<pre><code class="language-cangjie">public override operator func !=(other: SignatureAlgorithm): Bool
</code></pre>
<p>功能：判不等。</p>
<p>参数：</p>
<ul>
<li>other: <a href="crypto/x509/x509_package_api/./x509_package_enums.html#enum-signaturealgorithm">SignatureAlgorithm</a> - 被比较的签名算法。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - 若签名算法不同，返回 true；否则，返回 false。</li>
</ul>
<h3 id="operator-func--signaturealgorithm-1"><a class="header" href="#operator-func--signaturealgorithm-1">operator func == (SignatureAlgorithm)</a></h3>
<pre><code class="language-cangjie">public override operator func ==(other: SignatureAlgorithm): Bool
</code></pre>
<p>功能：判等。</p>
<p>参数：</p>
<ul>
<li>other: <a href="crypto/x509/x509_package_api/./x509_package_enums.html#enum-signaturealgorithm">SignatureAlgorithm</a> - 被比较的签名算法。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - 若签名算法相同，返回 true；否则，返回 false。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="结构体-7"><a class="header" href="#结构体-7">结构体</a></h1>
<h2 id="struct-derblob"><a class="header" href="#struct-derblob">struct DerBlob</a></h2>
<pre><code class="language-cangjie">public struct DerBlob &lt;: Equatable&lt;DerBlob&gt; &amp; Hashable {
    public init(content: Array&lt;Byte&gt;)
}
</code></pre>
<p>功能：Crypto 支持配置二进制证书流，用户读取二进制证书数据并创建 <a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a> 对象后可将其解析成 <a href="crypto/x509/x509_package_api/x509_package_classes.html#class-x509certificate">X509Certificate</a> / <a href="crypto/x509/x509_package_api/x509_package_classes.html#class-x509certificaterequest">X509CertificateRequest</a> / <a href="crypto/x509/x509_package_api/x509_package_interfaces.html#interface-publickey">PublicKey</a> / <a href="crypto/x509/x509_package_api/x509_package_interfaces.html#interface-privatekey">PrivateKey</a> 对象。</p>
<p>父类型：</p>
<ul>
<li>Equatable&lt;<a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a>&gt;</li>
<li>Hashable</li>
</ul>
<h3 id="prop-body"><a class="header" href="#prop-body">prop body</a></h3>
<pre><code class="language-cangjie">public prop body: Array&lt;Byte&gt;
</code></pre>
<p>功能：<a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a> 对象中的字符序列。</p>
<p>类型：Array&lt;Byte&gt;</p>
<h3 id="prop-size-8"><a class="header" href="#prop-size-8">prop size</a></h3>
<pre><code class="language-cangjie">public prop size: Int64
</code></pre>
<p>功能：<a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a> 对象中字符序列的大小。</p>
<p>类型：Int64</p>
<h3 id="initarraybyte"><a class="header" href="#initarraybyte">init(Array&lt;Byte&gt;)</a></h3>
<pre><code class="language-cangjie">public init(content: Array&lt;Byte&gt;)
</code></pre>
<p>功能：构造 <a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a> 对象。</p>
<p>参数：</p>
<ul>
<li>content: Array&lt;Byte&gt; - 二进制字符序列。</li>
</ul>
<h3 id="func-hashcode-2"><a class="header" href="#func-hashcode-2">func hashCode()</a></h3>
<pre><code class="language-cangjie">public override func hashCode(): Int64
</code></pre>
<p>功能：返回 <a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a> 对象哈希值。</p>
<p>返回值：</p>
<ul>
<li>Int64 - 对 <a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a> 对象进行哈希计算后得到的结果。</li>
</ul>
<h3 id="operator-func-derblob"><a class="header" href="#operator-func-derblob">operator func !=(DerBlob)</a></h3>
<pre><code class="language-cangjie">public override operator func !=(other: DerBlob): Bool
</code></pre>
<p>功能：判不等。</p>
<p>参数：</p>
<ul>
<li>other: <a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a> - 被比较的 <a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a> 对象。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - 若对象不同，返回 true；否则，返回 false。</li>
</ul>
<h3 id="operator-func-derblob-1"><a class="header" href="#operator-func-derblob-1">operator func ==(DerBlob)</a></h3>
<pre><code class="language-cangjie">public override operator func ==(other: DerBlob): Bool
</code></pre>
<p>功能：判等。</p>
<p>参数：</p>
<ul>
<li>other: <a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a> - 被比较的 <a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a> 对象。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - 若对象相同，返回 true；否则，返回 false。</li>
</ul>
<h2 id="struct-extkeyusage"><a class="header" href="#struct-extkeyusage">struct ExtKeyUsage</a></h2>
<pre><code class="language-cangjie">public struct ExtKeyUsage &lt;: ToString {
    public static let AnyKey = 0u16
    public static let ServerAuth = 1u16
    public static let ClientAuth = 2u16
    public static let EmailProtection = 3u16
    public static let CodeSigning = 4u16
    public static let OCSPSigning = 5u16
    public static let TimeStamping = 6u16
    public init(keys: Array&lt;UInt16&gt;)
}
</code></pre>
<p>功能：数字证书扩展字段中通常会包含携带扩展密钥用法说明，目前支持的用途有：ServerAuth、ClientAuth、EmailProtection、CodeSigning、OCSPSigning、TimeStamping。</p>
<p>父类型：</p>
<ul>
<li>ToString</li>
</ul>
<h3 id="static-let-anykey"><a class="header" href="#static-let-anykey">static let AnyKey</a></h3>
<pre><code class="language-cangjie">public static let AnyKey = 0u16
</code></pre>
<p>功能：表示应用于任意用途。</p>
<p>类型：UInt16</p>
<h3 id="static-let-clientauth"><a class="header" href="#static-let-clientauth">static let ClientAuth</a></h3>
<pre><code class="language-cangjie">public static let ClientAuth = 2u16
</code></pre>
<p>功能：表示用于 SSL 的客户端验证。</p>
<p>类型：UInt16</p>
<h3 id="static-let-codesigning"><a class="header" href="#static-let-codesigning">static let CodeSigning</a></h3>
<pre><code class="language-cangjie">public static let CodeSigning = 4u16
</code></pre>
<p>功能：表示用于代码签名。</p>
<p>类型：UInt16</p>
<h3 id="static-let-emailprotection"><a class="header" href="#static-let-emailprotection">static let EmailProtection</a></h3>
<pre><code class="language-cangjie">public static let EmailProtection = 3u16
</code></pre>
<p>功能：表示用于电子邮件的加解密、签名等。</p>
<p>类型：UInt16</p>
<h3 id="static-let-ocspsigning"><a class="header" href="#static-let-ocspsigning">static let OCSPSigning</a></h3>
<pre><code class="language-cangjie">public static let OCSPSigning = 5u16
</code></pre>
<p>功能：用于对 OCSP 响应包进行签名。</p>
<p>类型：UInt16</p>
<h3 id="static-let-serverauth"><a class="header" href="#static-let-serverauth">static let ServerAuth</a></h3>
<pre><code class="language-cangjie">public static let ServerAuth = 1u16
</code></pre>
<p>功能：表示用于 SSL 的服务端验证。</p>
<p>类型：UInt16</p>
<h3 id="static-let-timestamping"><a class="header" href="#static-let-timestamping">static let TimeStamping</a></h3>
<pre><code class="language-cangjie">public static let TimeStamping = 6u16
</code></pre>
<p>功能：用于将对象摘要值与时间绑定。</p>
<p>类型：UInt16</p>
<h3 id="initarrayuint16"><a class="header" href="#initarrayuint16">init(Array&lt;UInt16&gt;)</a></h3>
<pre><code class="language-cangjie">public init(keys: Array&lt;UInt16&gt;)
</code></pre>
<p>功能：构造指定用途的扩展密钥用法，需要注意同一个密钥可以有多种用途。</p>
<p>参数：</p>
<ul>
<li>keys: Array&lt;UInt16&gt; - 密钥。</li>
</ul>
<h3 id="func-tostring-13"><a class="header" href="#func-tostring-13">func toString()</a></h3>
<pre><code class="language-cangjie">public override func toString(): String
</code></pre>
<p>功能：生成扩展密钥用途字符串。</p>
<p>返回值：</p>
<ul>
<li>String - 证书扩展密钥用途字符串。</li>
</ul>
<h2 id="struct-keyusage"><a class="header" href="#struct-keyusage">struct KeyUsage</a></h2>
<pre><code class="language-cangjie">public struct KeyUsage &lt;: ToString {
    public static let DigitalSignature = 0x0080u16
    public static let NonRepudiation = 0x0040u16
    public static let KeyEncipherment = 0x0020u16
    public static let DataEncipherment = 0x0010u16
    public static let KeyAgreement = 0x0008u16
    public static let CertSign = 0x0004u16
    public static let CRLSign = 0x0002u16
    public static let EncipherOnly = 0x0001u16
    public static let DecipherOnly = 0x0100u16
    public init(keys: UInt16)
}
</code></pre>
<p>功能：数字证书扩展字段中通常会包含携带公钥的用法说明，目前支持的用途有：DigitalSignature、NonRepudiation、KeyEncipherment、DataEncipherment、KeyAgreement、CertSign、CRLSign、EncipherOnly、DecipherOnly。</p>
<p>父类型：</p>
<ul>
<li>ToString</li>
</ul>
<h3 id="static-let-crlsign"><a class="header" href="#static-let-crlsign">static let CRLSign</a></h3>
<pre><code class="language-cangjie">public static let CRLSign = 0x0002u16
</code></pre>
<p>功能：表示私钥可用于对 CRL 签名，而公钥可用于验证 CRL 签名。</p>
<p>类型：UInt16</p>
<h3 id="static-let-certsign"><a class="header" href="#static-let-certsign">static let CertSign</a></h3>
<pre><code class="language-cangjie">public static let CertSign = 0x0004u16
</code></pre>
<p>功能：表示私钥用于证书签名，而公钥用于验证证书签名，专用于 CA 证书。</p>
<p>类型：UInt16</p>
<h3 id="static-let-dataencipherment"><a class="header" href="#static-let-dataencipherment">static let DataEncipherment</a></h3>
<pre><code class="language-cangjie">public static let DataEncipherment = 0x0010u16
</code></pre>
<p>功能：表示公钥用于直接加密数据。</p>
<p>类型：UInt16</p>
<h3 id="static-let-decipheronly"><a class="header" href="#static-let-decipheronly">static let DecipherOnly</a></h3>
<pre><code class="language-cangjie">public static let DecipherOnly = 0x0100u16
</code></pre>
<p>功能：表示证书中的公钥在密钥协商过程中，仅仅用于解密计算，配合 key Agreement 使用才有意义。</p>
<p>类型：UInt16</p>
<h3 id="static-let-digitalsignature"><a class="header" href="#static-let-digitalsignature">static let DigitalSignature</a></h3>
<pre><code class="language-cangjie">public static let DigitalSignature = 0x0080u16
</code></pre>
<p>功能：表示私钥可以用于除了签发证书、签发 CRL 和非否认性服务的各种数字签名操作,而公钥用来验证这些签名。</p>
<p>类型：UInt16</p>
<h3 id="static-let-encipheronly"><a class="header" href="#static-let-encipheronly">static let EncipherOnly</a></h3>
<pre><code class="language-cangjie">public static let EncipherOnly = 0x0001u16
</code></pre>
<p>功能：表示证书中的公钥在密钥协商过程中，仅仅用于加密计算，配合 key Agreement 使用才有意义。</p>
<p>类型：UInt16</p>
<h3 id="static-let-keyagreement"><a class="header" href="#static-let-keyagreement">static let KeyAgreement</a></h3>
<pre><code class="language-cangjie">public static let KeyAgreement = 0x0008u16
</code></pre>
<p>功能：表示密钥用于密钥协商。</p>
<p>类型：UInt16</p>
<h3 id="static-let-keyencipherment"><a class="header" href="#static-let-keyencipherment">static let KeyEncipherment</a></h3>
<pre><code class="language-cangjie">public static let KeyEncipherment = 0x0020u16
</code></pre>
<p>功能：表示密钥用来加密传输其他的密钥。</p>
<p>类型：UInt16</p>
<h3 id="static-let-nonrepudiation"><a class="header" href="#static-let-nonrepudiation">static let NonRepudiation</a></h3>
<pre><code class="language-cangjie">public static let NonRepudiation = 0x0040u16
</code></pre>
<p>功能：表示私钥可以用于进行非否认性服务中的签名,而公钥用来验证签名。</p>
<p>类型：UInt16</p>
<h3 id="inituint16"><a class="header" href="#inituint16">init(UInt16)</a></h3>
<pre><code class="language-cangjie">public init(keys: UInt16)
</code></pre>
<p>功能：构造指定用途的扩展密钥用法，需要注意同一个密钥可以有多种用途。</p>
<p>参数：</p>
<ul>
<li>keys: UInt16 - 密钥的用法，建议使用本结构中所提供的密钥用法变量通过按位或的方式传入参数。</li>
</ul>
<h3 id="func-tostring-14"><a class="header" href="#func-tostring-14">func toString()</a></h3>
<pre><code class="language-cangjie">public override func toString(): String
</code></pre>
<p>功能：生成密钥用途字符串。</p>
<p>返回值：</p>
<ul>
<li>String - 证书密钥用途字符串。</li>
</ul>
<h2 id="struct-pem"><a class="header" href="#struct-pem">struct Pem</a></h2>
<pre><code class="language-cangjie">public struct Pem &lt;: Collection&lt;PemEntry&gt; &amp; ToString {
    public Pem(private let items: Array&lt;PemEntry&gt;)
}
</code></pre>
<p>功能：结构体 <a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-pem">Pem</a> 为条目序列，可以包含多个 <a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-pementry">PemEntry</a>。</p>
<p>父类型：</p>
<ul>
<li>Collection&lt;<a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-pementry">PemEntry</a>&gt;</li>
<li>ToString</li>
</ul>
<h3 id="prop-size-9"><a class="header" href="#prop-size-9">prop size</a></h3>
<pre><code class="language-cangjie">public override prop size: Int64
</code></pre>
<p>功能：条目序列的数量。</p>
<p>类型：Int64</p>
<h3 id="pemarraypementry"><a class="header" href="#pemarraypementry">Pem(Array&lt;PemEntry&gt;)</a></h3>
<pre><code class="language-cangjie">public Pem(private let items: Array&lt;PemEntry&gt;)
</code></pre>
<p>功能：构造 <a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-pem">Pem</a> 对象。</p>
<p>参数：</p>
<ul>
<li>items: Array&lt;<a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-pementry">PemEntry</a>&gt; - 多个 <a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-pementry">PemEntry</a> 对象。</li>
</ul>
<h3 id="static-func-decodestring"><a class="header" href="#static-func-decodestring">static func decode(String)</a></h3>
<pre><code class="language-cangjie">public static func decode(text: String): Pem
</code></pre>
<p>功能：将 PEM 文本解码为条目序列。</p>
<p>参数：</p>
<ul>
<li>text: String - PEM 字符串。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-pem">Pem</a> - PEM 条目序列。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/./x509_package_exceptions.html#class-x509exception">X509Exception</a> - 数据为空时，或解码失败抛出异常。</li>
</ul>
<h3 id="func-encode"><a class="header" href="#func-encode">func encode()</a></h3>
<pre><code class="language-cangjie">public func encode(): String
</code></pre>
<p>功能：返回PEM格式的字符串。行结束符将根据当前操作系统生成。</p>
<p>返回值：</p>
<ul>
<li>String - PEM 格式的字符串。</li>
</ul>
<h3 id="func-isempty"><a class="header" href="#func-isempty">func isEmpty()</a></h3>
<pre><code class="language-cangjie">public override func isEmpty(): Bool
</code></pre>
<p>功能：判断 PEM 文本解码为条目序列是否为空。</p>
<p>返回值：</p>
<ul>
<li>Bool - PEM 文本解码为条目序列为空返回 true；否则，返回 false。</li>
</ul>
<h3 id="func-iterator"><a class="header" href="#func-iterator">func iterator()</a></h3>
<pre><code class="language-cangjie">public override func iterator(): Iterator&lt;PemEntry&gt;
</code></pre>
<p>功能：生成 PEM 文本解码为条目序列的迭代器。</p>
<p>返回值：</p>
<ul>
<li>Iterator&lt;<a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-pementry">PemEntry</a>&gt; - PEM 文本解码为条目序列的迭代器。</li>
</ul>
<h3 id="func-tostring-15"><a class="header" href="#func-tostring-15">func toString()</a></h3>
<pre><code class="language-cangjie">public override func toString(): String
</code></pre>
<p>功能：返回一个字符串，字符串内容是包含每个条目序列的标签。</p>
<p>返回值：</p>
<ul>
<li>String - 包含每个条目序列的标签的字符串。</li>
</ul>
<h2 id="struct-pementry"><a class="header" href="#struct-pementry">struct PemEntry</a></h2>
<pre><code class="language-cangjie">public struct PemEntry &lt;: ToString {
    public static let LABEL_CERTIFICATE = &quot;CERTIFICATE&quot;
    public static let LABEL_X509_CRL = &quot;X509 CRL&quot;
    public static let LABEL_CERTIFICATE_REQUEST = &quot;CERTIFICATE REQUEST&quot;
    public static let LABEL_PRIVATE_KEY = &quot;PRIVATE KEY&quot;
    public static let LABEL_EC_PRIVATE_KEY = &quot;EC PRIVATE KEY&quot;
    public static let LABEL_ENCRYPTED_PRIVATE_KEY = &quot;ENCRYPTED PRIVATE KEY&quot;
    public static let LABEL_RSA_PRIVATE_KEY = &quot;RSA PRIVATE KEY&quot;
    public static let LABEL_SM2_PRIVATE_KEY = &quot;SM2 PRIVATE KEY&quot;
    public static let LABEL_PUBLIC_KEY = &quot;PUBLIC KEY&quot;
    public static let LABEL_EC_PARAMETERS = &quot;EC PARAMETERS&quot;
    public static let LABEL_DH_PARAMETERS = &quot;DH PARAMETERS&quot;
    public PemEntry(
        public let label: String,
        public let headers: Array&lt;(String, String)&gt;,
        public let body: ?DerBlob
    )
    public init(label: String, body: DerBlob)
}
</code></pre>
<p>功能：PEM 文本格式经常用于存储证书和密钥，PEM 编码结构包含以下几个部分：</p>
<p>第一行是 “-----BEGIN”，标签和 “-----” 组成的utf8编码的字符串；
中间是正文，是实际二进制内容经过 base64 编码得到的可打印字符串，详细的PEM编码规范可参考 <a href="https://www.rfc-editor.org/rfc/rfc7468.html">RFC 7468</a>；
最后一行是 “-----END”，标签和 “-----” 组成的 utf8 编码的字符串，详见 <a href="https://www.rfc-editor.org/rfc/rfc1421.html">RFC 1421</a>。
在旧版的 PEM 编码标准中在第一行和正文之间还包含条目头。</p>
<p>为了支持不同的用户场景，我们提供了 <a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-pementry">PemEntry</a> 和 <a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-pem">Pem</a> 类型，<a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-pementry">PemEntry</a> 用于存储单个PEM 基础结构。</p>
<p>父类型：</p>
<ul>
<li>ToString</li>
</ul>
<h3 id="static-let-label_certificate"><a class="header" href="#static-let-label_certificate">static let LABEL_CERTIFICATE</a></h3>
<pre><code class="language-cangjie">public static let LABEL_CERTIFICATE = &quot;CERTIFICATE&quot;
</code></pre>
<p>功能：记录条目类型为证书。</p>
<p>类型：String</p>
<h3 id="static-let-label_certificate_request"><a class="header" href="#static-let-label_certificate_request">static let LABEL_CERTIFICATE_REQUEST</a></h3>
<pre><code class="language-cangjie">public static let LABEL_CERTIFICATE_REQUEST = &quot;CERTIFICATE REQUEST&quot;
</code></pre>
<p>功能：记录条目类型为证书签名请求。</p>
<p>类型：String</p>
<h3 id="static-let-label_dh_parameters"><a class="header" href="#static-let-label_dh_parameters">static let LABEL_DH_PARAMETERS</a></h3>
<pre><code class="language-cangjie">public static let LABEL_DH_PARAMETERS = &quot;DH PARAMETERS&quot;
</code></pre>
<p>功能：记录条目类型为 DH 密钥参数。</p>
<p>类型：String</p>
<h3 id="static-let-label_ec_parameters"><a class="header" href="#static-let-label_ec_parameters">static let LABEL_EC_PARAMETERS</a></h3>
<pre><code class="language-cangjie">public static let LABEL_EC_PARAMETERS = &quot;EC PARAMETERS&quot;
</code></pre>
<p>功能：记录条目类型为椭圆曲线参数。</p>
<p>类型：String</p>
<h3 id="static-let-label_ec_private_key"><a class="header" href="#static-let-label_ec_private_key">static let LABEL_EC_PRIVATE_KEY</a></h3>
<pre><code class="language-cangjie">public static let LABEL_EC_PRIVATE_KEY = &quot;EC PRIVATE KEY&quot;
</code></pre>
<p>功能：记录条目类型为椭圆曲线私钥。</p>
<p>类型：String</p>
<h3 id="static-let-label_encrypted_private_key"><a class="header" href="#static-let-label_encrypted_private_key">static let LABEL_ENCRYPTED_PRIVATE_KEY</a></h3>
<pre><code class="language-cangjie">public static let LABEL_ENCRYPTED_PRIVATE_KEY = &quot;ENCRYPTED PRIVATE KEY&quot;
</code></pre>
<p>功能：记录条目类型为 PKCS #8 标准加密的私钥。</p>
<p>类型：String</p>
<h3 id="static-let-label_private_key"><a class="header" href="#static-let-label_private_key">static let LABEL_PRIVATE_KEY</a></h3>
<pre><code class="language-cangjie">public static let LABEL_PRIVATE_KEY = &quot;PRIVATE KEY&quot;
</code></pre>
<p>功能：记录条目类型为 PKCS #8 标准未加密的私钥。</p>
<p>类型：String</p>
<h3 id="static-let-label_public_key"><a class="header" href="#static-let-label_public_key">static let LABEL_PUBLIC_KEY</a></h3>
<pre><code class="language-cangjie">public static let LABEL_PUBLIC_KEY = &quot;PUBLIC KEY&quot;
</code></pre>
<p>功能：记录条目类型为公钥。</p>
<p>类型：String</p>
<h3 id="static-let-label_rsa_private_key"><a class="header" href="#static-let-label_rsa_private_key">static let LABEL_RSA_PRIVATE_KEY</a></h3>
<pre><code class="language-cangjie">public static let LABEL_RSA_PRIVATE_KEY = &quot;RSA PRIVATE KEY&quot;
</code></pre>
<p>功能：记录条目类型为 RSA 私钥。</p>
<p>类型：String</p>
<h3 id="static-let-label_sm2_private_key"><a class="header" href="#static-let-label_sm2_private_key">static let LABEL_SM2_PRIVATE_KEY</a></h3>
<pre><code class="language-cangjie">public static let LABEL_SM2_PRIVATE_KEY = &quot;SM2 PRIVATE KEY&quot;
</code></pre>
<p>功能：记录条目类型为 SM2 私钥。</p>
<p>类型：String</p>
<h3 id="static-let-label_x509_crl"><a class="header" href="#static-let-label_x509_crl">static let LABEL_X509_CRL</a></h3>
<pre><code class="language-cangjie">public static let LABEL_X509_CRL = &quot;X509 CRL&quot;
</code></pre>
<p>功能：记录条目类型为证书吊销列表。</p>
<p>类型：String</p>
<h3 id="pementrystring-arraystring-string-derblob"><a class="header" href="#pementrystring-arraystring-string-derblob">PemEntry(String, Array&lt;(String, String)&gt;, ?DerBlob)</a></h3>
<pre><code class="language-cangjie">public PemEntry(
    public let label: String,
    public let headers: Array&lt;(String, String)&gt;,
    public let body: ?DerBlob
)
</code></pre>
<p>功能：构造 <a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-pementry">PemEntry</a> 对象。</p>
<p>参数：</p>
<ul>
<li>
<p>label: String - 标签。</p>
</li>
<li>
<p>headers: Array&lt;(String, String)&gt; - 条目头。</p>
</li>
<li>
<p>body: ?<a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a> - 二进制内容。</p>
</li>
</ul>
<h3 id="let-body"><a class="header" href="#let-body">let body</a></h3>
<pre><code class="language-cangjie">public let body: ?DerBlob
</code></pre>
<p>功能：<a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-pementry">PemEntry</a> 实例的二进制内容。</p>
<p>类型：?<a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a></p>
<h3 id="let-headers"><a class="header" href="#let-headers">let headers</a></h3>
<pre><code class="language-cangjie">public let headers: Array&lt;(String, String)&gt;
</code></pre>
<p>功能：<a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-pementry">PemEntry</a> 实例的条目头。</p>
<p>类型：Array&lt;(String, String)&gt;</p>
<h3 id="let-label"><a class="header" href="#let-label">let label</a></h3>
<pre><code class="language-cangjie">public let label: String
</code></pre>
<p>功能：<a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-pementry">PemEntry</a> 实例的标签。</p>
<p>类型：String</p>
<h3 id="initstring-derblob"><a class="header" href="#initstring-derblob">init(String, DerBlob)</a></h3>
<pre><code class="language-cangjie">public init(label: String, body: DerBlob)
</code></pre>
<p>功能：构造 <a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-pementry">PemEntry</a> 对象。</p>
<p>参数：</p>
<ul>
<li>label: String - 标签</li>
<li>body: <a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a> - 二进制内容</li>
</ul>
<h3 id="func-encode-1"><a class="header" href="#func-encode-1">func encode()</a></h3>
<pre><code class="language-cangjie">public func encode(): String
</code></pre>
<p>功能：返回PEM格式的字符串。行结束符将根据当前操作系统生成。</p>
<p>返回值：</p>
<ul>
<li>String - PEM 格式的字符串。</li>
</ul>
<h3 id="func-headerstring"><a class="header" href="#func-headerstring">func header(String)</a></h3>
<pre><code class="language-cangjie">public func header(name: String): Iterator&lt;String&gt;
</code></pre>
<p>功能：通过条目头名称，找到对应条目内容。</p>
<p>参数：</p>
<ul>
<li>name: String - 条目头名称。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Iterator&lt;String&gt; - 条目头名称对应内容的迭代器。</li>
</ul>
<h3 id="func-tostring-16"><a class="header" href="#func-tostring-16">func toString()</a></h3>
<pre><code class="language-cangjie">public override func toString(): String
</code></pre>
<p>功能：返回 PEM 对象的标签和二进制内容的长度。</p>
<p>返回值：</p>
<ul>
<li>String - PEM 对象的标签和二进制内容的长度。</li>
</ul>
<h2 id="struct-serialnumber"><a class="header" href="#struct-serialnumber">struct SerialNumber</a></h2>
<pre><code class="language-cangjie">public struct SerialNumber &lt;: Equatable&lt;SerialNumber&gt; &amp; Hashable &amp; ToString {
    public init(length!: UInt8 = 16)
}
</code></pre>
<p>功能: 结构体 <a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-serialnumber">SerialNumber</a> 为数字证书的序列号，是数字证书中的一个唯一标识符，用于标识数字证书的唯一性。根据规范，证书序列号的长度不应超过 20 字节。详见<a href="https://www.rfc-editor.org/rfc/rfc5280">rfc5280</a>。</p>
<p>父类型：</p>
<ul>
<li>Equatable&lt;<a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-serialnumber">SerialNumber</a>&gt;</li>
<li>Hashable</li>
<li>ToString</li>
</ul>
<h3 id="inituint8"><a class="header" href="#inituint8">init(UInt8)</a></h3>
<pre><code class="language-cangjie">public init(length!: UInt8 = 16)
</code></pre>
<p>功能：生成指定长度的随机序列号。</p>
<p>参数：</p>
<ul>
<li>length!: UInt8 - 序列号长度，单位为字节，类型为 UInt8，默认值为 16。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/./x509_package_exceptions.html#class-x509exception">X509Exception</a> - length 等于 0 或大于 20 时，抛出异常。</li>
</ul>
<h3 id="func-hashcode-3"><a class="header" href="#func-hashcode-3">func hashCode()</a></h3>
<pre><code class="language-cangjie">public override func hashCode(): Int64
</code></pre>
<p>功能：返回证书序列号哈希值。</p>
<p>返回值：</p>
<ul>
<li>Int64 - 对证书序列号对象进行哈希计算后得到的结果。</li>
</ul>
<h3 id="func-tostring-17"><a class="header" href="#func-tostring-17">func toString()</a></h3>
<pre><code class="language-cangjie">public override func toString(): String
</code></pre>
<p>功能：生成证书序列号字符串，格式为 16 进制。</p>
<p>返回值：</p>
<ul>
<li>String - 证书序列号字符串。</li>
</ul>
<h3 id="operator-func-serialnumber"><a class="header" href="#operator-func-serialnumber">operator func !=(SerialNumber)</a></h3>
<pre><code class="language-cangjie">public override operator func !=(other: SerialNumber): Bool
</code></pre>
<p>功能：判不等。</p>
<p>参数：</p>
<ul>
<li>other: <a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-serialnumber">SerialNumber</a> - 被比较的证书序列号对象。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - 若序列号不同，返回 true；否则，返回 false。</li>
</ul>
<h3 id="operator-func-serialnumber-1"><a class="header" href="#operator-func-serialnumber-1">operator func ==(SerialNumber)</a></h3>
<pre><code class="language-cangjie">public override operator func ==(other: SerialNumber): Bool
</code></pre>
<p>功能：判等。</p>
<p>参数：</p>
<ul>
<li>other: <a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-serialnumber">SerialNumber</a> - 被比较的证书序列号对象。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - 若序列号相同，返回 true；否则，返回 false。</li>
</ul>
<h2 id="struct-signature"><a class="header" href="#struct-signature">struct Signature</a></h2>
<pre><code class="language-cangjie">public struct Signature &lt;: Equatable&lt;Signature&gt; &amp; Hashable {
}
</code></pre>
<p>功能：数字证书的签名，用来验证身份的正确性。</p>
<p>父类型：</p>
<ul>
<li>Equatable&lt;<a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-signature">Signature</a>&gt;</li>
<li>Hashable</li>
</ul>
<h3 id="prop-signaturevalue"><a class="header" href="#prop-signaturevalue">prop signatureValue</a></h3>
<pre><code class="language-cangjie">public prop signatureValue: DerBlob
</code></pre>
<p>功能：返回证书签名的二进制。</p>
<p>类型：<a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-derblob">DerBlob</a></p>
<h3 id="func-hashcode-4"><a class="header" href="#func-hashcode-4">func hashCode()</a></h3>
<pre><code class="language-cangjie">public override func hashCode(): Int64
</code></pre>
<p>功能：返回证书签名哈希值。</p>
<p>返回值：</p>
<ul>
<li>Int64 - 对证书签名对象进行哈希计算后得到的结果。</li>
</ul>
<h3 id="operator-func-signature"><a class="header" href="#operator-func-signature">operator func !=(Signature)</a></h3>
<pre><code class="language-cangjie">public override operator func !=(other: Signature): Bool
</code></pre>
<p>功能：判不等。</p>
<p>参数：</p>
<ul>
<li>other: <a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-signature">Signature</a> - 被比较的证书签名。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - 若证书签名不同，返回 true；否则，返回 false。</li>
</ul>
<h3 id="operator-func-signature-1"><a class="header" href="#operator-func-signature-1">operator func ==(Signature)</a></h3>
<pre><code class="language-cangjie">public override operator func ==(other: Signature): Bool
</code></pre>
<p>功能：判等。</p>
<p>参数：</p>
<ul>
<li>other: <a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-signature">Signature</a> - 被比较的证书签名。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - 若证书签名相同，返回 true；否则，返回 false。</li>
</ul>
<h2 id="struct-verifyoption"><a class="header" href="#struct-verifyoption">struct VerifyOption</a></h2>
<pre><code class="language-cangjie">public struct VerifyOption {
    public var time: DateTime = DateTime.now()
    public var dnsName: String = &quot;&quot;
    public var roots: Array&lt;X509Certificate&gt; = X509Certificate.systemRootCerts()
    public var intermediates: Array&lt;X509Certificate&gt; = Array&lt;X509Certificate&gt;()
}
</code></pre>
<p>功能：用于为 <code>x509</code> 证书验证函数 <a href="crypto/x509/x509_package_api/./x509_package_classes.html#func-verifyverifyoption">verify</a> 提供配置选项。</p>
<h3 id="var-dnsname"><a class="header" href="#var-dnsname">var dnsName</a></h3>
<pre><code class="language-cangjie">public var dnsName: String = &quot;&quot;
</code></pre>
<p>功能：校验域名，默认为空，只有设置域名时才会进行此处校验。</p>
<p>类型：String</p>
<h3 id="var-intermediates"><a class="header" href="#var-intermediates">var intermediates</a></h3>
<pre><code class="language-cangjie">public var intermediates: Array&lt;X509Certificate&gt; = Array&lt;X509Certificate&gt;()
</code></pre>
<p>功能：中间证书链，默认为空。</p>
<p>类型：Array&lt;<a href="crypto/x509/x509_package_api/x509_package_classes.html#class-x509certificate">X509Certificate</a>&gt;</p>
<h3 id="var-roots"><a class="header" href="#var-roots">var roots</a></h3>
<pre><code class="language-cangjie">public var roots: Array&lt;X509Certificate&gt; = X509Certificate.systemRootCerts()
</code></pre>
<p>功能：根证书链，默认为系统根证书链。</p>
<p>类型：Array&lt;<a href="crypto/x509/x509_package_api/x509_package_classes.html#class-x509certificate">X509Certificate</a>&gt;</p>
<h3 id="var-time"><a class="header" href="#var-time">var time</a></h3>
<pre><code class="language-cangjie">public var time: DateTime = DateTime.now()
</code></pre>
<p>功能：校验时间，默认为创建选项的时间。</p>
<p>类型：DateTime</p>
<h2 id="struct-x509certificateinfo"><a class="header" href="#struct-x509certificateinfo">struct X509CertificateInfo</a></h2>
<pre><code class="language-cangjie">public struct X509CertificateInfo {
    public var serialNumber: SerialNumber
    public var notBefore: DateTime
    public var notAfter: DateTime
    public var subject: ?X509Name
    public var dnsNames: Array&lt;String&gt;
    public var emailAddresses: Array&lt;String&gt;
    public var IPAddresses: Array&lt;IP&gt;
    public var keyUsage: ?KeyUsage
    public var extKeyUsage: ?ExtKeyUsage

    public init(
        serialNumber!: ?SerialNumber = None,
        notBefore!: ?DateTime = None,
        notAfter!: ?DateTime = None,
        subject!: ?X509Name = None,
        dnsNames!: Array&lt;String&gt; = Array&lt;String&gt;(),
        emailAddresses!: Array&lt;String&gt; = Array&lt;String&gt;(),
        IPAddresses!: Array&lt;IP&gt; = Array&lt;IP&gt;(),
        keyUsage!: ?KeyUsage = None,
        extKeyUsage!: ?ExtKeyUsage = None
    )
}
</code></pre>
<p>功能：<a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-x509certificateinfo">X509CertificateInfo</a> 结构包含了证书信息，包括证书序列号、有效期、实体可辨识名称、域名、email 地址、<a href="crypto/x509/x509_package_api/x509_package_type.html#type-ip">IP</a> 地址、密钥用法和扩展密钥用法。</p>
<h3 id="var-ipaddresses"><a class="header" href="#var-ipaddresses">var IPAddresses</a></h3>
<pre><code class="language-cangjie">public var IPAddresses: Array&lt;IP&gt;
</code></pre>
<p>功能：记录证书的 <a href="crypto/x509/x509_package_api/x509_package_type.html#type-ip">IP</a> 地址。</p>
<p>类型：Array&lt;<a href="crypto/x509/x509_package_api/./x509_package_type.html#type-ip">IP</a>&gt;</p>
<h3 id="var-dnsnames"><a class="header" href="#var-dnsnames">var dnsNames</a></h3>
<pre><code class="language-cangjie">public var dnsNames: Array&lt;String&gt;
</code></pre>
<p>功能：记录证书的 DNS 域名。</p>
<p>类型：Array&lt;String&gt;</p>
<h3 id="var-emailaddresses"><a class="header" href="#var-emailaddresses">var emailAddresses</a></h3>
<pre><code class="language-cangjie">public var emailAddresses: Array&lt;String&gt;
</code></pre>
<p>功能：记录证书的 email 地址。</p>
<p>类型：Array&lt;String&gt;</p>
<h3 id="var-extkeyusage"><a class="header" href="#var-extkeyusage">var extKeyUsage</a></h3>
<pre><code class="language-cangjie">public var extKeyUsage: ?ExtKeyUsage
</code></pre>
<p>功能：记录证书的扩展密钥用法。</p>
<p>类型：?<a href="crypto/x509/x509_package_api/./x509_package_structs.html#struct-extkeyusage">ExtKeyUsage</a></p>
<h3 id="var-keyusage"><a class="header" href="#var-keyusage">var keyUsage</a></h3>
<pre><code class="language-cangjie">public var keyUsage: ?KeyUsage
</code></pre>
<p>功能：记录证书的密钥用法。</p>
<p>类型：?<a href="crypto/x509/x509_package_api/./x509_package_structs.html#struct-keyusage">KeyUsage</a></p>
<h3 id="var-notafter"><a class="header" href="#var-notafter">var notAfter</a></h3>
<pre><code class="language-cangjie">public var notAfter: DateTime
</code></pre>
<p>功能：记录证书有效期的结束日期。</p>
<p>类型：DateTime</p>
<h3 id="var-notbefore"><a class="header" href="#var-notbefore">var notBefore</a></h3>
<pre><code class="language-cangjie">public var notBefore: DateTime
</code></pre>
<p>功能：记录证书有效期的起始日期。</p>
<p>类型：DateTime</p>
<h3 id="var-serialnumber"><a class="header" href="#var-serialnumber">var serialNumber</a></h3>
<pre><code class="language-cangjie">public var serialNumber: SerialNumber
</code></pre>
<p>功能：记录证书的序列号。</p>
<p>类型：<a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-serialnumber">SerialNumber</a></p>
<h3 id="var-subject"><a class="header" href="#var-subject">var subject</a></h3>
<pre><code class="language-cangjie">public var subject: ?X509Name
</code></pre>
<p>功能：记录证书实体可辨识名称。</p>
<p>类型：?<a href="crypto/x509/x509_package_api/x509_package_classes.html#class-x509name">X509Name</a></p>
<h3 id="initserialnumber-datetime-datetime-x509name-arraystring-arraystring-arrayip-keyusage-extkeyusage"><a class="header" href="#initserialnumber-datetime-datetime-x509name-arraystring-arraystring-arrayip-keyusage-extkeyusage">init(?SerialNumber, ?DateTime, ?DateTime, ?X509Name, Array&lt;String&gt;, Array&lt;String&gt;, Array&lt;IP&gt;, ?KeyUsage, ?ExtKeyUsage)</a></h3>
<pre><code class="language-cangjie">public init(
    serialNumber!: ?SerialNumber = None,
    notBefore!: ?DateTime = None,
    notAfter!: ?DateTime = None,
    subject!: ?X509Name = None,
    dnsNames!: Array&lt;String&gt; = Array&lt;String&gt;(),
    emailAddresses!: Array&lt;String&gt; = Array&lt;String&gt;(),
    IPAddresses!: Array&lt;IP&gt; = Array&lt;IP&gt;(),
    keyUsage!: ?KeyUsage = None,
    extKeyUsage!: ?ExtKeyUsage = None
)
</code></pre>
<p>功能：构造 <a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-x509certificateinfo">X509CertificateInfo</a> 对象。</p>
<p>参数：</p>
<ul>
<li>serialNumber!: ?<a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-serialnumber">SerialNumber</a> - 数字证书序列号，默认值为 None，使用默认值时默认的序列号长度为 128 比特。</li>
<li>notBefore!: ?DateTime - 数字证书有效期开始时间，默认值为 None，使用默认值时默认的时间为 <a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-x509certificateinfo">X509CertificateInfo</a> 创建的时间。</li>
<li>notAfter!: ?DateTime - 数字证书有效期截止时间，默认值为 None，使用默认值时默认的时间为 notBefore 往后 1 年的时间。</li>
<li>subject!: ?<a href="crypto/x509/x509_package_api/x509_package_classes.html#class-x509name">X509Name</a> - 数字证书使用者信息，默认值为 None。</li>
<li>dnsNames!: Array&lt;String&gt; - 域名列表，需要用户保证输入域名的有效性，默认值为空的字符串数组。</li>
<li>emailAddresses!: Array&lt;String&gt; - email 地址列表，需要用户保证输入 email 的有效性，默认值为空的字符串数组。</li>
<li>IPAddresses!: Array&lt;<a href="crypto/x509/x509_package_api/x509_package_type.html#type-ip">IP</a>&gt; - <a href="crypto/x509/x509_package_api/x509_package_type.html#type-ip">IP</a> 地址列表，默认值为空的 <a href="crypto/x509/x509_package_api/x509_package_type.html#type-ip">IP</a> 数组。</li>
<li>keyUsage!: ?<a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-keyusage">KeyUsage</a> - 密钥用法，默认值为 None。</li>
<li>extKeyUsage!: ?<a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-extkeyusage">ExtKeyUsage</a> - 扩展密钥用法，默认值为 None。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/./x509_package_exceptions.html#class-x509exception">X509Exception</a> - 输入的 <a href="crypto/x509/x509_package_api/x509_package_type.html#type-ip">IP</a> 地址列表中包含无效的 <a href="crypto/x509/x509_package_api/x509_package_type.html#type-ip">IP</a> 地址，则抛出异常。</li>
</ul>
<h2 id="struct-x509certificaterequestinfo"><a class="header" href="#struct-x509certificaterequestinfo">struct X509CertificateRequestInfo</a></h2>
<pre><code class="language-cangjie">public struct X509CertificateRequestInfo {
    public var subject: ?X509Name
    public var dnsNames: Array&lt;String&gt;
    public var emailAddresses: Array&lt;String&gt;
    public var IPAddresses: Array&lt;IP&gt;
 
    public init(
        subject!: ?X509Name = None,
        dnsNames!: Array&lt;String&gt; = Array&lt;String&gt;(),
        emailAddresses!: Array&lt;String&gt; = Array&lt;String&gt;(),
        IPAddresses!: Array&lt;IP&gt; = Array&lt;IP&gt;()
    )
}
</code></pre>
<p>功能: <a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-x509certificaterequestinfo">X509CertificateRequestInfo</a> 结构包含了证书请求信息，包括证书实体可辨识名称、域名、email 地址和 <a href="crypto/x509/x509_package_api/x509_package_type.html#type-ip">IP</a> 地址。</p>
<h3 id="var-ipaddresses-1"><a class="header" href="#var-ipaddresses-1">var IPAddresses</a></h3>
<pre><code class="language-cangjie">public var IPAddresses: Array&lt;IP&gt;
</code></pre>
<p>功能：记录证书签名请求的 <a href="crypto/x509/x509_package_api/x509_package_type.html#type-ip">IP</a> 地址。</p>
<p>类型：Array&lt;<a href="crypto/x509/x509_package_api/./x509_package_type.html#type-ip">IP</a>&gt;</p>
<h3 id="var-dnsnames-1"><a class="header" href="#var-dnsnames-1">var dnsNames</a></h3>
<pre><code class="language-cangjie">public var dnsNames: Array&lt;String&gt;
</code></pre>
<p>功能：记录证书签名请求的 DNS 域名。</p>
<p>类型：Array&lt;String&gt;</p>
<h3 id="var-emailaddresses-1"><a class="header" href="#var-emailaddresses-1">var emailAddresses</a></h3>
<pre><code class="language-cangjie">public var emailAddresses: Array&lt;String&gt;
</code></pre>
<p>功能：记录证书签名请求的 email 地址。</p>
<p>类型：Array&lt;String&gt;</p>
<h3 id="var-subject-1"><a class="header" href="#var-subject-1">var subject</a></h3>
<pre><code class="language-cangjie">public var subject: ?X509Name
</code></pre>
<p>功能：记录证书签名请求的实体可辨识名称。</p>
<h3 id="initx509name-arraystring-arraystring-arrayip"><a class="header" href="#initx509name-arraystring-arraystring-arrayip">init(?X509Name, Array&lt;String&gt;, Array&lt;String&gt;, Array&lt;IP&gt;)</a></h3>
<pre><code class="language-cangjie">public init(
    subject!: ?X509Name = None,
    dnsNames!: Array&lt;String&gt; = Array&lt;String&gt;(),
    emailAddresses!: Array&lt;String&gt; = Array&lt;String&gt;(),
    IPAddresses!: Array&lt;IP&gt; = Array&lt;IP&gt;()
)
</code></pre>
<p>功能：构造 <a href="crypto/x509/x509_package_api/x509_package_structs.html#struct-x509certificaterequestinfo">X509CertificateRequestInfo</a> 对象。</p>
<p>参数：</p>
<ul>
<li>subject!: ?<a href="crypto/x509/x509_package_api/x509_package_classes.html#class-x509name">X509Name</a> - 数字证书的使用者信息，默认值为 None。</li>
<li>dnsNames!: Array&lt;String&gt; - 域名列表，需要用户保证输入域名的有效性，默认值为空的字符串数组。</li>
<li>emailAddresses!: Array&lt;String&gt; - email 地址列表，需要用户保证输入 email 的有效性，默认值为空的字符串数组。</li>
<li>IPAddresses!: Array&lt;<a href="crypto/x509/x509_package_api/x509_package_type.html#type-ip">IP</a>&gt; - <a href="crypto/x509/x509_package_api/x509_package_type.html#type-ip">IP</a> 地址列表，默认值为空的 <a href="crypto/x509/x509_package_api/x509_package_type.html#type-ip">IP</a> 数组。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="crypto/x509/x509_package_api/./x509_package_exceptions.html#class-x509exception">X509Exception</a> - 输入的 <a href="crypto/x509/x509_package_api/x509_package_type.html#type-ip">IP</a> 地址列表中包含无效的 <a href="crypto/x509/x509_package_api/x509_package_type.html#type-ip">IP</a> 地址，则抛出异常。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="异常类-7"><a class="header" href="#异常类-7">异常类</a></h1>
<h2 id="class-x509exception"><a class="header" href="#class-x509exception">class X509Exception</a></h2>
<pre><code class="language-cangjie">public class X509Exception &lt;: Exception {
    public init()
    public init(message: String)
}
</code></pre>
<p>功能：此异常为 X509 包抛出的异常类型。</p>
<p>父类型：</p>
<ul>
<li>Exception</li>
</ul>
<h3 id="init-10"><a class="header" href="#init-10">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造 <a href="crypto/x509/x509_package_api/x509_package_exceptions.html#class-x509exception">X509Exception</a> 对象。</p>
<h3 id="initstring-3"><a class="header" href="#initstring-3">init(String)</a></h3>
<pre><code class="language-cangjie">public init(message: String)
</code></pre>
<p>功能：构造 <a href="crypto/x509/x509_package_api/x509_package_exceptions.html#class-x509exception">X509Exception</a> 对象。</p>
<p>参数：</p>
<ul>
<li>message: String - 异常的信息。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="x509-使用"><a class="header" href="#x509-使用">x509 使用</a></h1>
<h2 id="读取解析证书"><a class="header" href="#读取解析证书">读取、解析证书</a></h2>
<blockquote>
<p><strong>说明：</strong></p>
<p>需要自行准备证书文件。</p>
</blockquote>
<p>示例：</p>
<!-- compile -->
<pre><code class="language-cangjie">import std.fs.File
import stdx.crypto.x509.*

let readPath = &quot;./files/root_rsa.cer&quot;

main() {
    /* 读取本地证书*/
    let pem = String.fromUtf8(File.readFrom(readPath))
    let certificates = X509Certificate.decodeFromPem(pem)

    /* 解析证书中的必选字段 */
    let cert = certificates[0]
    println(cert)
    println(&quot;Serial Number: ${cert.serialNumber}&quot;)
    println(&quot;Issuer: ${cert.issuer}&quot;)
    println(&quot;NotBefore: ${cert.notBefore}&quot;)
    println(&quot;NotAfter: ${cert.notAfter}&quot;)
    println(cert.signatureAlgorithm)
    let signature = cert.signature
    println(signature.hashCode())
    println(cert.publicKeyAlgorithm)
    let pubKey = cert.publicKey
    println(pubKey.encodeToPem().encode())

    /* 解析证书中的扩展字段 */
    println(&quot;DNSNames: ${cert.dnsNames}&quot;)
    println(&quot;EmailAddresses: ${cert.emailAddresses}&quot;)
    println(&quot;IPAddresses: ${cert.IPAddresses}&quot;)
    println(&quot;KeyUsage: ${cert.keyUsage}&quot;)
    println(&quot;ExtKeyUsage: ${cert.extKeyUsage}&quot;)

    /* 解析证书使用者的可辨识名称 */
    println(&quot;Subject: ${cert.subject}&quot;)

    return 0
}
</code></pre>
<h2 id="读取验证证书"><a class="header" href="#读取验证证书">读取、验证证书</a></h2>
<blockquote>
<p><strong>说明：</strong></p>
<p>需要自行准备证书文件。</p>
</blockquote>
<p>示例：</p>
<!-- compile -->
<pre><code class="language-cangjie">import std.fs.File
import stdx.crypto.x509.*
import std.time.DateTime

let prefixPath = &quot;./files/&quot;
let certFile = &quot;servers.crt&quot;
let rootFile = &quot;roots.crt&quot;
let middleFile = &quot;middles.crt&quot;

func getX509Cert(path: String) {
    let pem = String.fromUtf8(File.readFrom(path))
    X509Certificate.decodeFromPem(pem)
}

func testVerifyByTime(cert: X509Certificate, roots: Array&lt;X509Certificate&gt;, middles: Array&lt;X509Certificate&gt;) {
    var opt = VerifyOption()
    opt.roots = roots
    opt.intermediates = middles
    cert.verify(opt)
    println(&quot;Verify result: ${cert.verify(opt)}&quot;)
    opt.time = DateTime.of(year: 2023, month: 7, dayOfMonth: 1)
    println(&quot;Verify result:: ${cert.verify(opt)}&quot;)
}

func testVerifyByDNS(cert: X509Certificate) {
    var opt = VerifyOption()
    opt.dnsName = &quot;www.example.com&quot;
    println(&quot;cert DNS names: ${cert.dnsNames}&quot;)
    let res = cert.verify(opt)
    println(&quot;Verify result: ${res}&quot;)
}

/**
 * The relation of certs.
 *    root[0]         root[1]
 *    /      \            |
 *  mid[0]  mid[1]    mid[2]
 *   |                  |
 *  server[0]         server[1]
 */
func testVerify(cert: X509Certificate, roots: Array&lt;X509Certificate&gt;, middles: Array&lt;X509Certificate&gt;) {
    var opt = VerifyOption()
    opt.roots = roots
    opt.intermediates = middles
    let res = cert.verify(opt)
    println(&quot;Verify result: ${res}&quot;)
}

main() {
    /* 两个服务端证书 */
    let certs = getX509Cert(prefixPath + certFile)
    /* 两个根证书 */
    let roots = getX509Cert(prefixPath + rootFile)
    /* 三个中间证书 */
    let middles = getX509Cert(prefixPath + middleFile)
    /* 验证有效期 */
    testVerifyByTime(certs[0], [roots[0]], [middles[0]])
    /* 验证 DNS 域名 */
    testVerifyByDNS(certs[0])

    /* 根据根证书和中间证书验证其有效性 */
    /* cert0 &lt;- root0: false */
    testVerify(certs[0], [roots[0]], [])
    /* cert0 &lt;- middle0 &lt;- root0: true */
    testVerify(certs[0], [roots[0]], [middles[0]])
    /* cert0 &lt;- (middle0, middle1, middle2) &lt;- (root0, root1) : true */
    testVerify(certs[0], roots, middles)
    /* cert1 &lt;- middle0 &lt;- root0: false */
    testVerify(certs[1], [roots[0]], [middles[0]])
    /* cert1 &lt;- middle2 &lt;- root1: true */
    testVerify(certs[1], [roots[1]], [middles[2]])
    /* cert1 &lt;- (middle0, middle1, middle2) &lt;- (root0, root1) : true */
    testVerify(certs[1], roots, middles)
    return 0
}
</code></pre>
<h2 id="创建解析证书"><a class="header" href="#创建解析证书">创建、解析证书</a></h2>
<blockquote>
<p><strong>说明：</strong></p>
<p>需要自行准备根证书文件。</p>
</blockquote>
<p>示例：</p>
<!-- compile -->
<pre><code class="language-cangjie">import std.fs.*
import stdx.crypto.x509.*
import std.time.*
import std.io.*

main() {
    let x509Name = X509Name(
        countryName: &quot;CN&quot;,
        provinceName: &quot;beijing&quot;,
        localityName: &quot;haidian&quot;,
        organizationName: &quot;organization&quot;,
        organizationalUnitName: &quot;organization unit&quot;,
        commonName: &quot;x509&quot;,
        email: &quot;test@email.com&quot;
    )
    let serialNumber = SerialNumber(length: 20)
    let startTime: DateTime = DateTime.now()
    let endTime: DateTime = startTime.addYears(1)
    let ip1: IP = [8, 8, 8, 8]
    let ip2: IP = [0, 1, 0, 1, 0, 1, 0, 1, 0, 8, 0, 8, 0, 8, 0, 8]
    let parentCertPem = String.fromUtf8(readToEnd(File(&quot;./certificate.pem&quot;, Read)))
    let parentCert = X509Certificate.decodeFromPem(parentCertPem)[0]
    let parentKeyPem = String.fromUtf8(readToEnd(File(&quot;./rsa_private_key.pem&quot;, Read)))
    let parentPrivateKey = PrivateKey.decodeFromPem(parentKeyPem)
    let usrKeyPem = String.fromUtf8(readToEnd(File(&quot;./ecdsa_public_key.pem&quot;, Read)))
    let usrPublicKey = PublicKey.decodeFromPem(usrKeyPem)

    let certInfo = X509CertificateInfo(serialNumber: serialNumber, notBefore: startTime, notAfter: endTime,
        subject: x509Name, dnsNames: [&quot;b.com&quot;], IPAddresses: [ip1, ip2]);
    let cert = X509Certificate(certInfo, parent: parentCert, publicKey: usrPublicKey, privateKey: parentPrivateKey)

    println(cert)
    println(&quot;Serial Number: ${cert.serialNumber}&quot;)
    println(&quot;Issuer: ${cert.issuer}&quot;)
    println(&quot;Subject: ${cert.subject}&quot;)
    println(&quot;NotBefore: ${cert.notBefore}&quot;)
    println(&quot;NotAfter: ${cert.notAfter}&quot;)
    println(cert.signatureAlgorithm)
    println(&quot;DNSNames: ${cert.dnsNames}&quot;)
    println(&quot;IPAddresses: ${cert.IPAddresses}&quot;)

    return 0
}
</code></pre>
<h2 id="创建解析证书签名请求"><a class="header" href="#创建解析证书签名请求">创建、解析证书签名请求</a></h2>
<blockquote>
<p><strong>说明：</strong></p>
<p>需要自行准备私钥等文件。</p>
</blockquote>
<p>示例：</p>
<!-- compile -->
<pre><code class="language-cangjie">import std.fs.*
import std.io.*
import stdx.crypto.x509.*

main() {
    let x509Name = X509Name(
        countryName: &quot;CN&quot;,
        provinceName: &quot;beijing&quot;,
        localityName: &quot;haidian&quot;,
        organizationName: &quot;organization&quot;,
        organizationalUnitName: &quot;organization unit&quot;,
        commonName: &quot;x509&quot;,
        email: &quot;test@email.com&quot;
    )
    let ip1: IP = [8, 8, 8, 8]
    let ip2: IP = [0, 1, 0, 1, 0, 1, 0, 1, 0, 8, 0, 8, 0, 8, 0, 8]
    let rsaPem = String.fromUtf8(readToEnd(File(&quot;./rsa_private_key.pem&quot;, Read)))
    let rsa = PrivateKey.decodeFromPem(rsaPem)

    let csrInfo = X509CertificateRequestInfo(subject: x509Name, dnsNames: [&quot;b.com&quot;], IPAddresses: [ip1, ip2]);
    let csr = X509CertificateRequest(rsa, certificateRequestInfo: csrInfo, signatureAlgorithm: SHA256WithRSA)

    println(&quot;Subject: ${csr.subject.toString()}&quot;)
    println(&quot;IPAddresses: ${csr.IPAddresses}&quot;)
    println(&quot;dnsNames: ${csr.dnsNames}&quot;)

    return 0
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdxencodingbase64"><a class="header" href="#stdxencodingbase64">stdx.encoding.base64</a></h1>
<h2 id="功能介绍-5"><a class="header" href="#功能介绍-5">功能介绍</a></h2>
<p>base 包提供字符串的 Base64 编码及解码。</p>
<p>Base64 编码能够将二进制数据转换成仅由 64 个可打印的字符（A-Z、a-z、0-9、+、/）组成的文本格式，这使得二进制数据能够在文本环境中安全传输和存储。</p>
<h2 id="api-列表-5"><a class="header" href="#api-列表-5">API 列表</a></h2>
<h3 id="函数"><a class="header" href="#函数">函数</a></h3>
<div class="table-wrapper"><table><thead><tr><th>函数名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="encoding/base64/./base64_package_api/base64_package_funcs.html#func-frombase64stringstring">fromBase64String(String)</a></td><td>用于 Base64 编码的字符串的解码。</td></tr>
<tr><td><a href="encoding/base64/./base64_package_api/base64_package_funcs.html#func-tobase64stringarraybyte">toBase64String(Array&lt;Byte&gt;)</a></td><td>用于将字符数组转换成 Base64 编码的字符串。</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="函数-1"><a class="header" href="#函数-1">函数</a></h1>
<h2 id="func-frombase64stringstring"><a class="header" href="#func-frombase64stringstring">func fromBase64String(String)</a></h2>
<pre><code class="language-cangjie">public func fromBase64String(data: String): Option&lt;Array&lt;Byte&gt;&gt;
</code></pre>
<p>功能：此函数用于 Base64 编码的字符串的解码。</p>
<p>参数：</p>
<ul>
<li>data: String - 要解码的 Base64 编码的字符串。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Option&lt;Array&lt;Byte&gt;&gt; - 输入空字符串会返回 Option&lt;Array&lt;Byte&gt;&gt;.Some(Array&lt;Byte&gt;())，解码失败会返回 Option&lt;Array&lt;Byte&gt;&gt;.None。</li>
</ul>
<h2 id="func-tobase64stringarraybyte"><a class="header" href="#func-tobase64stringarraybyte">func toBase64String(Array&lt;Byte&gt;)</a></h2>
<pre><code class="language-cangjie">public func toBase64String(data: Array&lt;Byte&gt;): String
</code></pre>
<p>功能：此函数用于将 Byte 数组转换成 Base64 编码的字符串。</p>
<p>参数：</p>
<ul>
<li>data: Array&lt;Byte&gt; - 要编码的 Byte 数组。</li>
</ul>
<p>返回值：</p>
<ul>
<li>String - 返回编码后的字符串。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="byte-数组和-base64-互转"><a class="header" href="#byte-数组和-base64-互转">Byte 数组和 Base64 互转</a></h1>
<p>示例：</p>
<!-- verify -->
<pre><code class="language-cangjie">import stdx.encoding.base64.*

main(): Int64 {
    var arr: Array&lt;Byte&gt; = [77, 97, 110]
    var str = toBase64String(arr)
    print(&quot;${str},&quot;)
    var opArr: Option&lt;Array&lt;Byte&gt;&gt; = fromBase64String(str)
    var arr2: Array&lt;Byte&gt; = match (opArr) {
        case Some(s) =&gt; s
        case None =&gt; Array&lt;Byte&gt;()
    }
    for (i in 0..arr2.size) {
        print(&quot;${arr2[i]},&quot;)
    }
    return 0
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-text">TWFu,77,97,110,
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdxencodinghex"><a class="header" href="#stdxencodinghex">stdx.encoding.hex</a></h1>
<h2 id="功能介绍-6"><a class="header" href="#功能介绍-6">功能介绍</a></h2>
<p>hex 包提供字符串的 Hex 编码及解码。</p>
<p>Hex 编码（也称为十六进制编码）是一种将数据转换为十六进制表示形式的编码方法。Hex 编码使用 16 个字符来表示数据，这 16 个字符分别是 0-9 的数字和 A-F 的字母（不区分大小写，即 a-f 和 A-F 是等价的）。</p>
<h2 id="api-列表-6"><a class="header" href="#api-列表-6">API 列表</a></h2>
<h3 id="函数-2"><a class="header" href="#函数-2">函数</a></h3>
<div class="table-wrapper"><table><thead><tr><th>函数名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="encoding/hex/./hex_package_api/hex_package_funcs.html#func-fromhexstringstring">fromHexString(String)</a></td><td>用于 Hex 编码的字符串的解码。</td></tr>
<tr><td><a href="encoding/hex/./hex_package_api/hex_package_funcs.html#func-tohexstringarraybyte">toHexString(Array&lt;Byte&gt;)</a></td><td>用于将字符数组转换成 Hex 编码的字符串。</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="函数-3"><a class="header" href="#函数-3">函数</a></h1>
<h2 id="func-fromhexstringstring"><a class="header" href="#func-fromhexstringstring">func fromHexString(String)</a></h2>
<pre><code class="language-cangjie">public func fromHexString(data: String): Option&lt;Array&lt;Byte&gt;&gt;
</code></pre>
<p>功能：此函数用于 Hex 编码的字符串的解码。</p>
<p>参数：</p>
<ul>
<li>data: String - 要解码的 Hex 编码的字符串。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Option&lt;Array&lt;Byte&gt;&gt; - 输入空字符串会返回 Option&lt;Array&lt;Byte&gt;&gt;.Some(Array&lt;Byte&gt;())，解码失败会返回 Option&lt;Array&lt;Byte&gt;&gt;.None。</li>
</ul>
<h2 id="func-tohexstringarraybyte"><a class="header" href="#func-tohexstringarraybyte">func toHexString(Array&lt;Byte&gt;)</a></h2>
<pre><code class="language-cangjie">public func toHexString(data: Array&lt;Byte&gt;): String
</code></pre>
<p>功能：此函数用于将 Byte 数组转换成 Hex 编码的字符串。</p>
<p>参数：</p>
<ul>
<li>data: Array&lt;Byte&gt; - 要编码的 Byte 数组。</li>
</ul>
<p>返回值：</p>
<ul>
<li>String - 返回编码后的字符串。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="byte-数组和-hex-互转"><a class="header" href="#byte-数组和-hex-互转">Byte 数组和 Hex 互转</a></h1>
<p>示例：</p>
<!-- verify -->
<pre><code class="language-cangjie">import stdx.encoding.hex.*

main(): Int64 {
    var arr: Array&lt;Byte&gt; = [65, 66, 94, 97]
    var str = toHexString(arr)
    print(&quot;${str},&quot;)
    var opArr: Option&lt;Array&lt;Byte&gt;&gt; = fromHexString(str)
    var arr2: Array&lt;Byte&gt; = match (opArr) {
        case Some(s) =&gt; s
        case None =&gt; Array&lt;Byte&gt;()
    }
    for (i in 0..arr2.size) {
        print(&quot;${arr2[i]},&quot;)
    }
    return 0
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-text">41425e61,65,66,94,97,
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdxencodingjson"><a class="header" href="#stdxencodingjson">stdx.encoding.json</a></h1>
<h2 id="功能介绍-7"><a class="header" href="#功能介绍-7">功能介绍</a></h2>
<p>json 包用于对 JSON 数据的处理，实现 String, JsonValue, DataModel 之间的相互转换。</p>
<p>JsonValue 是对 JSON 数据格式的封装，包括 object, array, string, number, true, false 和 null。</p>
<p>DataModel 详细信息可参考：<a href="encoding/json/../../serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">serialization 包文档</a>。</p>
<p>JSON 语法规则可参考：<a href="https://www.json.org/json-zh.html">介绍 JSON</a>。</p>
<p>JSON 数据转换标准可参考：<a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-404/">ECMA-404 The JSON Data Interchange Standard</a>。</p>
<h2 id="api-列表-7"><a class="header" href="#api-列表-7">API 列表</a></h2>
<h3 id="接口-2"><a class="header" href="#接口-2">接口</a></h3>
<div class="table-wrapper"><table><thead><tr><th>接口名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="encoding/json/./json_package_api/encoding_json_package_interfaces.html#interface-tojson">ToJson</a></td><td>用于实现 JsonValue 和 DataModel 的相互转换。</td></tr>
</tbody></table>
</div>
<h3 id="类-9"><a class="header" href="#类-9">类</a></h3>
<div class="table-wrapper"><table><thead><tr><th>类名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="encoding/json/./json_package_api/encoding_json_package_classes.html#class-jsonarray">JsonArray</a></td><td>创建空 JsonArray。</td></tr>
<tr><td><a href="encoding/json/./json_package_api/encoding_json_package_classes.html#class-jsonbool">JsonBool</a></td><td>将指定的 Bool 类型实例封装成 JsonBool 实例。</td></tr>
<tr><td><a href="encoding/json/./json_package_api/encoding_json_package_classes.html#class-jsonfloat">JsonFloat</a></td><td>将指定的 Float64 类型实例封装成 JsonFloat 实例。</td></tr>
<tr><td><a href="encoding/json/./json_package_api/encoding_json_package_classes.html#class-jsonint">JsonInt</a></td><td>将指定的 Int64 类型实例封装成 JsonInt 实例。</td></tr>
<tr><td><a href="encoding/json/./json_package_api/encoding_json_package_classes.html#class-jsonnull">JsonNull</a></td><td>将 JsonNull 转换为字符串。</td></tr>
<tr><td><a href="encoding/json/./json_package_api/encoding_json_package_classes.html#class-jsonobject">JsonObject</a></td><td>创建空 JsonObject。</td></tr>
<tr><td><a href="encoding/json/./json_package_api/encoding_json_package_classes.html#class-jsonstring">JsonString</a></td><td>将指定的 String 类型实例封装成 JsonString 实例。</td></tr>
<tr><td><a href="encoding/json/./json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a></td><td>此类为 JSON 数据层, 主要用于 JsonValue 和 String 数据之间的互相转换。</td></tr>
</tbody></table>
</div>
<h3 id="枚举-6"><a class="header" href="#枚举-6">枚举</a></h3>
<div class="table-wrapper"><table><thead><tr><th>枚举名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="encoding/json/./json_package_api/encoding_json_package_enums.html#enum-jsonkind">JsonKind</a></td><td>表示 JsonValue 的具体类型。</td></tr>
</tbody></table>
</div>
<h3 id="异常类-8"><a class="header" href="#异常类-8">异常类</a></h3>
<div class="table-wrapper"><table><thead><tr><th>异常类名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="encoding/json/./json_package_api/encoding_json_package_exceptions.html#class-jsonexception">JsonException</a></td><td>用于 JsonValue 类型使用时出现异常的场景。</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="接口-3"><a class="header" href="#接口-3">接口</a></h1>
<h2 id="interface-tojson"><a class="header" href="#interface-tojson">interface ToJson</a></h2>
<pre><code class="language-cangjie">public interface ToJson {
    static func fromJson(jv: JsonValue): DataModel
    func toJson(): JsonValue
}
</code></pre>
<p>功能：用于实现 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a> 和 <a href="encoding/json/json_package_api/../../../serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> 的相互转换。</p>
<h3 id="static-func-fromjsonjsonvalue"><a class="header" href="#static-func-fromjsonjsonvalue">static func fromJson(JsonValue)</a></h3>
<pre><code class="language-cangjie">static func fromJson(jv: JsonValue): DataModel
</code></pre>
<p>功能：将 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a> 转化为对象 <a href="encoding/json/json_package_api/../../../serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a>。</p>
<p>参数：</p>
<ul>
<li>jv: <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a> - 待转换的 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a>。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="encoding/json/json_package_api/../../../serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 转换后的 <a href="encoding/json/json_package_api/../../../serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a>。</li>
</ul>
<h3 id="func-tojson"><a class="header" href="#func-tojson">func toJson()</a></h3>
<pre><code class="language-cangjie">func toJson(): JsonValue
</code></pre>
<p>功能：将自身转化为 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a>。</p>
<p>返回值：</p>
<ul>
<li><a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a> - 转换后的 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a>。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="encoding/json/json_package_api/encoding_json_package_exceptions.html#class-jsonexception">JsonException</a> - 如果转换失败，抛出异常。</li>
</ul>
<h3 id="extend-datamodel--tojson"><a class="header" href="#extend-datamodel--tojson">extend DataModel &lt;: ToJson</a></h3>
<pre><code class="language-cangjie">extend DataModel &lt;: ToJson
</code></pre>
<p>功能：为 <a href="encoding/json/json_package_api/../../../serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> 类型实现 ToJson 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json/json_package_api/encoding_json_package_interfaces.html#interface-tojson">ToJson</a></li>
</ul>
<h4 id="static-func-fromjsonjsonvalue-1"><a class="header" href="#static-func-fromjsonjsonvalue-1">static func fromJson(JsonValue)</a></h4>
<pre><code class="language-cangjie">public static func fromJson(jv: JsonValue): DataModel
</code></pre>
<p>功能：将 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a> 转化为对象 <a href="encoding/json/json_package_api/../../../serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a>。</p>
<p>参数：</p>
<ul>
<li>jv: <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a> - 待转换的 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a>。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="encoding/json/json_package_api/../../../serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 转换后的 <a href="encoding/json/json_package_api/../../../serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a>。</li>
</ul>
<h4 id="func-tojson-1"><a class="header" href="#func-tojson-1">func toJson()</a></h4>
<pre><code class="language-cangjie">public func toJson(): JsonValue
</code></pre>
<p>功能：将自身转化为 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a>。</p>
<p>返回值：</p>
<ul>
<li><a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a> - 转换后的 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a>。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="encoding/json/json_package_api/encoding_json_package_exceptions.html#class-jsonexception">JsonException</a> - 如果转换失败，抛出异常。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类-10"><a class="header" href="#类-10">类</a></h1>
<h2 id="class-jsonarray"><a class="header" href="#class-jsonarray">class JsonArray</a></h2>
<pre><code class="language-cangjie">public class JsonArray &lt;: JsonValue {
    public init()
    public init(list: ArrayList&lt;JsonValue&gt;)
    public init(list: Array&lt;JsonValue&gt;)
}
</code></pre>
<p>功能：此类为 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a> 实现子类，主要用于封装数组类型的 JSON 数据。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a></li>
</ul>
<p>示例：</p>
<p>使用示例见 <a href="encoding/json/json_package_api/../json_samples/json_array_sample.html">JsonArray 使用示例</a>。</p>
<h3 id="init-11"><a class="header" href="#init-11">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：创建空 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonarray">JsonArray</a>。</p>
<h3 id="initarraylistjsonvalue"><a class="header" href="#initarraylistjsonvalue">init(ArrayList&lt;JsonValue&gt;)</a></h3>
<pre><code class="language-cangjie">public init(list: ArrayList&lt;JsonValue&gt;)
</code></pre>
<p>功能：将指定的 ArrayList 类型实例封装成 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonarray">JsonArray</a> 实例。</p>
<p>参数：</p>
<ul>
<li>list: ArrayList&lt;<a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a>&gt; - 用于创建 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonarray">JsonArray</a> 的 ArrayList。</li>
</ul>
<h3 id="initarrayjsonvalue"><a class="header" href="#initarrayjsonvalue">init(Array&lt;JsonValue&gt;)</a></h3>
<pre><code class="language-cangjie">public init(list: Array&lt;JsonValue&gt;)
</code></pre>
<p>功能：将指定的 Array 类型实例封装成 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonarray">JsonArray</a> 实例。</p>
<p>参数：</p>
<ul>
<li>list: Array&lt;<a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a>&gt; - 用于创建 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonarray">JsonArray</a> 的 Array。</li>
</ul>
<h3 id="func-addjsonvalue"><a class="header" href="#func-addjsonvalue">func add(JsonValue)</a></h3>
<pre><code class="language-cangjie">public func add(jv: JsonValue): JsonArray
</code></pre>
<p>功能：向 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonarray">JsonArray</a> 中加入 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a> 数据。</p>
<p>参数：</p>
<ul>
<li>jv: <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a> - 需要加入的 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a>。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonarray">JsonArray</a> - 加入数据后的 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonarray">JsonArray</a>。</li>
</ul>
<h3 id="func-getint64"><a class="header" href="#func-getint64">func get(Int64)</a></h3>
<pre><code class="language-cangjie">public func get(index: Int64): Option&lt;JsonValue&gt;
</code></pre>
<p>功能：获取 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonarray">JsonArray</a> 中指定索引的 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a>，并用 Option&lt;<a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a>&gt; 封装。</p>
<p>参数：</p>
<ul>
<li>index: Int64 - 指定的索引。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Option&lt;<a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a>&gt; - 对应索引的 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a> 数据的封装形式。</li>
</ul>
<h3 id="func-getitems"><a class="header" href="#func-getitems">func getItems()</a></h3>
<pre><code class="language-cangjie">public func getItems(): ArrayList&lt;JsonValue&gt;
</code></pre>
<p>功能：获取 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonarray">JsonArray</a> 中的 items 数据。</p>
<p>返回值：</p>
<ul>
<li>ArrayList&lt;<a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a>&gt; - <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonarray">JsonArray</a> 的 items 数据。</li>
</ul>
<h3 id="func-kind"><a class="header" href="#func-kind">func kind()</a></h3>
<pre><code class="language-cangjie">public func kind(): JsonKind
</code></pre>
<p>功能：返回当前 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonarray">JsonArray</a> 所属的 <a href="encoding/json/json_package_api/encoding_json_package_enums.html#enum-jsonkind">JsonKind</a> 类型（JsArray）。</p>
<p>返回值：</p>
<ul>
<li><a href="encoding/json/json_package_api/encoding_json_package_enums.html#enum-jsonkind">JsonKind</a> - 当前 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonarray">JsonArray</a> 所属的 <a href="encoding/json/json_package_api/encoding_json_package_enums.html#enum-jsonkind">JsonKind</a> 类型（JsArray）。</li>
</ul>
<h3 id="func-size"><a class="header" href="#func-size">func size()</a></h3>
<pre><code class="language-cangjie">public func size(): Int64
</code></pre>
<p>功能：获取 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonarray">JsonArray</a> 中 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a> 的数量。</p>
<p>返回值：</p>
<ul>
<li>Int64 - <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonarray">JsonArray</a> 中 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a> 的数量。</li>
</ul>
<h3 id="func-tojsonstring"><a class="header" href="#func-tojsonstring">func toJsonString()</a></h3>
<pre><code class="language-cangjie">public func toJsonString(): String
</code></pre>
<p>功能：将 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonarray">JsonArray</a> 转换为 JSON 格式的 (带有空格换行符) 的字符串。</p>
<p>返回值：</p>
<ul>
<li>String - 转换后的 JSON 格式字符串。</li>
</ul>
<h3 id="func-tojsonstringint64-bool-string"><a class="header" href="#func-tojsonstringint64-bool-string">func toJsonString(Int64, Bool, String)</a></h3>
<pre><code class="language-cangjie">public func toJsonString(depth: Int64, bracketInNewLine!: Bool = false, indent!: String = &quot;  &quot;): String
</code></pre>
<p>功能：将 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonarray">JsonArray</a> 转换为 JSON 格式的字符串。该函数将指定初始的缩进深度、第一个括号后是否换行以及缩进字符串。</p>
<p>参数：</p>
<ul>
<li>depth: Int64 - 指定的缩进深度。</li>
<li>bracketInNewLine!: Bool - 第一个括号是否换行，如果为 <code>true</code>，第一个括号将另起一行并且按照指定的深度缩进。</li>
<li>indent!: String - 指定的缩进字符串，缩进字符串中只允许空格和制表符的组合，默认为两个空格。</li>
</ul>
<p>返回值：</p>
<ul>
<li>String - 转换后的 JSON 格式字符串。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 如果 depth 为负数，或 indent 中存在 ' ' 和 '\t' 以外的字符，则抛出异常。</li>
</ul>
<h3 id="func-tostring-18"><a class="header" href="#func-tostring-18">func toString()</a></h3>
<pre><code class="language-cangjie">public func toString(): String
</code></pre>
<p>功能：将 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonstring">JsonString</a> 转换为字符串。</p>
<p>返回值：</p>
<ul>
<li>String - 转换后的字符串。</li>
</ul>
<h3 id="operator-func-int64"><a class="header" href="#operator-func-int64">operator func [](Int64)</a></h3>
<pre><code class="language-cangjie">public operator func [](index: Int64): JsonValue
</code></pre>
<p>功能：获取 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonarray">JsonArray</a> 中指定索引的 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a>。</p>
<p>参数：</p>
<ul>
<li>index: Int64 - 指定的索引。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a> - 对应索引的 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a>。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="encoding/json/json_package_api/encoding_json_package_exceptions.html#class-jsonexception">JsonException</a> - 如果 index 不是 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonarray">JsonArray</a> 的有效索引，抛出异常。</li>
</ul>
<h2 id="class-jsonbool"><a class="header" href="#class-jsonbool">class JsonBool</a></h2>
<pre><code class="language-cangjie">public class JsonBool &lt;: JsonValue {
    public init(bv: Bool)
}
</code></pre>
<p>功能：此类为 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a> 实现子类，主要用于封装 true 或者 false 的 JSON 数据。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a></li>
</ul>
<h3 id="initbool-1"><a class="header" href="#initbool-1">init(Bool)</a></h3>
<pre><code class="language-cangjie">public init(bv: Bool)
</code></pre>
<p>功能：将指定的 Bool 类型实例封装成 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonbool">JsonBool</a> 实例。</p>
<h3 id="func-getvalue"><a class="header" href="#func-getvalue">func getValue()</a></h3>
<pre><code class="language-cangjie">public func getValue(): Bool
</code></pre>
<p>功能：获取 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonbool">JsonBool</a> 中 value 的实际值。</p>
<p>返回值：</p>
<ul>
<li>Bool - value 的实际值。</li>
</ul>
<h3 id="func-kind-1"><a class="header" href="#func-kind-1">func kind()</a></h3>
<pre><code class="language-cangjie">public func kind(): JsonKind
</code></pre>
<p>功能：返回当前 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonbool">JsonBool</a> 所属的 <a href="encoding/json/json_package_api/encoding_json_package_enums.html#enum-jsonkind">JsonKind</a> 类型（JsBool）。</p>
<p>返回值：</p>
<ul>
<li><a href="encoding/json/json_package_api/encoding_json_package_enums.html#enum-jsonkind">JsonKind</a> - 当前 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonbool">JsonBool</a> 所属的 <a href="encoding/json/json_package_api/encoding_json_package_enums.html#enum-jsonkind">JsonKind</a> 类型（JsBool）。</li>
</ul>
<h3 id="func-tojsonstring-1"><a class="header" href="#func-tojsonstring-1">func toJsonString()</a></h3>
<pre><code class="language-cangjie">public func toJsonString(): String
</code></pre>
<p>功能：将 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonbool">JsonBool</a> 转换为 JSON 格式的 (带有空格换行符) 字符串。</p>
<p>返回值：</p>
<ul>
<li>String - 转换后的 JSON 格式字符串。</li>
</ul>
<h3 id="func-tostring-19"><a class="header" href="#func-tostring-19">func toString()</a></h3>
<pre><code class="language-cangjie">public func toString(): String
</code></pre>
<p>功能：将 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonbool">JsonBool</a> 转换为字符串。</p>
<p>返回值：</p>
<ul>
<li>String - 转换后的字符串。</li>
</ul>
<h2 id="class-jsonfloat"><a class="header" href="#class-jsonfloat">class JsonFloat</a></h2>
<pre><code class="language-cangjie">public class JsonFloat &lt;: JsonValue {
    public init(fv: Float64)
    public init(v: Int64)
}
</code></pre>
<p>功能：此类为 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a> 实现子类，主要用于封装浮点类型的 JSON 数据。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a></li>
</ul>
<h3 id="initfloat64"><a class="header" href="#initfloat64">init(Float64)</a></h3>
<pre><code class="language-cangjie">public init(fv: Float64)
</code></pre>
<p>功能：将指定的 Float64 类型实例封装成 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonfloat">JsonFloat</a> 实例。</p>
<p>参数：</p>
<ul>
<li>fv: Float64 - Float64 类型。</li>
</ul>
<h3 id="initint64"><a class="header" href="#initint64">init(Int64)</a></h3>
<pre><code class="language-cangjie">public init(v: Int64)
</code></pre>
<p>功能：将指定的 Int64 类型实例封装成 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonfloat">JsonFloat</a> 实例。</p>
<p>参数：</p>
<ul>
<li>v: Int64 - Int64 类型。</li>
</ul>
<h3 id="func-getvalue-1"><a class="header" href="#func-getvalue-1">func getValue()</a></h3>
<pre><code class="language-cangjie">public func getValue(): Float64
</code></pre>
<p>功能：获取 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonfloat">JsonFloat</a> 中 value 的实际值。</p>
<p>返回值：</p>
<ul>
<li>Float64 - value 的实际值。</li>
</ul>
<h3 id="func-kind-2"><a class="header" href="#func-kind-2">func kind()</a></h3>
<pre><code class="language-cangjie">public func kind(): JsonKind
</code></pre>
<p>功能：返回当前 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonfloat">JsonFloat</a> 所属的 <a href="encoding/json/json_package_api/encoding_json_package_enums.html#enum-jsonkind">JsonKind</a> 类型（JsFloat）。</p>
<p>返回值：</p>
<ul>
<li><a href="encoding/json/json_package_api/encoding_json_package_enums.html#enum-jsonkind">JsonKind</a> - 当前 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonfloat">JsonFloat</a> 所属的 <a href="encoding/json/json_package_api/encoding_json_package_enums.html#enum-jsonkind">JsonKind</a> 类型（JsFloat）。</li>
</ul>
<h3 id="func-tojsonstring-2"><a class="header" href="#func-tojsonstring-2">func toJsonString()</a></h3>
<pre><code class="language-cangjie">public func toJsonString(): String
</code></pre>
<p>功能：将 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonfloat">JsonFloat</a> 转换为 JSON 格式的 (带有空格换行符) 字符串。</p>
<p>返回值：</p>
<ul>
<li>String - 转换后的 JSON 格式字符串。</li>
</ul>
<h3 id="func-tostring-20"><a class="header" href="#func-tostring-20">func toString()</a></h3>
<pre><code class="language-cangjie">public func toString(): String
</code></pre>
<p>功能：将 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonfloat">JsonFloat</a> 转换为字符串。</p>
<p>返回值：</p>
<ul>
<li>String - 转换后的字符串。</li>
</ul>
<h2 id="class-jsonint"><a class="header" href="#class-jsonint">class JsonInt</a></h2>
<pre><code class="language-cangjie">public class JsonInt &lt;: JsonValue {
    public init(iv: Int64)
}
</code></pre>
<p>功能：此类为 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a> 实现子类，主要用于封装整数类型的 JSON 数据。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a></li>
</ul>
<h3 id="initint64-1"><a class="header" href="#initint64-1">init(Int64)</a></h3>
<pre><code class="language-cangjie">public init(iv: Int64)
</code></pre>
<p>功能：将指定的 Int64 类型实例封装成 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonint">JsonInt</a> 实例。</p>
<p>参数：</p>
<ul>
<li>iv: Int64 - 用于创建 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonint">JsonInt</a> 的 Int64。</li>
</ul>
<h3 id="func-getvalue-2"><a class="header" href="#func-getvalue-2">func getValue()</a></h3>
<pre><code class="language-cangjie">public func getValue(): Int64
</code></pre>
<p>功能：获取 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonint">JsonInt</a> 中 value 的实际值。</p>
<p>返回值：</p>
<ul>
<li>Int64 - value 的实际值。</li>
</ul>
<h3 id="func-kind-3"><a class="header" href="#func-kind-3">func kind()</a></h3>
<pre><code class="language-cangjie">public func kind(): JsonKind
</code></pre>
<p>功能：返回当前 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonint">JsonInt</a> 所属的 <a href="encoding/json/json_package_api/encoding_json_package_enums.html#enum-jsonkind">JsonKind</a> 类型（JsInt）。</p>
<p>返回值：</p>
<ul>
<li><a href="encoding/json/json_package_api/encoding_json_package_enums.html#enum-jsonkind">JsonKind</a> - 当前 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonint">JsonInt</a> 所属的 <a href="encoding/json/json_package_api/encoding_json_package_enums.html#enum-jsonkind">JsonKind</a> 类型（JsInt）。</li>
</ul>
<h3 id="func-tojsonstring-3"><a class="header" href="#func-tojsonstring-3">func toJsonString()</a></h3>
<pre><code class="language-cangjie">public func toJsonString(): String
</code></pre>
<p>功能：将 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonint">JsonInt</a> 转换为 JSON 格式的 (带有空格换行符) 字符串。</p>
<p>返回值：</p>
<ul>
<li>String - 转换后的 JSON 格式字符串。</li>
</ul>
<h3 id="func-tostring-21"><a class="header" href="#func-tostring-21">func toString()</a></h3>
<pre><code class="language-cangjie">public func toString(): String
</code></pre>
<p>功能：将 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonint">JsonInt</a> 转换为字符串。</p>
<p>返回值：</p>
<ul>
<li>String - 转换后的字符串。</li>
</ul>
<h2 id="class-jsonnull"><a class="header" href="#class-jsonnull">class JsonNull</a></h2>
<pre><code class="language-cangjie">public class JsonNull &lt;: JsonValue
</code></pre>
<p>功能：此类为 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a> 实现子类，主要用于封装 null 的 JSON 数据。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a></li>
</ul>
<h3 id="func-kind-4"><a class="header" href="#func-kind-4">func kind()</a></h3>
<pre><code class="language-cangjie">public func kind(): JsonKind
</code></pre>
<p>功能：返回当前 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonnull">JsonNull</a> 所属的 <a href="encoding/json/json_package_api/encoding_json_package_enums.html#enum-jsonkind">JsonKind</a> 类型（JsNull）。</p>
<p>返回值：</p>
<ul>
<li><a href="encoding/json/json_package_api/encoding_json_package_enums.html#enum-jsonkind">JsonKind</a> - 当前 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonnull">JsonNull</a> 所属的 <a href="encoding/json/json_package_api/encoding_json_package_enums.html#enum-jsonkind">JsonKind</a> 类型（JsNull）。</li>
</ul>
<h3 id="func-tojsonstring-4"><a class="header" href="#func-tojsonstring-4">func toJsonString()</a></h3>
<pre><code class="language-cangjie">public func toJsonString(): String
</code></pre>
<p>功能：将 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonnull">JsonNull</a> 转换为 JSON 格式的 (带有空格换行符) 字符串。</p>
<p>返回值：</p>
<ul>
<li>String - 转换后的 JSON 格式字符串。</li>
</ul>
<h3 id="func-tostring-22"><a class="header" href="#func-tostring-22">func toString()</a></h3>
<pre><code class="language-cangjie">public func toString(): String
</code></pre>
<p>功能：将 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonnull">JsonNull</a> 转换为字符串。</p>
<p>返回值：</p>
<ul>
<li>String - 转换后的字符串。</li>
</ul>
<h2 id="class-jsonobject"><a class="header" href="#class-jsonobject">class JsonObject</a></h2>
<pre><code class="language-cangjie">public class JsonObject &lt;: JsonValue {
    public init()
    public init(map: HashMap&lt;String, JsonValue&gt;)
}
</code></pre>
<p>功能：此类为 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a> 实现子类，主要用于封装 object 类型的 JSON 数据。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a></li>
</ul>
<h3 id="init-12"><a class="header" href="#init-12">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：创建空 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonobject">JsonObject</a>。</p>
<h3 id="inithashmapstring-jsonvalue"><a class="header" href="#inithashmapstring-jsonvalue">init(HashMap&lt;String, JsonValue&gt;)</a></h3>
<pre><code class="language-cangjie">public init(map: HashMap&lt;String, JsonValue&gt;)
</code></pre>
<p>功能：将指定的 HashMap 类型实例封装成 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonobject">JsonObject</a> 实例。</p>
<h3 id="func-containskeystring"><a class="header" href="#func-containskeystring">func containsKey(String)</a></h3>
<pre><code class="language-cangjie">public func containsKey(key: String): Bool
</code></pre>
<p>功能：判断 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonobject">JsonObject</a> 中是否存在 key。</p>
<p>参数：</p>
<ul>
<li>key: String - 指定的 key。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - 存在返回 true，不存在返回 false。</li>
</ul>
<h3 id="func-getstring"><a class="header" href="#func-getstring">func get(String)</a></h3>
<pre><code class="language-cangjie">public func get(key: String): Option&lt;JsonValue&gt;
</code></pre>
<p>功能：获取 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonobject">JsonObject</a> 中 key 对应的 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a>，并用 Option&lt;<a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a>&gt; 封装。</p>
<p>参数：</p>
<ul>
<li>key: String - 指定的 key。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Option&lt;<a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a>&gt; - key 对应的 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a> 的封装形式。</li>
</ul>
<h3 id="func-getfields"><a class="header" href="#func-getfields">func getFields()</a></h3>
<pre><code class="language-cangjie">public func getFields(): HashMap&lt;String, JsonValue&gt;
</code></pre>
<p>功能：获取 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonobject">JsonObject</a> 中的 fields 数据。</p>
<p>返回值：</p>
<ul>
<li>HashMap&lt;String, <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a>&gt; - <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonobject">JsonObject</a> 的 fields 数据。</li>
</ul>
<h3 id="func-kind-5"><a class="header" href="#func-kind-5">func kind()</a></h3>
<pre><code class="language-cangjie">public func kind(): JsonKind
</code></pre>
<p>功能：返回当前 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonobject">JsonObject</a> 所属的 <a href="encoding/json/json_package_api/encoding_json_package_enums.html#enum-jsonkind">JsonKind</a> 类型（JsObject）。</p>
<p>返回值：</p>
<ul>
<li><a href="encoding/json/json_package_api/encoding_json_package_enums.html#enum-jsonkind">JsonKind</a> - 当前 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonobject">JsonObject</a> 所属的 <a href="encoding/json/json_package_api/encoding_json_package_enums.html#enum-jsonkind">JsonKind</a> 类型（JsObject）。</li>
</ul>
<h3 id="func-putstring-jsonvalue"><a class="header" href="#func-putstring-jsonvalue">func put(String, JsonValue)</a></h3>
<pre><code class="language-cangjie">public func put(key: String, v: JsonValue): Unit
</code></pre>
<p>功能：向 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonobject">JsonObject</a> 中加入 key-<a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a> 数据。</p>
<p>参数：</p>
<ul>
<li>key: String - 需要加入的 key。</li>
<li>v: <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a> - 对应 key 的 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a>。</li>
</ul>
<h3 id="func-size-1"><a class="header" href="#func-size-1">func size()</a></h3>
<pre><code class="language-cangjie">public func size(): Int64
</code></pre>
<p>功能：获取 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonobject">JsonObject</a> 中 fields 存入 string-<a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a> 的数量。</p>
<p>返回值：</p>
<ul>
<li>Int64 - <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonobject">JsonObject</a> 中 fields 的大小。</li>
</ul>
<h3 id="func-tojsonstring-5"><a class="header" href="#func-tojsonstring-5">func toJsonString()</a></h3>
<pre><code class="language-cangjie">public func toJsonString(): String
</code></pre>
<p>功能：将 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonobject">JsonObject</a> 转换为 JSON 格式的 (带有空格换行符) 字符串。</p>
<p>返回值：</p>
<ul>
<li>String - 转换后的 JSON 格式字符串。</li>
</ul>
<h3 id="func-tojsonstringint64-bool-string-1"><a class="header" href="#func-tojsonstringint64-bool-string-1">func toJsonString(Int64, Bool, String)</a></h3>
<pre><code class="language-cangjie">public func toJsonString(depth: Int64, bracketInNewLine!: Bool = false, indent!: String = &quot;  &quot;): String
</code></pre>
<p>功能：将 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonobject">JsonObject</a> 转换为 Json格式的字符串。该函数将指定初始的缩进深度、第一个括号后是否换行以及缩进字符串。</p>
<p>参数：</p>
<ul>
<li>depth: Int64 - 缩进深度。</li>
<li>bracketInNewLine!: Bool - 第一个括号是否换行，如果为 <code>true</code>，第一个括号将另起一行并且按照指定的深度缩进。</li>
<li>indent!: String - 指定的缩进字符串，缩进字符串中只允许空格和制表符的组合，默认为两个空格。</li>
</ul>
<p>返回值：</p>
<ul>
<li>String - 转换后的 JSON 格式字符串。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 如果 depth 为负数，或 indent 中存在 ' ' 和 '\t' 以外的字符，则抛出异常。</li>
</ul>
<h3 id="func-tostring-23"><a class="header" href="#func-tostring-23">func toString()</a></h3>
<pre><code class="language-cangjie">public func toString(): String
</code></pre>
<p>功能：将 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonobject">JsonObject</a> 转换为字符串。</p>
<p>返回值：</p>
<ul>
<li>String - 转换后的字符串。</li>
</ul>
<h3 id="operator-func-string"><a class="header" href="#operator-func-string">operator func [](String)</a></h3>
<pre><code class="language-cangjie">public operator func [](key: String): JsonValue
</code></pre>
<p>功能：获取 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonobject">JsonObject</a> 中 key 对应的 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a>。</p>
<p>参数：</p>
<ul>
<li>key: String - 指定的 key。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a> - key 对应的 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a>。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="encoding/json/json_package_api/encoding_json_package_exceptions.html#class-jsonexception">JsonException</a> - 如果 key 不是 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonobject">JsonObject</a> 的有效键，抛出异常。</li>
</ul>
<h2 id="class-jsonstring"><a class="header" href="#class-jsonstring">class JsonString</a></h2>
<pre><code class="language-cangjie">public class JsonString &lt;: JsonValue {
    public init(sv: String)
}
</code></pre>
<p>功能：此类为 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a> 实现子类，主要用于封装字符串类型的 JSON 数据。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a></li>
</ul>
<h3 id="initstring-4"><a class="header" href="#initstring-4">init(String)</a></h3>
<pre><code class="language-cangjie">public init(sv: String)
</code></pre>
<p>功能：将指定的 String 类型实例封装成 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonstring">JsonString</a> 实例。</p>
<h3 id="func-getvalue-3"><a class="header" href="#func-getvalue-3">func getValue()</a></h3>
<pre><code class="language-cangjie">public func getValue(): String
</code></pre>
<p>功能：获取 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonstring">JsonString</a> 中 value 的实际值。</p>
<p>返回值：</p>
<ul>
<li>String - value 的实际值。</li>
</ul>
<h3 id="func-kind-6"><a class="header" href="#func-kind-6">func kind()</a></h3>
<pre><code class="language-cangjie">public func kind(): JsonKind
</code></pre>
<p>功能：返回当前 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonstring">JsonString</a> 所属的 <a href="encoding/json/json_package_api/encoding_json_package_enums.html#enum-jsonkind">JsonKind</a> 类型（JsString）。</p>
<p>返回值：</p>
<ul>
<li><a href="encoding/json/json_package_api/encoding_json_package_enums.html#enum-jsonkind">JsonKind</a> - 当前 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonstring">JsonString</a> 所属的 <a href="encoding/json/json_package_api/encoding_json_package_enums.html#enum-jsonkind">JsonKind</a> 类型（JsString）。</li>
</ul>
<h3 id="func-tojsonstring-6"><a class="header" href="#func-tojsonstring-6">func toJsonString()</a></h3>
<pre><code class="language-cangjie">public func toJsonString(): String
</code></pre>
<p>功能：将 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonstring">JsonString</a> 转换为 JSON 格式的 (带有空格换行符) 字符串。</p>
<p>返回值：</p>
<ul>
<li>String - 转换后的 JSON 格式字符串。</li>
</ul>
<h3 id="func-tostring-24"><a class="header" href="#func-tostring-24">func toString()</a></h3>
<pre><code class="language-cangjie">public func toString(): String
</code></pre>
<p>功能：将 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonstring">JsonString</a> 转换为字符串。</p>
<p>返回值：</p>
<ul>
<li>String - 转换后的字符串。</li>
</ul>
<h2 id="class-jsonvalue"><a class="header" href="#class-jsonvalue">class JsonValue</a></h2>
<pre><code class="language-cangjie">sealed abstract class JsonValue &lt;: ToString
</code></pre>
<p>功能：此类为 JSON 数据层，主要用于 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a> 和 String 数据之间的互相转换。</p>
<p>抽象类 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a> 提供了 String 类型和具体的 JSON 类型相互转换的接口，以及具体的 JSON 类型判断功能。</p>
<p>父类型：</p>
<ul>
<li>ToString</li>
</ul>
<p>示例：</p>
<p>使用示例见<a href="encoding/json/json_package_api/../json_samples/json_value_sample.html">JsonValue 和 String 互相转换</a>。</p>
<h3 id="static-func-fromstrstring"><a class="header" href="#static-func-fromstrstring">static func fromStr(String)</a></h3>
<pre><code class="language-cangjie">public static func fromStr(s: String): JsonValue
</code></pre>
<p>功能：将字符串数据解析为 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a>。对于整数，支持前导 '0b'，'0o'，'0x'（不区分大小写），分别表示二进制，八进制和十六进制。字符串解析失败时将打印错误字符及其行数和列数，其中列数从错误字符所在行的非空格字符起开始计算。</p>
<p>JSON 在解析 String 转换为 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a> 时，转义字符 \ 之后只能对应 JSON 支持的转义字符（b、f、n、r、t、u、\、&quot;、/），其中 \u 的格式为：\uXXXX，X 为十六进制数，例：\u0041 代表字符 'A'。</p>
<p>参数：</p>
<ul>
<li>s: String - 传入字符串，暂不支持 &quot;?&quot; 和特殊字符。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a> - 转换后的 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a>。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="encoding/json/json_package_api/encoding_json_package_exceptions.html#class-jsonexception">JsonException</a> - 如果内存分配失败，或解析字符串出错，抛出异常。</li>
</ul>
<p>示例：</p>
<pre><code class="language-cangjie">import stdx.encoding.json.*

main() {
    println(JsonString(&quot;\b | \f | \n | \r | \t | A | \\ | \&quot; | /&quot;).toString())
    println(JsonValue.fromStr(&quot;\&quot;\\b\&quot;&quot;).toString())
    println(JsonValue.fromStr(&quot;\&quot;\\f\&quot;&quot;).toString())
    println(JsonValue.fromStr(&quot;\&quot;\\n\&quot;&quot;).toString())
    println(JsonValue.fromStr(&quot;\&quot;\\r\&quot;&quot;).toString())
    println(JsonValue.fromStr(&quot;\&quot;\\t\&quot;&quot;).toString())
    println(JsonValue.fromStr(&quot;\&quot;\\u0041\&quot;&quot;).toString())
    println(JsonValue.fromStr(&quot;\&quot;\\\\\&quot;&quot;).toString())
    println(JsonValue.fromStr(&quot;\&quot;\\\&quot;\&quot;&quot;).toString())
    println(JsonValue.fromStr(&quot;\&quot;\\/\&quot;&quot;).toString())
}
</code></pre>
<p>运行结果如下：</p>
<pre><code class="language-text">&quot;\b | \f | \n | \r | \t | A | \\ | \&quot; | /&quot;
&quot;\b&quot;
&quot;\f&quot;
&quot;\n&quot;
&quot;\r&quot;
&quot;\t&quot;
&quot;A&quot;
&quot;\\&quot;
&quot;\&quot;&quot;
&quot;/&quot;
</code></pre>
<h3 id="func-asarray"><a class="header" href="#func-asarray">func asArray()</a></h3>
<pre><code class="language-cangjie">public func asArray(): JsonArray
</code></pre>
<p>功能：将 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a> 转换为 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonarray">JsonArray</a> 格式。</p>
<p>返回值：</p>
<ul>
<li><a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonarray">JsonArray</a> - 转换后的 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonarray">JsonArray</a>。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="encoding/json/json_package_api/encoding_json_package_exceptions.html#class-jsonexception">JsonException</a> - 如果转换失败，抛出异常。</li>
</ul>
<h3 id="func-asbool"><a class="header" href="#func-asbool">func asBool()</a></h3>
<pre><code class="language-cangjie">public func asBool(): JsonBool
</code></pre>
<p>功能：将 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a> 转换为 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonbool">JsonBool</a> 格式。</p>
<p>返回值：</p>
<ul>
<li><a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonbool">JsonBool</a> - 转换后的 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonbool">JsonBool</a>。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="encoding/json/json_package_api/encoding_json_package_exceptions.html#class-jsonexception">JsonException</a> - 如果转换失败，抛出异常。</li>
</ul>
<h3 id="func-asfloat"><a class="header" href="#func-asfloat">func asFloat()</a></h3>
<pre><code class="language-cangjie">public func asFloat(): JsonFloat
</code></pre>
<p>功能：将 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a> 转换为 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonfloat">JsonFloat</a> 格式。</p>
<p>返回值：</p>
<ul>
<li><a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonfloat">JsonFloat</a> - 转换后的 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonfloat">JsonFloat</a>。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="encoding/json/json_package_api/encoding_json_package_exceptions.html#class-jsonexception">JsonException</a> - 如果转换失败，抛出异常。</li>
</ul>
<h3 id="func-asint"><a class="header" href="#func-asint">func asInt()</a></h3>
<pre><code class="language-cangjie">public func asInt(): JsonInt
</code></pre>
<p>功能：将 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a> 转换为 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonint">JsonInt</a> 格式。</p>
<p>返回值：</p>
<ul>
<li><a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonint">JsonInt</a> - 转换后的 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonint">JsonInt</a>。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="encoding/json/json_package_api/encoding_json_package_exceptions.html#class-jsonexception">JsonException</a> - 如果转换失败，抛出异常。</li>
</ul>
<h3 id="func-asnull"><a class="header" href="#func-asnull">func asNull()</a></h3>
<pre><code class="language-cangjie">public func asNull(): JsonNull
</code></pre>
<p>功能：将 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a> 转换为 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonnull">JsonNull</a> 格式。</p>
<p>返回值：</p>
<ul>
<li><a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonnull">JsonNull</a> - 转换后的 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonnull">JsonNull</a>。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="encoding/json/json_package_api/encoding_json_package_exceptions.html#class-jsonexception">JsonException</a> - 如果转换失败，抛出异常。</li>
</ul>
<h3 id="func-asobject"><a class="header" href="#func-asobject">func asObject()</a></h3>
<pre><code class="language-cangjie">public func asObject(): JsonObject
</code></pre>
<p>功能：将 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a> 转换为 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonobject">JsonObject</a> 格式。</p>
<p>返回值：</p>
<ul>
<li><a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonobject">JsonObject</a> - 转换后的 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonobject">JsonObject</a>。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="encoding/json/json_package_api/encoding_json_package_exceptions.html#class-jsonexception">JsonException</a> - 如果转换失败，抛出异常。</li>
</ul>
<h3 id="func-asstring"><a class="header" href="#func-asstring">func asString()</a></h3>
<pre><code class="language-cangjie">public func asString(): JsonString
</code></pre>
<p>功能：将 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a> 转换为 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonstring">JsonString</a> 格式。</p>
<p>返回值：</p>
<ul>
<li><a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonstring">JsonString</a> - 转换后的 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonstring">JsonString</a>。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="encoding/json/json_package_api/encoding_json_package_exceptions.html#class-jsonexception">JsonException</a> - 如果转换失败，抛出异常。</li>
</ul>
<h3 id="func-kind-7"><a class="header" href="#func-kind-7">func kind()</a></h3>
<pre><code class="language-cangjie">public func kind(): JsonKind
</code></pre>
<p>功能：返回当前 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a> 所属的 <a href="encoding/json/json_package_api/encoding_json_package_enums.html#enum-jsonkind">JsonKind</a> 类型。</p>
<p>返回值：</p>
<ul>
<li><a href="encoding/json/json_package_api/encoding_json_package_enums.html#enum-jsonkind">JsonKind</a> - 当前 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a> 所属的 <a href="encoding/json/json_package_api/encoding_json_package_enums.html#enum-jsonkind">JsonKind</a> 类型。</li>
</ul>
<h3 id="func-tojsonstring-7"><a class="header" href="#func-tojsonstring-7">func toJsonString()</a></h3>
<pre><code class="language-cangjie">public func toJsonString(): String
</code></pre>
<p>功能：将 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a> 转换为 JSON 格式的 (带有空格换行符) 字符串。</p>
<p>返回值：</p>
<ul>
<li>String - 转换后的 JSON 格式字符串。</li>
</ul>
<h3 id="func-tostring-25"><a class="header" href="#func-tostring-25">func toString()</a></h3>
<pre><code class="language-cangjie">public func toString(): String
</code></pre>
<p>功能：将 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a> 转换为字符串。</p>
<p>返回值：</p>
<ul>
<li>String - 转换后的字符串。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="枚举-7"><a class="header" href="#枚举-7">枚举</a></h1>
<h2 id="enum-jsonkind"><a class="header" href="#enum-jsonkind">enum JsonKind</a></h2>
<pre><code class="language-cangjie">public enum JsonKind {
    | JsNull
    | JsBool
    | JsInt
    | JsFloat
    | JsString
    | JsArray
    | JsObject
}
</code></pre>
<p>功能：表示 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a> 的具体类型。</p>
<h3 id="jsarray"><a class="header" href="#jsarray">JsArray</a></h3>
<pre><code class="language-cangjie">JsArray
</code></pre>
<p>功能：表示 <code>JSON</code> 类型中的数组类型。</p>
<h3 id="jsbool"><a class="header" href="#jsbool">JsBool</a></h3>
<pre><code class="language-cangjie">JsBool
</code></pre>
<p>功能：表示 <code>true</code> 或者 <code>false</code> 类型。</p>
<h3 id="jsfloat"><a class="header" href="#jsfloat">JsFloat</a></h3>
<pre><code class="language-cangjie">JsFloat
</code></pre>
<p>功能：表示值为浮点数的 <code>number</code> 类型。</p>
<h3 id="jsint"><a class="header" href="#jsint">JsInt</a></h3>
<pre><code class="language-cangjie">JsInt
</code></pre>
<p>功能：表示值为整数的 <code>number</code> 类型。</p>
<h3 id="jsnull"><a class="header" href="#jsnull">JsNull</a></h3>
<pre><code class="language-cangjie">JsNull
</code></pre>
<p>功能：表示 <code>null</code> 类型。</p>
<h3 id="jsobject"><a class="header" href="#jsobject">JsObject</a></h3>
<pre><code class="language-cangjie">JsObject
</code></pre>
<p>功能：表述 <code>JSON</code> 类型中的对象类型。</p>
<h3 id="jsstring"><a class="header" href="#jsstring">JsString</a></h3>
<pre><code class="language-cangjie">JsString
</code></pre>
<p>功能：表示 <code>string</code> 类型。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="异常"><a class="header" href="#异常">异常</a></h1>
<h2 id="class-jsonexception"><a class="header" href="#class-jsonexception">class JsonException</a></h2>
<pre><code class="language-cangjie">public class JsonException &lt;: Exception {
    public init()
    public init(message: String)
}
</code></pre>
<p>功能：JSON 包的异常类，用于 <a href="encoding/json/json_package_api/encoding_json_package_classes.html#class-jsonvalue">JsonValue</a> 类型使用时出现异常的场景。</p>
<p>父类型：</p>
<ul>
<li>Exception</li>
</ul>
<h3 id="init-13"><a class="header" href="#init-13">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个不包含任何异常提示信息的 <a href="encoding/json/json_package_api/encoding_json_package_exceptions.html#class-jsonexception">JsonException</a> 实例。</p>
<h3 id="initstring-5"><a class="header" href="#initstring-5">init(String)</a></h3>
<pre><code class="language-cangjie">public init(message: String)
</code></pre>
<p>功能：根据指定的异常提示信息构造 <a href="encoding/json/json_package_api/encoding_json_package_exceptions.html#class-jsonexception">JsonException</a> 实例。</p>
<p>参数：</p>
<ul>
<li>message: String - 指定的异常提示信息。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jsonarray-使用示例"><a class="header" href="#jsonarray-使用示例">JsonArray 使用示例</a></h1>
<p>下面是 JsonArray 使用示例，该示例构造了一个 JsonArray 对象，并往其中添加了一些 JsonValue，最后以两种格式打印了该 JsonArray 对象。</p>
<p>示例：</p>
<!-- verify -->
<pre><code class="language-cangjie">import stdx.encoding.json.*
import std.collection.*

main() {
    var a: JsonValue = JsonNull()
    var b: JsonValue = JsonBool(true)
    var c: JsonValue = JsonBool(false)
    var d: JsonValue = JsonInt(7363)
    var e: JsonValue = JsonFloat(736423.546)
    var list: ArrayList&lt;JsonValue&gt; = ArrayList&lt;JsonValue&gt;()
    var list2: ArrayList&lt;JsonValue&gt; = ArrayList&lt;JsonValue&gt;()
    var map = JsonObject()
    var map1 = JsonObject()
    map1.put(&quot;a&quot;, JsonString(&quot;jjjjjj&quot;))
    map1.put(&quot;b&quot;, b)
    map1.put(&quot;c&quot;, JsonString(&quot;hhhhh&quot;))
    list2.add(b)
    list2.add(JsonInt(3333333))
    list2.add(map1)
    list2.add(JsonString(&quot;sdfghgfasd&quot;))
    list.add(b)
    list.add(a)
    list.add(map)
    list.add(c)
    list.add(JsonArray(list2))
    list.add(d)
    list.add(JsonString(&quot;ddddddd&quot;))
    list.add(e)
    var result: JsonValue = JsonArray(list)
    println(&quot;func toString result is:&quot;)
    println(result.toString())
    println(&quot;func toJsonString result is:&quot;)
    println(result.toJsonString())
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-text">func toString result is:
[true,null,{},false,[true,3333333,{&quot;a&quot;:&quot;jjjjjj&quot;,&quot;b&quot;:true,&quot;c&quot;:&quot;hhhhh&quot;},&quot;sdfghgfasd&quot;],7363,&quot;ddddddd&quot;,736423.546]
func toJsonString result is:
[
  true,
  null,
  {},
  false,
  [
    true,
    3333333,
    {
      &quot;a&quot;: &quot;jjjjjj&quot;,
      &quot;b&quot;: true,
      &quot;c&quot;: &quot;hhhhh&quot;
    },
    &quot;sdfghgfasd&quot;
  ],
  7363,
  &quot;ddddddd&quot;,
  736423.546
]

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jsonvalue-和-string-互相转换"><a class="header" href="#jsonvalue-和-string-互相转换">JsonValue 和 String 互相转换</a></h1>
<p>下面是 JsonValue 和 String 互相转换的示例，该示例使用 JsonValue.fromStr 将一个 JSON 字符串转换为 JsonValue，随后以两种格式打印了该 JsonValue 对象。</p>
<p>示例：</p>
<!-- verify -->
<pre><code class="language-cangjie">import stdx.encoding.json.*

main() {
    var str = ##&quot;[true,&quot;kjjjke\&quot;eed&quot;,{&quot;sdfd&quot;:&quot;ggggg&quot;,&quot;eeeee&quot;:[341,false,{&quot;nnnn&quot;:55.87}]},3422,22.341,false,[22,22.22,true,&quot;ddd&quot;],43]&quot;##
    var jv: JsonValue = JsonValue.fromStr(str)
    var res = jv.toString()
    var prettyres = jv.toJsonString()
    println(res)
    println(prettyres)
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-text">[true,&quot;kjjjke\&quot;eed&quot;,{&quot;sdfd&quot;:&quot;ggggg&quot;,&quot;eeeee&quot;:[341,false,{&quot;nnnn&quot;:55.87}]},3422,22.341,false,[22,22.22,true,&quot;ddd&quot;],43]
[
  true,
  &quot;kjjjke\&quot;eed&quot;,
  {
    &quot;sdfd&quot;: &quot;ggggg&quot;,
    &quot;eeeee&quot;: [
      341,
      false,
      {
        &quot;nnnn&quot;: 55.87
      }
    ]
  },
  3422,
  22.341,
  false,
  [
    22,
    22.22,
    true,
    &quot;ddd&quot;
  ],
  43
]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jsonvalue-与-datamodel-的转换"><a class="header" href="#jsonvalue-与-datamodel-的转换">JsonValue 与 DataModel 的转换</a></h1>
<p>下面是 JSON 字符串与自定义类型间的转换的示例，该用例为 Person 类型实现了 Serializable 接口，随后进行了从 JSON 字符串到自定义类型的转换和从自定义类型到 JSON 字符串的转换。</p>
<p>示例：</p>
<!-- verify -->
<pre><code class="language-cangjie">import stdx.serialization.serialization.*
import stdx.encoding.json.*

class Person &lt;: Serializable&lt;Person&gt; {
    var name: String = &quot;&quot;
    var age: Int64 = 0
    var loc: Option&lt;Location&gt; = Option&lt;Location&gt;.None

    public func serialize(): DataModel {
        return DataModelStruct()
            .add(field&lt;String&gt;(&quot;name&quot;, name))
            .add(field&lt;Int64&gt;(&quot;age&quot;, age))
            .add(field&lt;Option&lt;Location&gt;&gt;(&quot;loc&quot;, loc))
    }

    public static func deserialize(dm: DataModel): Person {
        var dms = match (dm) {
            case data: DataModelStruct =&gt; data
            case _ =&gt; throw Exception(&quot;this data is not DataModelStruct&quot;)
        }
        var result = Person()
        result.name = String.deserialize(dms.get(&quot;name&quot;))
        result.age = Int64.deserialize(dms.get(&quot;age&quot;))
        result.loc = Option&lt;Location&gt;.deserialize(dms.get(&quot;loc&quot;))
        return result
    }
}

class Location &lt;: Serializable&lt;Location&gt; {
    var country: String = &quot;&quot;
    var province: String = &quot;&quot;

    public func serialize(): DataModel {
        return DataModelStruct().add(field&lt;String&gt;(&quot;country&quot;, country)).add(field&lt;String&gt;(&quot;province&quot;, province))
    }

    public static func deserialize(dm: DataModel): Location {
        var dms = match (dm) {
            case data: DataModelStruct =&gt; data
            case _ =&gt; throw Exception(&quot;this data is not DataModelStruct&quot;)
        }
        var result = Location()
        result.country = String.deserialize(dms.get(&quot;country&quot;))
        result.province = String.deserialize(dms.get(&quot;province&quot;))
        return result
    }
}

main() {
    var js = ##&quot;{
    &quot;name&quot;: &quot;A&quot;,
    &quot;age&quot;: 30,
    &quot;loc&quot;: {
        &quot;country&quot;: &quot;China&quot;,
        &quot;province&quot;: &quot;Beijing&quot;
    }
}&quot;##

    /* 实现从 JSON 字符串到自定义类型的转换 */
    var jv = JsonValue.fromStr(js)
    var dm = DataModel.fromJson(jv)
    var A = Person.deserialize(dm)
    println(&quot;name == ${A.name}&quot;)
    println(&quot;age == ${A.age}&quot;)
    println(&quot;country == ${A.loc.getOrThrow().country}&quot;)
    println(&quot;province == ${A.loc.getOrThrow().province}&quot;)
    println(&quot;====================&quot;)

    /* 实现从自定义类型到 JSON 字符串的转换 */
    dm = A.serialize()
    var jo = dm.toJson().asObject()
    println(jo.toJsonString())
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-text">name == A
age == 30
country == China
province == Beijing
====================
{
  &quot;name&quot;: &quot;A&quot;,
  &quot;age&quot;: 30,
  &quot;loc&quot;: {
    &quot;country&quot;: &quot;China&quot;,
    &quot;province&quot;: &quot;Beijing&quot;
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdxencodingjsonstream"><a class="header" href="#stdxencodingjsonstream">stdx.encoding.json.stream</a></h1>
<h2 id="功能介绍-8"><a class="header" href="#功能介绍-8">功能介绍</a></h2>
<p>json.stream 包主要用于仓颉对象和 JSON 数据流之间的互相转换。</p>
<p>本包提供了 JsonWriter 和 JsonReader 类，JsonWriter 用于提供仓颉对象转 JSON 数据流的序列化能力；JsonReader 用于提供 JSON 数据流转仓颉对象的反序列化能力。</p>
<p>当前实现中支持和 JSON 数据流互转的类型有：</p>
<ul>
<li>
<p>基础数据类型：String、Int8、Int16、Int32、Int64、Float16、Float32、Float64、UInt8、UInt16、UInt32、UInt64。</p>
</li>
<li>
<p>集合类型：Array&lt;T&gt;、ArrayList&lt;T&gt;、HashMap&lt;String, T&gt;。</p>
</li>
<li>
<p>其它类型：Option&lt;T&gt;、BigInt、Decimal。</p>
</li>
</ul>
<h2 id="api-列表-8"><a class="header" href="#api-列表-8">API 列表</a></h2>
<h3 id="接口-4"><a class="header" href="#接口-4">接口</a></h3>
<div class="table-wrapper"><table><thead><tr><th>接口名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="encoding/json_stream/./json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsondeserializablet">JsonDeserializable&lt;T&gt;</a></td><td>此接口用于实现从 <a href="encoding/json_stream/./json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 中读取一个仓颉对象。</td></tr>
<tr><td><a href="encoding/json_stream/./json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsonserializable">JsonSerializable</a></td><td>为类型提供序列化到 JSON 数据流的接口。</td></tr>
</tbody></table>
</div>
<h3 id="类-11"><a class="header" href="#类-11">类</a></h3>
<div class="table-wrapper"><table><thead><tr><th>类名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="encoding/json_stream/./json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a></td><td>此类提供 JSON 数据流转仓颉对象的反序列化能力。</td></tr>
<tr><td><a href="encoding/json_stream/./json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a></td><td>构造函数，构造一个将数据写入 out 的实例。</td></tr>
</tbody></table>
</div>
<h3 id="枚举-8"><a class="header" href="#枚举-8">枚举</a></h3>
<div class="table-wrapper"><table><thead><tr><th>枚举名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="encoding/json_stream/./json_stream_package_api/encoding_json_stream_package_enums.html#enum-jsontoken">JsonToken</a></td><td>表示 JSON 编码的字符串中的结构、名称或者值类型。</td></tr>
</tbody></table>
</div>
<h3 id="结构体-8"><a class="header" href="#结构体-8">结构体</a></h3>
<div class="table-wrapper"><table><thead><tr><th>结构体名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="encoding/json_stream/./json_stream_package_api/encoding_json_stream_package_structs.html#struct-writeconfig">WriteConfig</a></td><td>用于表示 <a href="encoding/json_stream/./json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 的序列化格式配置。</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="接口-5"><a class="header" href="#接口-5">接口</a></h1>
<h2 id="interface-jsondeserializablet"><a class="header" href="#interface-jsondeserializablet">interface JsonDeserializable&lt;T&gt;</a></h2>
<pre><code class="language-cangjie">public interface JsonDeserializable&lt;T&gt; {
    static func fromJson(r: JsonReader): T
}
</code></pre>
<p>功能：此接口用于实现从 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 中读取一个仓颉对象。</p>
<p>支持的对象类型包括：</p>
<ul>
<li>
<p>基本数据类型：整数类型、浮点类型、布尔类型、字符串类型。</p>
</li>
<li>
<p>Collection 类型：Array、ArrayList、HashMap、Option。</p>
</li>
<li>
<p>BigInt、Decimal 类型。</p>
</li>
<li>
<p>DateTime 类型。</p>
</li>
</ul>
<h3 id="static-func-fromjsonjsonreader"><a class="header" href="#static-func-fromjsonjsonreader">static func fromJson(JsonReader)</a></h3>
<pre><code class="language-cangjie">static func fromJson(r: JsonReader): T
</code></pre>
<p>功能：从参数 <code>r</code> 指定的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 实例中读取一个 <code>T</code> 类型对象。</p>
<p>参数：</p>
<ul>
<li>r: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> - 读取反序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 实例。</li>
</ul>
<p>返回值：</p>
<ul>
<li>T - <code>T</code> 类型的实例。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalStateException - 如果输入流的 JSON 数据不符合格式，抛出异常。</li>
</ul>
<h3 id="extend-bigint--jsondeserializablebigint"><a class="header" href="#extend-bigint--jsondeserializablebigint">extend BigInt &lt;: JsonDeserializable&lt;BigInt&gt;</a></h3>
<pre><code class="language-cangjie">extend BigInt &lt;: JsonDeserializable&lt;BigInt&gt;
</code></pre>
<p>功能：为 BigInt 类型实现 JsonDeserializable 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsondeserializablet">JsonDeserializable</a>&lt;BigInt&gt;</li>
</ul>
<h4 id="static-func-fromjsonjsonreader-1"><a class="header" href="#static-func-fromjsonjsonreader-1">static func fromJson(JsonReader)</a></h4>
<pre><code class="language-cangjie">public static func fromJson(r: JsonReader): BigInt
</code></pre>
<p>功能：从 <a href="encoding/json_stream/json_stream_package_api/../json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 中读取一个 BigInt。</p>
<p>参数：</p>
<ul>
<li>r: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> - 读取反序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 实例。</li>
</ul>
<p>返回值：</p>
<ul>
<li>BigInt - BigInt 类型的实例。</li>
</ul>
<h3 id="extend-bool--jsondeserializablebool"><a class="header" href="#extend-bool--jsondeserializablebool">extend Bool &lt;: JsonDeserializable&lt;Bool&gt;</a></h3>
<pre><code class="language-cangjie">extend Bool &lt;: JsonDeserializable&lt;Bool&gt;
</code></pre>
<p>功能：为 Bool 类型实现 JsonDeserializable 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsondeserializablet">JsonDeserializable</a>&lt;Bool&gt;</li>
</ul>
<h4 id="static-func-fromjsonjsonreader-2"><a class="header" href="#static-func-fromjsonjsonreader-2">static func fromJson(JsonReader)</a></h4>
<pre><code class="language-cangjie">public static func fromJson(r: JsonReader): Bool
</code></pre>
<p>功能：从 <a href="encoding/json_stream/json_stream_package_api/../json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 中读取一个 Bool。</p>
<p>参数：</p>
<ul>
<li>r: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> - 读取反序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 实例。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - Bool 类型的实例。</li>
</ul>
<h3 id="extend-datetime--jsondeserializabledatetime"><a class="header" href="#extend-datetime--jsondeserializabledatetime">extend DateTime &lt;: JsonDeserializable&lt;DateTime&gt;</a></h3>
<pre><code class="language-cangjie">extend DateTime &lt;: JsonDeserializable&lt;DateTime&gt;
</code></pre>
<p>功能：为 DateTime 类型实现 JsonDeserializable 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsondeserializablet">JsonDeserializable</a>&lt;DateTime&gt;</li>
</ul>
<h4 id="static-func-fromjsonjsonreader-3"><a class="header" href="#static-func-fromjsonjsonreader-3">static func fromJson(JsonReader)</a></h4>
<pre><code class="language-cangjie">public static func fromJson(r: JsonReader): DateTime
</code></pre>
<p>功能：从 <a href="encoding/json_stream/json_stream_package_api/../json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 中读取一个 DateTime 实例。</p>
<p>该函数将会把读取到的字符串按照 <code>RFC3339</code> 的规范解析，可包含小数秒格式，函数的行为参考DateTime的func parse(String)。</p>
<p>参数：</p>
<ul>
<li>r: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> - 读取反序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 实例。</li>
</ul>
<p>返回值：</p>
<ul>
<li>DateTime - DateTime 类型的实例。</li>
</ul>
<p>异常：</p>
<ul>
<li>TimeParseException - 无法正常解析时，抛出异常。</li>
</ul>
<h3 id="extend-decimal--jsondeserializabledecimal"><a class="header" href="#extend-decimal--jsondeserializabledecimal">extend Decimal &lt;: JsonDeserializable&lt;Decimal&gt;</a></h3>
<pre><code class="language-cangjie">extend Decimal &lt;: JsonDeserializable&lt;Decimal&gt;
</code></pre>
<p>功能：为 Decimal 类型实现 <a href="encoding/json_stream/json_stream_package_api/./encoding_json_stream_package_interfaces.html#interface-jsondeserializablet">JsonDeserializable</a> 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsondeserializablet">JsonDeserializable</a>&lt;Decimal&gt;</li>
</ul>
<h4 id="static-func-fromjsonjsonreader-4"><a class="header" href="#static-func-fromjsonjsonreader-4">static func fromJson(JsonReader)</a></h4>
<pre><code class="language-cangjie">public static func fromJson(r: JsonReader): Decimal
</code></pre>
<p>功能：从 <a href="encoding/json_stream/json_stream_package_api/../json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 中读取一个 Decimal。</p>
<p>参数：</p>
<ul>
<li>r: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> - 读取反序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 实例。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Decimal - Decimal 类型的实例。</li>
</ul>
<h3 id="extend-float16--jsondeserializablefloat16"><a class="header" href="#extend-float16--jsondeserializablefloat16">extend Float16 &lt;: JsonDeserializable&lt;Float16&gt;</a></h3>
<pre><code class="language-cangjie">extend Float16 &lt;: JsonDeserializable&lt;Float16&gt;
</code></pre>
<p>功能：为 Float16 类型实现 JsonDeserializable 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsondeserializablet">JsonDeserializable</a>&lt;Float16&gt;</li>
</ul>
<h4 id="static-func-fromjsonjsonreader-5"><a class="header" href="#static-func-fromjsonjsonreader-5">static func fromJson(JsonReader)</a></h4>
<pre><code class="language-cangjie">public static func fromJson(r: JsonReader): Float16
</code></pre>
<p>功能：从 <a href="encoding/json_stream/json_stream_package_api/../json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 中读取一个 Float16。</p>
<p>参数：</p>
<ul>
<li>r: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> - 读取反序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 实例。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Float16 - Float16 类型的实例。</li>
</ul>
<p>异常：</p>
<ul>
<li>OverflowException - 读取的数据超过范围时，抛出异常。</li>
</ul>
<h3 id="extend-float32--jsondeserializablefloat32"><a class="header" href="#extend-float32--jsondeserializablefloat32">extend Float32 &lt;: JsonDeserializable&lt;Float32&gt;</a></h3>
<pre><code class="language-cangjie">extend Float32 &lt;: JsonDeserializable&lt;Float32&gt;
</code></pre>
<p>功能：为 Float32 类型实现 JsonDeserializable 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsondeserializablet">JsonDeserializable</a>&lt;Float32&gt;</li>
</ul>
<h4 id="static-func-fromjsonjsonreader-6"><a class="header" href="#static-func-fromjsonjsonreader-6">static func fromJson(JsonReader)</a></h4>
<pre><code class="language-cangjie">public static func fromJson(r: JsonReader): Float32
</code></pre>
<p>功能：从 <a href="encoding/json_stream/json_stream_package_api/../json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 中读取一个 Float32。</p>
<p>参数：</p>
<ul>
<li>r: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> - 读取反序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 实例。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Float32 - Float32 类型的实例。</li>
</ul>
<p>异常：</p>
<ul>
<li>OverflowException - 读取的数据超过范围时，抛出异常。</li>
</ul>
<h3 id="extend-float64--jsondeserializablefloat64"><a class="header" href="#extend-float64--jsondeserializablefloat64">extend Float64 &lt;: JsonDeserializable&lt;Float64&gt;</a></h3>
<pre><code class="language-cangjie">extend Float64 &lt;: JsonDeserializable&lt;Float64&gt;
</code></pre>
<p>功能：为 Float64 类型实现 JsonDeserializable 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsondeserializablet">JsonDeserializable</a>&lt;Float64&gt;</li>
</ul>
<h4 id="static-func-fromjsonjsonreader-7"><a class="header" href="#static-func-fromjsonjsonreader-7">static func fromJson(JsonReader)</a></h4>
<pre><code class="language-cangjie">public static func fromJson(r: JsonReader): Float64
</code></pre>
<p>功能：从 <a href="encoding/json_stream/json_stream_package_api/../json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 中读取一个 Float64。</p>
<p>参数：</p>
<ul>
<li>r: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> - 读取反序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 实例。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Float64 - Float64 类型的实例。</li>
</ul>
<p>异常：</p>
<ul>
<li>OverflowException - 读取的数据超过范围时，抛出异常。</li>
</ul>
<h3 id="extend-string--jsondeserializablestring"><a class="header" href="#extend-string--jsondeserializablestring">extend String &lt;: JsonDeserializable&lt;String&gt;</a></h3>
<pre><code class="language-cangjie">extend String &lt;: JsonDeserializable&lt;String&gt;
</code></pre>
<p>功能：为 String 类型实现 JsonDeserializable 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsondeserializablet">JsonDeserializable</a>&lt;String&gt;</li>
</ul>
<h4 id="static-func-fromjsonjsonreader-8"><a class="header" href="#static-func-fromjsonjsonreader-8">static func fromJson(JsonReader)</a></h4>
<pre><code class="language-cangjie">public static func fromJson(r: JsonReader): String
</code></pre>
<p>功能：从 <a href="encoding/json_stream/json_stream_package_api/../json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 中读取一个 String。</p>
<p>根据下一个 <code>JsonToken</code> 的不同，<code>String</code> 的反序列化结果将会不同：</p>
<ul>
<li>当下一个 <code>JsonToken</code> 是 <code>JsonString</code> 时， 反序列化过程会按照标准<a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-404/">ECMA-404 The JSON Data Interchange Standard</a>对读到的 <code>String</code> 进行转义。</li>
<li>当下一个 <code>JsonToken</code> 是 <code>JsonNumber</code> <code>JsonBool</code> <code>JsonNull</code> 其中一个时，将会读取下一个 <code>value</code> 字段的原始字符串并返回。</li>
<li>当下一个 <code>JsonToken</code> 是其它类型时，调用此接口会抛异常。</li>
</ul>
<p>参数：</p>
<ul>
<li>r: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> - 读取反序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 实例。</li>
</ul>
<p>返回值：</p>
<ul>
<li>String - String 类型的实例。</li>
</ul>
<h3 id="extend-int16--jsondeserializableint16"><a class="header" href="#extend-int16--jsondeserializableint16">extend Int16 &lt;: JsonDeserializable&lt;Int16&gt;</a></h3>
<pre><code class="language-cangjie">extend Int16 &lt;: JsonDeserializable&lt;Int16&gt;
</code></pre>
<p>功能：为 Int16 类型实现 JsonDeserializable 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsondeserializablet">JsonDeserializable</a>&lt;Int16&gt;</li>
</ul>
<h4 id="static-func-fromjsonjsonreader-9"><a class="header" href="#static-func-fromjsonjsonreader-9">static func fromJson(JsonReader)</a></h4>
<pre><code class="language-cangjie">public static func fromJson(r: JsonReader): Int16
</code></pre>
<p>功能：从 <a href="encoding/json_stream/json_stream_package_api/../json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 中读取一个 Int16。</p>
<p>参数：</p>
<ul>
<li>r: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> - 读取反序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 实例。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Int16 - Int16 类型的实例。</li>
</ul>
<p>异常：</p>
<ul>
<li>OverflowException - 读取的数据超过范围时，抛出异常。</li>
</ul>
<h3 id="extend-int32--jsondeserializableint32"><a class="header" href="#extend-int32--jsondeserializableint32">extend Int32 &lt;: JsonDeserializable&lt;Int32&gt;</a></h3>
<pre><code class="language-cangjie">extend Int32 &lt;: JsonDeserializable&lt;Int32&gt;
</code></pre>
<p>功能：为 Int32 类型实现 JsonDeserializable 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsondeserializablet">JsonDeserializable</a>&lt;Int32&gt;</li>
</ul>
<h4 id="static-func-fromjsonjsonreader-10"><a class="header" href="#static-func-fromjsonjsonreader-10">static func fromJson(JsonReader)</a></h4>
<pre><code class="language-cangjie">public static func fromJson(r: JsonReader): Int32
</code></pre>
<p>功能：从 <a href="encoding/json_stream/json_stream_package_api/../json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 中读取一个 Int32。</p>
<p>参数：</p>
<ul>
<li>r: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> - 读取反序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 实例。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Int32 - Int32 类型的实例。</li>
</ul>
<p>异常：</p>
<ul>
<li>OverflowException - 读取的数据超过范围时，抛出异常。</li>
</ul>
<h3 id="extend-int64--jsondeserializableint64"><a class="header" href="#extend-int64--jsondeserializableint64">extend Int64 &lt;: JsonDeserializable&lt;Int64&gt;</a></h3>
<pre><code class="language-cangjie">extend Int64 &lt;: JsonDeserializable&lt;Int64&gt;
</code></pre>
<p>功能：为 Int64 类型实现 JsonDeserializable 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsondeserializablet">JsonDeserializable</a>&lt;Int64&gt;</li>
</ul>
<h4 id="static-func-fromjsonjsonreader-11"><a class="header" href="#static-func-fromjsonjsonreader-11">static func fromJson(JsonReader)</a></h4>
<pre><code class="language-cangjie">public static func fromJson(r: JsonReader): Int64
</code></pre>
<p>功能：从 <a href="encoding/json_stream/json_stream_package_api/../json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 中读取一个 Int64。</p>
<p>参数：</p>
<ul>
<li>r: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> - 读取反序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 实例。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Int64 - Int64 类型的实例。</li>
</ul>
<p>异常：</p>
<ul>
<li>OverflowException - 读取的数据超过范围时，抛出异常。</li>
</ul>
<h3 id="extend-int8--jsondeserializableint8"><a class="header" href="#extend-int8--jsondeserializableint8">extend Int8 &lt;: JsonDeserializable&lt;Int8&gt;</a></h3>
<pre><code class="language-cangjie">extend Int8 &lt;: JsonDeserializable&lt;Int8&gt;
</code></pre>
<p>功能：为 Int8 类型实现 JsonDeserializable 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsondeserializablet">JsonDeserializable</a>&lt;Int8&gt;</li>
</ul>
<h4 id="static-func-fromjsonjsonreader-12"><a class="header" href="#static-func-fromjsonjsonreader-12">static func fromJson(JsonReader)</a></h4>
<pre><code class="language-cangjie">public static func fromJson(r: JsonReader): Int8
</code></pre>
<p>功能：从 <a href="encoding/json_stream/json_stream_package_api/../json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 中读取一个 Int8。</p>
<p>参数：</p>
<ul>
<li>r: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> - 读取反序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 实例。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Int8 - Int8 类型的实例。</li>
</ul>
<p>异常：</p>
<ul>
<li>OverflowException - 读取的数据超过范围时，抛出异常。</li>
</ul>
<h3 id="extend-intnative--jsondeserializableintnative"><a class="header" href="#extend-intnative--jsondeserializableintnative">extend IntNative &lt;: JsonDeserializable&lt;IntNative&gt;</a></h3>
<pre><code class="language-cangjie">extend IntNative &lt;: JsonDeserializable&lt;IntNative&gt;
</code></pre>
<p>功能：为 IntNative 类型实现 JsonDeserializable 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsondeserializablet">JsonDeserializable</a>&lt;IntNative&gt;</li>
</ul>
<h4 id="static-func-fromjsonjsonreader-13"><a class="header" href="#static-func-fromjsonjsonreader-13">static func fromJson(JsonReader)</a></h4>
<pre><code class="language-cangjie">public static func fromJson(r: JsonReader): IntNative
</code></pre>
<p>功能：从 <a href="encoding/json_stream/json_stream_package_api/../json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 中读取一个 IntNative。</p>
<p>参数：</p>
<ul>
<li>r: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> - 读取反序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 实例。</li>
</ul>
<p>返回值：</p>
<ul>
<li>IntNative - IntNative 类型的实例。</li>
</ul>
<p>异常：</p>
<ul>
<li>OverflowException - 读取的数据超过范围时，抛出异常。</li>
</ul>
<h3 id="extend-uint16--jsondeserializableuint16"><a class="header" href="#extend-uint16--jsondeserializableuint16">extend UInt16 &lt;: JsonDeserializable&lt;UInt16&gt;</a></h3>
<pre><code class="language-cangjie">extend UInt16 &lt;: JsonDeserializable&lt;UInt16&gt;
</code></pre>
<p>功能：为 UInt16 类型实现 JsonDeserializable 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsondeserializablet">JsonDeserializable</a>&lt;UInt16&gt;</li>
</ul>
<h4 id="static-func-fromjsonjsonreader-14"><a class="header" href="#static-func-fromjsonjsonreader-14">static func fromJson(JsonReader)</a></h4>
<pre><code class="language-cangjie">public static func fromJson(r: JsonReader): UInt16
</code></pre>
<p>功能：从 <a href="encoding/json_stream/json_stream_package_api/../json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 中读取一个 UInt16。</p>
<p>参数：</p>
<ul>
<li>r: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> - 读取反序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 实例。</li>
</ul>
<p>返回值：</p>
<ul>
<li>UInt16 - UInt16 类型的实例。</li>
</ul>
<p>异常：</p>
<ul>
<li>OverflowException - 读取的数据超过范围时，抛出异常。</li>
</ul>
<h3 id="extend-uint32--jsondeserializableuint32"><a class="header" href="#extend-uint32--jsondeserializableuint32">extend UInt32 &lt;: JsonDeserializable&lt;UInt32&gt;</a></h3>
<pre><code class="language-cangjie">extend UInt32 &lt;: JsonDeserializable&lt;UInt32&gt;
</code></pre>
<p>功能：为 UInt32 类型实现 JsonDeserializable 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsondeserializablet">JsonDeserializable</a>&lt;UInt32&gt;</li>
</ul>
<h4 id="static-func-fromjsonjsonreader-15"><a class="header" href="#static-func-fromjsonjsonreader-15">static func fromJson(JsonReader)</a></h4>
<pre><code class="language-cangjie">public static func fromJson(r: JsonReader): UInt32
</code></pre>
<p>功能：从 <a href="encoding/json_stream/json_stream_package_api/../json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 中读取一个 UInt32。</p>
<p>参数：</p>
<ul>
<li>r: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> - 读取反序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 实例。</li>
</ul>
<p>返回值：</p>
<ul>
<li>UInt32 - UInt32 类型的实例。</li>
</ul>
<p>异常：</p>
<ul>
<li>OverflowException - 读取的数据超过范围时，抛出异常。</li>
</ul>
<h3 id="extend-uint64--jsondeserializableuint64"><a class="header" href="#extend-uint64--jsondeserializableuint64">extend UInt64 &lt;: JsonDeserializable&lt;UInt64 &gt;</a></h3>
<pre><code class="language-cangjie">extend UInt64 &lt;: JsonDeserializable&lt;UInt64&gt;
</code></pre>
<p>功能：为 UInt64 类型实现 JsonDeserializable 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsondeserializablet">JsonDeserializable</a>&lt;UInt64&gt;</li>
</ul>
<h4 id="static-func-fromjsonjsonreader-16"><a class="header" href="#static-func-fromjsonjsonreader-16">static func fromJson(JsonReader)</a></h4>
<pre><code class="language-cangjie">public static func fromJson(r: JsonReader): UInt64
</code></pre>
<p>功能：从 <a href="encoding/json_stream/json_stream_package_api/../json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 中读取一个 UInt64。</p>
<p>参数：</p>
<ul>
<li>r: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> - 读取反序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 实例。</li>
</ul>
<p>返回值：</p>
<ul>
<li>UInt64 - UInt64 类型的实例。</li>
</ul>
<p>异常：</p>
<ul>
<li>OverflowException - 读取的数据超过范围时，抛出异常。</li>
</ul>
<h3 id="extend-uint8--jsondeserializableuint8"><a class="header" href="#extend-uint8--jsondeserializableuint8">extend UInt8 &lt;: JsonDeserializable&lt;UInt8&gt;</a></h3>
<pre><code class="language-cangjie">extend UInt8 &lt;: JsonDeserializable&lt;UInt8&gt;
</code></pre>
<p>功能：为 UInt8 类型实现 JsonDeserializable 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsondeserializablet">JsonDeserializable</a>&lt;UInt8&gt;</li>
</ul>
<h4 id="static-func-fromjsonjsonreader-17"><a class="header" href="#static-func-fromjsonjsonreader-17">static func fromJson(JsonReader)</a></h4>
<pre><code class="language-cangjie">public static func fromJson(r: JsonReader): UInt8
</code></pre>
<p>功能：从 <a href="encoding/json_stream/json_stream_package_api/../json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 中读取一个 UInt8。</p>
<p>参数：</p>
<ul>
<li>r: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> - 读取反序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 实例。</li>
</ul>
<p>返回值：</p>
<ul>
<li>UInt8 - UInt8 类型的实例。</li>
</ul>
<p>异常：</p>
<ul>
<li>OverflowException - 读取的数据超过范围时，抛出异常。</li>
</ul>
<h3 id="extend-uintnative--jsondeserializableuintnative"><a class="header" href="#extend-uintnative--jsondeserializableuintnative">extend UIntNative &lt;: JsonDeserializable&lt;UIntNative&gt;</a></h3>
<pre><code class="language-cangjie">extend UIntNative &lt;: JsonDeserializable&lt;UIntNative&gt;
</code></pre>
<p>功能：为 UIntNative 类型实现 JsonDeserializable 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsondeserializablet">JsonDeserializable</a>&lt;UIntNative&gt;</li>
</ul>
<h4 id="static-func-fromjsonjsonreader-18"><a class="header" href="#static-func-fromjsonjsonreader-18">static func fromJson(JsonReader)</a></h4>
<pre><code class="language-cangjie">public static func fromJson(r: JsonReader): UIntNative
</code></pre>
<p>功能：从 <a href="encoding/json_stream/json_stream_package_api/../json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 中读取一个 UIntNative。</p>
<p>参数：</p>
<ul>
<li>r: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> - 读取反序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 实例。</li>
</ul>
<p>返回值：</p>
<ul>
<li>UIntNative - UIntNative 类型的实例。</li>
</ul>
<p>异常：</p>
<ul>
<li>OverflowException - 读取的数据超过范围时，抛出异常。</li>
</ul>
<h3 id="extendt-arrayt--jsondeserializablearrayt-where-t--jsondeserializablet"><a class="header" href="#extendt-arrayt--jsondeserializablearrayt-where-t--jsondeserializablet">extend&lt;T&gt; Array&lt;T&gt; &lt;: JsonDeserializable&lt;Array&lt;T&gt;&gt; where T &lt;: JsonDeserializable&lt;T&gt;</a></h3>
<pre><code class="language-cangjie">extend&lt;T&gt; Array&lt;T&gt; &lt;: JsonDeserializable&lt;Array&lt;T&gt;&gt; where T &lt;: JsonDeserializable&lt;T&gt;
</code></pre>
<p>功能：为 Array&lt;T&gt; 类型实现 JsonDeserializable 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsondeserializablet">JsonDeserializable</a>&lt;Array&lt;T&gt;&gt;</li>
</ul>
<h4 id="static-func-fromjsonjsonreader-19"><a class="header" href="#static-func-fromjsonjsonreader-19">static func fromJson(JsonReader)</a></h4>
<pre><code class="language-cangjie">public static func fromJson(r: JsonReader): Array&lt;T&gt;
</code></pre>
<p>功能：从 <a href="encoding/json_stream/json_stream_package_api/../json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 中读取一个 Array。</p>
<p>参数：</p>
<ul>
<li>r: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> - 读取反序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 实例。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Array&lt;T&gt; - Array 类型的实例。</li>
</ul>
<h3 id="extendt-arraylistt--jsondeserializablearraylistt-where-t--jsondeserializablet"><a class="header" href="#extendt-arraylistt--jsondeserializablearraylistt-where-t--jsondeserializablet">extend&lt;T&gt; ArrayList&lt;T&gt; &lt;: JsonDeserializable&lt;ArrayList&lt;T&gt;&gt; where T &lt;: JsonDeserializable&lt;T&gt;</a></h3>
<pre><code class="language-cangjie">extend&lt;T&gt; ArrayList&lt;T&gt; &lt;: JsonDeserializable&lt;ArrayList&lt;T&gt;&gt; where T &lt;: JsonDeserializable&lt;T&gt;
</code></pre>
<p>功能：为 ArrayList 类型实现 JsonDeserializable 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsondeserializablet">JsonDeserializable</a>&lt;ArrayList&lt;T&gt;&gt;</li>
</ul>
<h4 id="static-func-fromjsonjsonreader-20"><a class="header" href="#static-func-fromjsonjsonreader-20">static func fromJson(JsonReader)</a></h4>
<pre><code class="language-cangjie">public static func fromJson(r: JsonReader): ArrayList&lt;T&gt;
</code></pre>
<p>功能：从 <a href="encoding/json_stream/json_stream_package_api/../json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 中读取一个 ArrayList。</p>
<p>参数：</p>
<ul>
<li>r: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> - 读取反序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 实例。</li>
</ul>
<p>返回值：</p>
<ul>
<li>ArrayList &lt;T&gt; - ArrayList 类型的实例。</li>
</ul>
<h3 id="extendt-option-t--jsondeserializableoptiont-where-t--jsondeserializablet"><a class="header" href="#extendt-option-t--jsondeserializableoptiont-where-t--jsondeserializablet">extend&lt;T&gt; Option &lt;T&gt; &lt;: JsonDeserializable&lt;Option&lt;T&gt;&gt; where T &lt;: JsonDeserializable&lt;T&gt;</a></h3>
<pre><code class="language-cangjie">extend&lt;T&gt; Option&lt;T&gt; &lt;: JsonDeserializable&lt;Option&lt;T&gt;&gt; where T &lt;: JsonDeserializable&lt;T&gt;
</code></pre>
<p>功能：为 Option 类型实现 JsonDeserializable 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsondeserializablet">JsonDeserializable</a>&lt;Option&lt;T&gt;&gt;</li>
</ul>
<h4 id="static-func-fromjsonjsonreader-21"><a class="header" href="#static-func-fromjsonjsonreader-21">static func fromJson(JsonReader)</a></h4>
<pre><code class="language-cangjie">public static func fromJson(r: JsonReader): Option&lt;T&gt;
</code></pre>
<p>功能：从 <a href="encoding/json_stream/json_stream_package_api/../json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 中读取一个Option。</p>
<p>参数：</p>
<ul>
<li>r: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> - 读取反序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 实例。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Option&lt;T&gt; - Option 类型的实例。</li>
</ul>
<h3 id="extendt-hashmapstring-t--jsondeserializablehashmapstring-t-where-t--jsondeserializablet"><a class="header" href="#extendt-hashmapstring-t--jsondeserializablehashmapstring-t-where-t--jsondeserializablet">extend&lt;T&gt; HashMap&lt;String, T&gt; &lt;: JsonDeserializable&lt;HashMap&lt;String, T&gt;&gt; where T &lt;: JsonDeserializable&lt;T&gt;</a></h3>
<pre><code class="language-cangjie">extend&lt;T&gt; HashMap&lt;String, T&gt; &lt;: JsonDeserializable&lt;HashMap&lt;String, T&gt;&gt; where T &lt;: JsonDeserializable&lt;T&gt;
</code></pre>
<p>功能：为 HashMap 类型实现 JsonDeserializable 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsondeserializablet">JsonDeserializable</a>&lt;HashMap&lt;String, T&gt;&gt;</li>
</ul>
<h4 id="static-func-fromjsonjsonreader-22"><a class="header" href="#static-func-fromjsonjsonreader-22">static func fromJson(JsonReader)</a></h4>
<pre><code class="language-cangjie">public static func fromJson(r: JsonReader): HashMap&lt;String, T&gt;
</code></pre>
<p>功能：从 <a href="encoding/json_stream/json_stream_package_api/../json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 中读取一个 HashMap。</p>
<p>参数：</p>
<ul>
<li>r: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> - 读取反序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 实例。</li>
</ul>
<p>返回值：</p>
<ul>
<li>HashMap&lt;String, T&gt; - HashMap&lt;String, T&gt; 类型的实例。</li>
</ul>
<h2 id="interface-jsonserializable"><a class="header" href="#interface-jsonserializable">interface JsonSerializable</a></h2>
<pre><code class="language-cangjie">public interface JsonSerializable {
    func toJson(w: JsonWriter): Unit
}
</code></pre>
<p>功能：为类型提供序列化到 JSON 数据流的接口。</p>
<p>与 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 搭配使用，<a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 可以将实现了 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsonserializable">JsonSerializable</a> 接口的类型写入到 Stream 中。</p>
<h3 id="func-tojsonjsonwriter"><a class="header" href="#func-tojsonjsonwriter">func toJson(JsonWriter)</a></h3>
<pre><code class="language-cangjie">func toJson(w: JsonWriter): Unit
</code></pre>
<p>功能：将实现了 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsonserializable">JsonSerializable</a> 接口的类型写入参数 <code>w</code> 指定的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例中。</p>
<p>参数：</p>
<ul>
<li>w: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> - 写入序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例。</li>
</ul>
<h3 id="extend-bigint--jsonserializable"><a class="header" href="#extend-bigint--jsonserializable">extend BigInt &lt;: JsonSerializable</a></h3>
<pre><code class="language-cangjie">extend BigInt &lt;: JsonSerializable
</code></pre>
<p>功能：为 BigInt 类型提供序列化到 JSON 数据流的接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsonserializable">JsonSerializable</a></li>
</ul>
<h4 id="func-tojsonjsonwriter-1"><a class="header" href="#func-tojsonjsonwriter-1">func toJson(JsonWriter)</a></h4>
<pre><code class="language-cangjie">public func toJson(w: JsonWriter): Unit
</code></pre>
<p>功能：将 BigInt 类型写入参数 <code>w</code> 指定的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例中。</p>
<p>参数：</p>
<ul>
<li>w: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> - 写入序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例。</li>
</ul>
<h3 id="extend-bool--jsonserializable"><a class="header" href="#extend-bool--jsonserializable">extend Bool &lt;: JsonSerializable</a></h3>
<pre><code class="language-cangjie">extend Bool &lt;: JsonSerializable
</code></pre>
<p>功能：为 Bool 类型提供序列化到 JSON 数据流的接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsonserializable">JsonSerializable</a></li>
</ul>
<h4 id="func-tojsonjsonwriter-2"><a class="header" href="#func-tojsonjsonwriter-2">func toJson(JsonWriter)</a></h4>
<pre><code class="language-cangjie">public func toJson(w: JsonWriter): Unit
</code></pre>
<p>功能：将 Bool 类型写入参数 <code>w</code> 指定的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例中。</p>
<p>参数：</p>
<ul>
<li>w: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> - 写入序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例。</li>
</ul>
<h3 id="extend-datetime--jsonserializable"><a class="header" href="#extend-datetime--jsonserializable">extend DateTime &lt;: JsonSerializable</a></h3>
<pre><code class="language-cangjie">extend DateTime &lt;: JsonSerializable
</code></pre>
<p>功能：为 DateTime 类型实现 JsonSerializable 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsonserializable">JsonSerializable</a></li>
</ul>
<h4 id="func-tojsonjsonwriter-3"><a class="header" href="#func-tojsonjsonwriter-3">func toJson(JsonWriter)</a></h4>
<pre><code class="language-cangjie">public func toJson(w: JsonWriter): Unit
</code></pre>
<p>功能：提供 DateTime 类型序列化到流的功能。</p>
<p>该接口的功能与 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 的 <a href="encoding/json_stream/json_stream_package_api/./encoding_json_stream_package_classes.html#var-writeconfig">writeConfig</a>中的属性 <a href="encoding/json_stream/json_stream_package_api/./encoding_json_stream_package_structs.html#prop-datetimeformat">dateTimeFormat</a>有关联，将会把 DateTime 按照<a href="encoding/json_stream/json_stream_package_api/./encoding_json_stream_package_structs.html#prop-datetimeformat">dateTimeFormat</a>中的格式输出到目标流中，可以通过修改<a href="encoding/json_stream/json_stream_package_api/./encoding_json_stream_package_structs.html#prop-datetimeformat">dateTimeFormat</a>实现不同的格式控制。</p>
<p>参数：</p>
<ul>
<li>w: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> - 写入序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例。</li>
</ul>
<h3 id="extend-decimal--jsonserializable"><a class="header" href="#extend-decimal--jsonserializable">extend Decimal &lt;: JsonSerializable</a></h3>
<pre><code class="language-cangjie">extend Decimal &lt;: JsonSerializable
</code></pre>
<p>功能：为 Decimal 类型提供序列化到 JSON 数据流的接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsonserializable">JsonSerializable</a></li>
</ul>
<h4 id="func-tojsonjsonwriter-4"><a class="header" href="#func-tojsonjsonwriter-4">func toJson(JsonWriter)</a></h4>
<pre><code class="language-cangjie">public func toJson(w: JsonWriter): Unit
</code></pre>
<p>功能：将 Decimal 类型写入参数 <code>w</code> 指定的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例中。</p>
<p>参数：</p>
<ul>
<li>w: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> - 写入序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例。</li>
</ul>
<h3 id="extend-float16--jsonserializable"><a class="header" href="#extend-float16--jsonserializable">extend Float16 &lt;: JsonSerializable</a></h3>
<pre><code class="language-cangjie">extend Float16 &lt;: JsonSerializable
</code></pre>
<p>功能：为 Float16 类型提供序列化到 JSON 数据流的接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsonserializable">JsonSerializable</a></li>
</ul>
<h4 id="func-tojsonjsonwriter-5"><a class="header" href="#func-tojsonjsonwriter-5">func toJson(JsonWriter)</a></h4>
<pre><code class="language-cangjie">public func toJson(w: JsonWriter): Unit
</code></pre>
<p>功能：将 Float16 类型写入参数 <code>w</code> 指定的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例中。</p>
<p>参数：</p>
<ul>
<li>w: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> - 写入序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例。</li>
</ul>
<h3 id="extend-float32--jsonserializable"><a class="header" href="#extend-float32--jsonserializable">extend Float32 &lt;: JsonSerializable</a></h3>
<pre><code class="language-cangjie">extend Float32 &lt;: JsonSerializable
</code></pre>
<p>功能：为 Float32 类型提供序列化到 JSON 数据流的接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsonserializable">JsonSerializable</a></li>
</ul>
<h4 id="func-tojsonjsonwriter-6"><a class="header" href="#func-tojsonjsonwriter-6">func toJson(JsonWriter)</a></h4>
<pre><code class="language-cangjie">public func toJson(w: JsonWriter): Unit
</code></pre>
<p>功能：将 Float32 类型写入参数 <code>w</code> 指定的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例中。</p>
<p>参数：</p>
<ul>
<li>w: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> - 写入序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例。</li>
</ul>
<h3 id="extend-float64--jsonserializable"><a class="header" href="#extend-float64--jsonserializable">extend Float64 &lt;: JsonSerializable</a></h3>
<pre><code class="language-cangjie">extend Float64 &lt;: JsonSerializable
</code></pre>
<p>功能：为 Float64 类型提供序列化到 JSON 数据流的接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsonserializable">JsonSerializable</a></li>
</ul>
<h4 id="func-tojsonjsonwriter-7"><a class="header" href="#func-tojsonjsonwriter-7">func toJson(JsonWriter)</a></h4>
<pre><code class="language-cangjie">public func toJson(w: JsonWriter): Unit
</code></pre>
<p>功能：将 Float64 类型写入参数 <code>w</code> 指定的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例中。</p>
<p>参数：</p>
<ul>
<li>w: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> - 写入序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例。</li>
</ul>
<h3 id="extend-string--jsonserializable"><a class="header" href="#extend-string--jsonserializable">extend String &lt;: JsonSerializable</a></h3>
<pre><code class="language-cangjie">extend String &lt;: JsonSerializable
</code></pre>
<p>功能：为 String 类型提供序列化到 JSON 数据流的接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsonserializable">JsonSerializable</a></li>
</ul>
<h4 id="func-tojsonjsonwriter-8"><a class="header" href="#func-tojsonjsonwriter-8">func toJson(JsonWriter)</a></h4>
<pre><code class="language-cangjie">public func toJson(w: JsonWriter): Unit
</code></pre>
<p>功能：将 String 类型写入参数 <code>w</code> 指定的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例中。写入的String</p>
<p>参数：</p>
<ul>
<li>w: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> - 写入序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例。</li>
</ul>
<h3 id="extend-int16--jsonserializable"><a class="header" href="#extend-int16--jsonserializable">extend Int16 &lt;: JsonSerializable</a></h3>
<pre><code class="language-cangjie">extend Int16 &lt;: JsonSerializable
</code></pre>
<p>功能：为 Int16 类型提供序列化到 JSON 数据流的接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsonserializable">JsonSerializable</a></li>
</ul>
<h4 id="func-tojsonjsonwriter-9"><a class="header" href="#func-tojsonjsonwriter-9">func toJson(JsonWriter)</a></h4>
<pre><code class="language-cangjie">public func toJson(w: JsonWriter): Unit
</code></pre>
<p>功能：将 Int16 类型写入参数 <code>w</code> 指定的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例中。</p>
<p>参数：</p>
<ul>
<li>w: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> - 写入序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例。</li>
</ul>
<h3 id="extend-int32--jsonserializable"><a class="header" href="#extend-int32--jsonserializable">extend Int32 &lt;: JsonSerializable</a></h3>
<pre><code class="language-cangjie">extend Int32 &lt;: JsonSerializable
</code></pre>
<p>功能：为 Int32 类型提供序列化到 JSON 数据流的接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsonserializable">JsonSerializable</a></li>
</ul>
<h4 id="func-tojsonjsonwriter-10"><a class="header" href="#func-tojsonjsonwriter-10">func toJson(JsonWriter)</a></h4>
<pre><code class="language-cangjie">public func toJson(w: JsonWriter): Unit
</code></pre>
<p>功能：将 Int32 类型写入参数 <code>w</code> 指定的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例中。</p>
<p>参数：</p>
<ul>
<li>w: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> - 写入序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例。</li>
</ul>
<h3 id="extend-int64--jsonserializable"><a class="header" href="#extend-int64--jsonserializable">extend Int64 &lt;: JsonSerializable</a></h3>
<pre><code class="language-cangjie">extend Int64 &lt;: JsonSerializable
</code></pre>
<p>功能：为 Int64 类型提供序列化到 JSON 数据流的接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsonserializable">JsonSerializable</a></li>
</ul>
<h4 id="func-tojsonjsonwriter-11"><a class="header" href="#func-tojsonjsonwriter-11">func toJson(JsonWriter)</a></h4>
<pre><code class="language-cangjie">public func toJson(w: JsonWriter): Unit
</code></pre>
<p>功能：将 Int64 类型写入参数 <code>w</code> 指定的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例中。</p>
<p>参数：</p>
<ul>
<li>w: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> - 写入序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例。</li>
</ul>
<h3 id="extend-int8--jsonserializable"><a class="header" href="#extend-int8--jsonserializable">extend Int8 &lt;: JsonSerializable</a></h3>
<pre><code class="language-cangjie">extend Int8 &lt;: JsonSerializable
</code></pre>
<p>功能：为 Int8 类型提供序列化到 JSON 数据流的接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsonserializable">JsonSerializable</a></li>
</ul>
<h4 id="func-tojsonjsonwriter-12"><a class="header" href="#func-tojsonjsonwriter-12">func toJson(JsonWriter)</a></h4>
<pre><code class="language-cangjie">public func toJson(w: JsonWriter): Unit
</code></pre>
<p>功能：将 Int8 类型写入参数 <code>w</code> 指定的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例中。</p>
<p>参数：</p>
<ul>
<li>w: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> - 写入序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例。</li>
</ul>
<h3 id="extend-intnative--jsonserializable"><a class="header" href="#extend-intnative--jsonserializable">extend IntNative &lt;: JsonSerializable</a></h3>
<pre><code class="language-cangjie">extend IntNative &lt;: JsonSerializable
</code></pre>
<p>功能：为 IntNative 类型提供序列化到 JSON 数据流的接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsonserializable">JsonSerializable</a></li>
</ul>
<h4 id="func-tojsonjsonwriter-13"><a class="header" href="#func-tojsonjsonwriter-13">func toJson(JsonWriter)</a></h4>
<pre><code class="language-cangjie">public func toJson(w: JsonWriter): Unit
</code></pre>
<p>功能：将 IntNative 类型写入参数 <code>w</code> 指定的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例中。</p>
<p>参数：</p>
<ul>
<li>w: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> - 写入序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例。</li>
</ul>
<h3 id="extend-uint16--jsonserializable"><a class="header" href="#extend-uint16--jsonserializable">extend UInt16 &lt;: JsonSerializable</a></h3>
<pre><code class="language-cangjie">extend UInt16 &lt;: JsonSerializable
</code></pre>
<p>功能：为 UInt16 类型提供序列化到 JSON 数据流的接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsonserializable">JsonSerializable</a></li>
</ul>
<h4 id="func-tojsonjsonwriter-14"><a class="header" href="#func-tojsonjsonwriter-14">func toJson(JsonWriter)</a></h4>
<pre><code class="language-cangjie">public func toJson(w: JsonWriter): Unit
</code></pre>
<p>功能：将 UInt16 类型写入参数 <code>w</code> 指定的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例中。</p>
<p>参数：</p>
<ul>
<li>w: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> - 写入序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例。</li>
</ul>
<h3 id="extend-uint32--jsonserializable"><a class="header" href="#extend-uint32--jsonserializable">extend UInt32 &lt;: JsonSerializable</a></h3>
<pre><code class="language-cangjie">extend UInt32 &lt;: JsonSerializable
</code></pre>
<p>功能：为 UInt32 类型提供序列化到 JSON 数据流的接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsonserializable">JsonSerializable</a></li>
</ul>
<h4 id="func-tojsonjsonwriter-15"><a class="header" href="#func-tojsonjsonwriter-15">func toJson(JsonWriter)</a></h4>
<pre><code class="language-cangjie">public func toJson(w: JsonWriter): Unit
</code></pre>
<p>功能：将 UInt32 类型写入参数 <code>w</code> 指定的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例中。</p>
<p>参数：</p>
<ul>
<li>w: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> - 写入序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例。</li>
</ul>
<h3 id="extend-uint64--jsonserializable"><a class="header" href="#extend-uint64--jsonserializable">extend UInt64 &lt;: JsonSerializable</a></h3>
<pre><code class="language-cangjie">extend UInt64 &lt;: JsonSerializable
</code></pre>
<p>功能：为 UInt64 类型提供序列化到 JSON 数据流的接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsonserializable">JsonSerializable</a></li>
</ul>
<h4 id="func-tojsonjsonwriter-16"><a class="header" href="#func-tojsonjsonwriter-16">func toJson(JsonWriter)</a></h4>
<pre><code class="language-cangjie">public func toJson(w: JsonWriter): Unit
</code></pre>
<p>功能：将 UInt64 类型写入参数 <code>w</code> 指定的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例中。</p>
<p>参数：</p>
<ul>
<li>w: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> - 写入序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例。</li>
</ul>
<h3 id="extend-uint8--jsonserializable"><a class="header" href="#extend-uint8--jsonserializable">extend UInt8 &lt;: JsonSerializable</a></h3>
<pre><code class="language-cangjie">extend UInt8 &lt;: JsonSerializable
</code></pre>
<p>功能：为 UInt8 类型提供序列化到 JSON 数据流的接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsonserializable">JsonSerializable</a></li>
</ul>
<h4 id="func-tojsonjsonwriter-17"><a class="header" href="#func-tojsonjsonwriter-17">func toJson(JsonWriter)</a></h4>
<pre><code class="language-cangjie">public func toJson(w: JsonWriter): Unit
</code></pre>
<p>功能：将 UInt8 类型写入参数 <code>w</code> 指定的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例中。</p>
<p>参数：</p>
<ul>
<li>w: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> - 写入序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例。</li>
</ul>
<h3 id="extend-uintnative--jsonserializable"><a class="header" href="#extend-uintnative--jsonserializable">extend UIntNative &lt;: JsonSerializable</a></h3>
<pre><code class="language-cangjie">extend UIntNative &lt;: JsonSerializable
</code></pre>
<p>功能：为 UIntNative 类型提供序列化到 JSON 数据流的接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsonserializable">JsonSerializable</a></li>
</ul>
<h4 id="func-tojsonjsonwriter-18"><a class="header" href="#func-tojsonjsonwriter-18">func toJson(JsonWriter)</a></h4>
<pre><code class="language-cangjie">public func toJson(w: JsonWriter): Unit
</code></pre>
<p>功能：将 UIntNative 类型写入参数 <code>w</code> 指定的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例中。</p>
<p>参数：</p>
<ul>
<li>w: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> - 写入序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例。</li>
</ul>
<h3 id="extendt-arrayt--jsonserializable-where-t--jsonserializable"><a class="header" href="#extendt-arrayt--jsonserializable-where-t--jsonserializable">extend&lt;T&gt; Array&lt;T&gt; &lt;: JsonSerializable where T &lt;: JsonSerializable</a></h3>
<pre><code class="language-cangjie">extend&lt;T&gt; Array&lt;T&gt; &lt;: JsonSerializable where T &lt;: JsonSerializable
</code></pre>
<p>功能：为 Array&lt;T&gt; 类型提供序列化到 JSON 数据流的接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsonserializable">JsonSerializable</a></li>
</ul>
<h4 id="func-tojsonjsonwriter-19"><a class="header" href="#func-tojsonjsonwriter-19">func toJson(JsonWriter)</a></h4>
<pre><code class="language-cangjie">public func toJson(w: JsonWriter): Unit
</code></pre>
<p>功能：将 Array&lt;T&gt; 类型写入参数 <code>w</code> 指定的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例中。</p>
<p>参数：</p>
<ul>
<li>w: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> - 写入序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例。</li>
</ul>
<h3 id="extendt-arraylistt--jsonserializable-where-t--jsonserializable"><a class="header" href="#extendt-arraylistt--jsonserializable-where-t--jsonserializable">extend&lt;T&gt; ArrayList&lt;T&gt; &lt;: JsonSerializable where T &lt;: JsonSerializable</a></h3>
<pre><code class="language-cangjie">extend&lt;T&gt; ArrayList&lt;T&gt; &lt;: JsonSerializable where T &lt;: JsonSerializable
</code></pre>
<p>功能：为 ArrayList&lt;T&gt; 类型提供序列化到 JSON 数据流的接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsonserializable">JsonSerializable</a></li>
</ul>
<h4 id="func-tojsonjsonwriter-20"><a class="header" href="#func-tojsonjsonwriter-20">func toJson(JsonWriter)</a></h4>
<pre><code class="language-cangjie">public func toJson(w: JsonWriter): Unit
</code></pre>
<p>功能：将 ArrayList&lt;T&gt; 类型写入参数 <code>w</code> 指定的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例中。</p>
<p>参数：</p>
<ul>
<li>w: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> - 写入序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例。</li>
</ul>
<h3 id="extendt-optiont--jsonserializable-where-t--jsonserializable"><a class="header" href="#extendt-optiont--jsonserializable-where-t--jsonserializable">extend&lt;T&gt; Option&lt;T&gt; &lt;: JsonSerializable where T &lt;: JsonSerializable</a></h3>
<pre><code class="language-cangjie">extend&lt;T&gt; Option&lt;T&gt; &lt;: JsonSerializable where T &lt;: JsonSerializable
</code></pre>
<p>功能：为 Option&lt;T&gt; 类型提供序列化到 JSON 数据流的接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsonserializable">JsonSerializable</a></li>
</ul>
<h4 id="func-tojsonjsonwriter-21"><a class="header" href="#func-tojsonjsonwriter-21">func toJson(JsonWriter)</a></h4>
<pre><code class="language-cangjie">public func toJson(w: JsonWriter): Unit
</code></pre>
<p>功能：将 Option&lt;T&gt; 类型写入参数 <code>w</code> 指定的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例中。</p>
<p>参数：</p>
<ul>
<li>w: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> - 写入序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例。</li>
</ul>
<h3 id="extendv-hashmapstring-v--jsonserializable-where-v--jsonserializable"><a class="header" href="#extendv-hashmapstring-v--jsonserializable-where-v--jsonserializable">extend&lt;V&gt; HashMap&lt;String, V&gt; &lt;: JsonSerializable where V &lt;: JsonSerializable</a></h3>
<pre><code class="language-cangjie">extend&lt;V&gt; HashMap&lt;String, V&gt; &lt;: JsonSerializable where V &lt;: JsonSerializable
</code></pre>
<p>功能：为 HashMap&lt;String, T&gt; 类型提供序列化到 JSON 数据流的接口。</p>
<p>父类型：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsonserializable">JsonSerializable</a></li>
</ul>
<h4 id="func-tojsonjsonwriter-22"><a class="header" href="#func-tojsonjsonwriter-22">func toJson(JsonWriter)</a></h4>
<pre><code class="language-cangjie">public func toJson(w: JsonWriter): Unit
</code></pre>
<p>功能：将 HashMap&lt;String, T&gt; 类型写入参数 <code>w</code> 指定的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例中。</p>
<p>参数：</p>
<ul>
<li>w: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> - 写入序列化结果的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 实例。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类-12"><a class="header" href="#类-12">类</a></h1>
<h2 id="class-jsonreader"><a class="header" href="#class-jsonreader">class JsonReader</a></h2>
<pre><code class="language-cangjie">public class JsonReader {
    public init(inputStream: InputStream)
}
</code></pre>
<p>功能：此类提供 JSON 数据流转仓颉对象的反序列化能力。</p>
<p>使用示例见<a href="encoding/json_stream/json_stream_package_api/../json_stream_samples/sample_json_reader.html">使用 Json Stream 进行反序列化</a></p>
<h3 id="initinputstream"><a class="header" href="#initinputstream">init(InputStream)</a></h3>
<pre><code class="language-cangjie">public init(inputStream: InputStream)
</code></pre>
<p>功能：根据输入流创建一个 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a>， <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a> 从输入流中读取数据时，将跳过非 <a href="encoding/json_stream/json_stream_package_api/../../json/json_package_api/encoding_json_package_classes.html#class-jsonstring">JsonString</a> 中的空字符（'\0', '\t', '\n', '\r'）。</p>
<p>参数：</p>
<ul>
<li>inputStream: InputStream - 输入的 JSON 数据流。</li>
</ul>
<h3 id="func-endarray"><a class="header" href="#func-endarray">func endArray()</a></h3>
<pre><code class="language-cangjie">public func endArray(): Unit
</code></pre>
<p>功能：从输入流的当前位置跳过空白字符后消耗一个 ']' 字符，<a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#func-endarray">endArray</a> 必须有一个 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#func-startarray">startArray</a> 与之对应。</p>
<p>异常：</p>
<ul>
<li>IllegalStateException - 如果输入流的 JSON 数据不符合格式，抛出异常。</li>
</ul>
<h3 id="func-endobject"><a class="header" href="#func-endobject">func endObject()</a></h3>
<pre><code class="language-cangjie">public func endObject(): Unit
</code></pre>
<p>功能：从输入流的当前位置跳过空白字符后消耗一个 '}' 字符，<a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#func-endobject">endObject</a> 必须有一个 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#func-startobject">startObject</a> 与之对应。</p>
<p>异常：</p>
<ul>
<li>IllegalStateException - 如果输入流的 JSON 数据不符合格式，抛出异常。</li>
</ul>
<h3 id="func-peek"><a class="header" href="#func-peek">func peek()</a></h3>
<pre><code class="language-cangjie">public func peek(): Option&lt;JsonToken&gt;
</code></pre>
<p>功能：获取输入流的下一个 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_enums.html#enum-jsontoken">JsonToken</a> 的类型，不保证下一个 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_enums.html#enum-jsontoken">JsonToken</a> 的格式一定正确。</p>
<p>例：如果输入流中的下一个字符为 't'，获取的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_enums.html#enum-jsontoken">JsonToken</a> 将为 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_enums.html#enum-jsontoken">JsonToken</a>.Bool，但调用 readValue&lt;Bool&gt;() 不一定成功。</p>
<p>返回值：</p>
<ul>
<li>Option&lt;<a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_enums.html#enum-jsontoken">JsonToken</a>&gt; - 获取到的下一个 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_enums.html#enum-jsontoken">JsonToken</a> 的类型，如果到了输入流的结尾返回 None。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalStateException - 如果输入流的下一个字符不在以下范围内：(n, t, f, &quot;, 0~9, -, {, }, [, ])。</li>
</ul>
<h3 id="func-readname"><a class="header" href="#func-readname">func readName()</a></h3>
<pre><code class="language-cangjie">public func readName(): String
</code></pre>
<p>功能：从输入流的当前位置读取一个 name。</p>
<p>返回值：</p>
<ul>
<li>String - 读取出的 name 值。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalStateException - 如果输入流的 JSON 数据不符合格式，抛出异常。</li>
</ul>
<h3 id="func-readvaluet-where-t--jsondeserializablet"><a class="header" href="#func-readvaluet-where-t--jsondeserializablet">func readValue&lt;T&gt;() where T &lt;: JsonDeserializable&lt;T&gt;</a></h3>
<pre><code class="language-cangjie">public func readValue&lt;T&gt;(): T where T &lt;: JsonDeserializable&lt;T&gt;
</code></pre>
<p>功能：从输入流的当前位置读取一个 value。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>当泛型 T 是 String 类型时，根据下一个 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_enums.html#enum-jsontoken">JsonToken</a> 的不同，该函数的返回值将会不同：</p>
<ul>
<li>
<p>当下一个 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_enums.html#enum-jsontoken">JsonToken</a> 是 <a href="encoding/json_stream/json_stream_package_api/../../json/json_package_api/encoding_json_package_classes.html#class-jsonstring">JsonString</a> 时， 反序列化过程会按照标准 <a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-404/">ECMA-404 The JSON Data Interchange Standard</a> 对读到的 String 进行转义。</p>
</li>
<li>
<p>当下一个 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_enums.html#enum-jsontoken">JsonToken</a> 是 <a href="encoding/json_stream/json_stream_package_api/../../json/json_package_api/encoding_json_package_classes.html#class-jsonint">JsonInt</a> <a href="encoding/json_stream/json_stream_package_api/../../json/json_package_api/encoding_json_package_classes.html#class-jsonfloat">JsonFloat</a> <a href="encoding/json_stream/json_stream_package_api/../../json/json_package_api/encoding_json_package_classes.html#class-jsonbool">JsonBool</a> <a href="encoding/json_stream/json_stream_package_api/../../json/json_package_api/encoding_json_package_classes.html#class-jsonnull">JsonNull</a> 其中一个时，将会读取下一个 <code>value</code> 字段的原始字符串并返回。</p>
</li>
<li>
<p>当下一个 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_enums.html#enum-jsontoken">JsonToken</a> 是其它类型时，调用此接口会抛异常。</p>
</li>
</ul>
</blockquote>
<p>返回值：</p>
<ul>
<li>T - 读取出的 value 值。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalStateException - 如果输入流的 JSON 数据不符合格式，抛出异常。</li>
</ul>
<h3 id="func-readvaluebytes"><a class="header" href="#func-readvaluebytes">func readValueBytes()</a></h3>
<pre><code class="language-cangjie">public func readValueBytes(): Array&lt;Byte&gt;
</code></pre>
<p>功能：读取输入流的下一组原始数据(字节数组)，不进行转义等操作。</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>readValueBytes 的规则如下：</p>
<ul>
<li>
<p>如果 next token 是 value，则读取这个 value 的所有原始字节，直到读取到代表结束的符号，如 ',' '}' ']'。</p>
</li>
<li>
<p>如果 next token 是 Name，读取 (name + value) 这一个组合的原始字节数组。</p>
</li>
<li>
<p>如果 next token 是 BeginArray，读取 Array 内的内的所有原始字节。</p>
</li>
<li>
<p>如果 next token 是 BeginObject，读取 Object 内的内的所有原始字节。</p>
</li>
<li>
<p>如果 next token 是 EndArray 或者 EndObject 或者 None，不做任何操作，返回空的数组，再次执行 peek() 仍返回 EndArray 或者 EndObject 或者 None。</p>
</li>
</ul>
</blockquote>
<p>返回值：</p>
<ul>
<li>Array&lt;Byte&gt; - 下一组数据对应的原始字节数据。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalStateException - 如果输入流的 JSON 数据不符合格式，抛出异常。</li>
</ul>
<h3 id="func-skip"><a class="header" href="#func-skip">func skip()</a></h3>
<pre><code class="language-cangjie">public func skip(): Unit
</code></pre>
<p>功能：从输入流的当前位置跳过一组数据。</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>Skip 的规则如下：</p>
<ul>
<li>
<p>如果 next token 是 value，跳过这个 value, 跳过 value 时不检查该 value 格式是否正确。</p>
</li>
<li>
<p>如果 next token 是 Name，跳过 (name + value) 这一个组合。</p>
</li>
<li>
<p>如果 next token 是 BeginArray，跳过这个 array。</p>
</li>
<li>
<p>如果 next token 是 BeginObject，跳过这个 object。</p>
</li>
<li>
<p>如果 next token 是 EndArray 或者 EndObject 或者 None，不做任何操作，peek 仍返回 EndArray 或者 EndObject 或者 None。</p>
</li>
</ul>
</blockquote>
<p>异常：</p>
<ul>
<li>IllegalStateException - 如果输入流的 JSON 数据不符合格式，抛出异常。</li>
</ul>
<h3 id="func-startarray"><a class="header" href="#func-startarray">func startArray()</a></h3>
<pre><code class="language-cangjie">public func startArray(): Unit
</code></pre>
<p>功能：从输入流的当前位置跳过空白字符后消耗一个 '[' 字符。</p>
<p>异常：</p>
<ul>
<li>IllegalStateException - 如果输入流的 JSON 数据不符合格式，抛出异常。</li>
</ul>
<h3 id="func-startobject"><a class="header" href="#func-startobject">func startObject()</a></h3>
<pre><code class="language-cangjie">public func startObject(): Unit
</code></pre>
<p>功能：从输入流的当前位置跳过空白字符后消耗一个 '{' 字符。</p>
<p>异常：</p>
<ul>
<li>IllegalStateException - 如果输入流的 JSON 数据不符合格式，抛出异常。</li>
</ul>
<h2 id="class-jsonwriter"><a class="header" href="#class-jsonwriter">class JsonWriter</a></h2>
<pre><code class="language-cangjie">public class JsonWriter {
    public var writeConfig = WriteConfig.compact
    public init(out: OutputStream)
}
</code></pre>
<p>功能：<a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 提供了将仓颉对象序列化到 OutputStream 的能力。</p>
<p><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 需要和 interface <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsonserializable">JsonSerializable</a> 搭配使用，<a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 可以通过 writeValue 来将实现了 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsonserializable">JsonSerializable</a> 接口的类型写入到 Stream 中。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 中使用缓存来减少写入 Stream 时的 IO 次数，在结束使用 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 之前需要调用 flush 函数来确保缓存中的数据全部写入 Stream。</p>
</blockquote>
<p>示例：</p>
<p>使用示例见<a href="encoding/json_stream/json_stream_package_api/../json_stream_samples/sample_json_writer.html">使用 Json Stream 进行序列化</a></p>
<h3 id="var-writeconfig"><a class="header" href="#var-writeconfig">var writeConfig</a></h3>
<pre><code class="language-cangjie">public var writeConfig = WriteConfig.compact
</code></pre>
<p>功能：序列化格式配置。详见 <a href="encoding/json_stream/json_stream_package_api/./encoding_json_stream_package_structs.html#struct-writeconfig">WriteConfig</a>。</p>
<h3 id="initoutputstream"><a class="header" href="#initoutputstream">init(OutputStream)</a></h3>
<pre><code class="language-cangjie">public init(out: OutputStream)
</code></pre>
<p>功能：构造函数，构造一个将数据写入 out 的实例。</p>
<p>参数：</p>
<ul>
<li>out: OutputStream - 目标流</li>
</ul>
<h3 id="func-endarray-1"><a class="header" href="#func-endarray-1">func endArray()</a></h3>
<pre><code class="language-cangjie">public func endArray(): Unit
</code></pre>
<p>功能：结束序列化当前的 JSON 数组。</p>
<p>异常：</p>
<ul>
<li>IllegalStateException - 当前 writer 没有匹配的 startArray 时。</li>
</ul>
<h3 id="func-endobject-1"><a class="header" href="#func-endobject-1">func endObject()</a></h3>
<pre><code class="language-cangjie">public func endObject(): Unit
</code></pre>
<p>功能：结束序列化当前的 JSON object。</p>
<p>异常：</p>
<ul>
<li>IllegalStateException - 当前 writer 的状态不应该结束一个 JSON object 时。</li>
</ul>
<h3 id="func-flush-2"><a class="header" href="#func-flush-2">func flush()</a></h3>
<pre><code class="language-cangjie">public func flush(): Unit
</code></pre>
<p>功能：将缓存中的数据写入 out，并且调用 out 的 flush 方法。</p>
<h3 id="func-jsonvaluestring"><a class="header" href="#func-jsonvaluestring">func jsonValue(String)</a></h3>
<pre><code class="language-cangjie">public func jsonValue(value: String): JsonWriter
</code></pre>
<p>功能: 将符合JSON value规范的原始字符串写入stream。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>此函数不会对值 value 进行转义，也不会为入参添加双引号。如果使用者能够保证输入的值 value 符合数据转换标准<a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-404/">ECMA-404 The JSON Data Interchange Standard</a>， 建议使用该函数。</p>
</blockquote>
<p>返回值：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> - 为方便链式调用，返回值为当前 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 的引用。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalStateException - 当前 writer 的状态不应该写入 value 时。</li>
</ul>
<h3 id="func-startarray-1"><a class="header" href="#func-startarray-1">func startArray()</a></h3>
<pre><code class="language-cangjie">public func startArray(): Unit
</code></pre>
<p>功能：开始序列化一个新的 JSON 数组，每一个 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#func-startarray-1">startArray</a> 都必须有一个 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#func-endarray-1">endArray</a> 对应。</p>
<p>异常：</p>
<ul>
<li>IllegalStateException - 当前 writer 的状态不应该写入 JSON array 时。</li>
</ul>
<h3 id="func-startobject-1"><a class="header" href="#func-startobject-1">func startObject()</a></h3>
<pre><code class="language-cangjie">public func startObject(): Unit
</code></pre>
<p>功能：开始序列化一个新的 JSON object，每一个 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#func-startobject-1">startObject</a> 都必须有一个 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#func-endobject-1">endObject</a> 对应。</p>
<p>异常：</p>
<ul>
<li>IllegalStateException - 当前 writer 的状态不应该写入 JSON object 时。</li>
</ul>
<h3 id="func-writenamestring"><a class="header" href="#func-writenamestring">func writeName(String)</a></h3>
<pre><code class="language-cangjie">public func writeName(name: String): JsonWriter
</code></pre>
<p>功能：在 object 结构中写入 name。</p>
<p>返回值：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> - 当前 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 引用。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalStateException - 当前 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 的状态不应写入参数 <code>name</code> 指定字符串时。</li>
</ul>
<h3 id="func-writenullvalue"><a class="header" href="#func-writenullvalue">func writeNullValue()</a></h3>
<pre><code class="language-cangjie">public func writeNullValue(): JsonWriter
</code></pre>
<p>功能：向流中写入 JSON value null。</p>
<p>返回值：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> - 为方便链式调用，返回值为当前 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 的引用。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalStateException - 当前 writer 的状态不应该写入 value 时</li>
</ul>
<h3 id="func-writevaluett-where-t--jsonserializable"><a class="header" href="#func-writevaluett-where-t--jsonserializable">func writeValue&lt;T&gt;(T) where T &lt;: JsonSerializable</a></h3>
<pre><code class="language-cangjie">public func writeValue&lt;T&gt;(v: T): JsonWriter where T &lt;: JsonSerializable
</code></pre>
<p>功能：将实现了 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsonserializable">JsonSerializable</a> 接口的类型写入到 Stream 中。该接口会调用泛型 T 的 toJson 方法向输出流中写入数据。</p>
<p>json.stream 包已经为基础类型 Int64、UInt64、Float64、Bool、String类型扩展实现了 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsonserializable">JsonSerializable</a>， 并且为 Collection 类型 Array、ArrayList和 HashMap 扩展实现了 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html#interface-jsonserializable">JsonSerializable</a>。</p>
<p>返回值：</p>
<ul>
<li><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> - 返回当前 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 的引用。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalStateException - 当前 writer 的状态不应该写入 value 时。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="枚举-9"><a class="header" href="#枚举-9">枚举</a></h1>
<h2 id="enum-jsontoken"><a class="header" href="#enum-jsontoken">enum JsonToken</a></h2>
<pre><code class="language-cangjie">public enum JsonToken &lt;: Equatable&lt;JsonToken&gt; &amp; Hashable{
    | JsonNull
    | JsonBool
    | JsonNumber
    | JsonString
    | BeginArray
    | EndArray
    | BeginObject
    | EndObject
    | Name
}
</code></pre>
<p>功能：表示 JSON 编码的字符串中的结构、名称或者值类型。</p>
<p><a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_enums.html#enum-jsontoken">JsonToken</a> 通常和 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a>.peek()搭配使用，通过对返回值的判断来决定具体的处理方式。</p>
<p>父类型：</p>
<ul>
<li>Equatable&lt;<a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_enums.html#enum-jsontoken">JsonToken</a>&gt;</li>
<li>Hashable</li>
</ul>
<h3 id="beginarray"><a class="header" href="#beginarray">BeginArray</a></h3>
<pre><code class="language-cangjie">BeginArray
</code></pre>
<p>功能：表示 JSON 中 array 的开始。如果 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a>.peek() 返回的是该类型，可以使用 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a>.startArray() 读取。</p>
<h3 id="beginobject"><a class="header" href="#beginobject">BeginObject</a></h3>
<pre><code class="language-cangjie">BeginObject
</code></pre>
<p>功能：表示 JSON 中 object 的开始。如果 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a>.peek() 返回的是该类型，可以使用 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a>.startObject() 读取。</p>
<h3 id="endarray"><a class="header" href="#endarray">EndArray</a></h3>
<pre><code class="language-cangjie">EndArray
</code></pre>
<p>功能：表示 JSON 中 array 的结束。如果 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a>.peek() 返回的是该类型，可以使用 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a>.endArray() 读取。</p>
<h3 id="endobject"><a class="header" href="#endobject">EndObject</a></h3>
<pre><code class="language-cangjie">EndObject
</code></pre>
<p>功能：表示 JSON 中 object 的结束。如果 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a>.peek() 返回的是该类型，可以使用 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a>.endObject() 读取。</p>
<h3 id="jsonbool"><a class="header" href="#jsonbool">JsonBool</a></h3>
<pre><code class="language-cangjie">JsonBool
</code></pre>
<p>功能：表示 JSON 的 bool 类型。如果 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a>.peek() 返回的是该类型，可以使用 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a>.readValue&lt;Bool&gt;() 读取。</p>
<h3 id="jsonnull"><a class="header" href="#jsonnull">JsonNull</a></h3>
<pre><code class="language-cangjie">JsonNull
</code></pre>
<p>功能：表示 JSON 的 null 类型。如果 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a>.peek() 返回的是该类型，可以使用 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a>.readValue&lt;Option&lt;T&gt;&gt;() 读取。</p>
<h3 id="jsonnumber"><a class="header" href="#jsonnumber">JsonNumber</a></h3>
<pre><code class="language-cangjie">JsonNumber
</code></pre>
<p>功能：表示 JSON 的 number 类型。如果 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a>.peek() 返回的是该类型，可以使用 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a>.readValue&lt;Float64&gt;() 读取。</p>
<h3 id="jsonstring"><a class="header" href="#jsonstring">JsonString</a></h3>
<pre><code class="language-cangjie">JsonString
</code></pre>
<p>功能：表示 JSON 的 string 类型。如果 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a>.peek() 返回的是该类型，可以使用 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a>.readValue&lt;String&gt;() 读取。</p>
<h3 id="name"><a class="header" href="#name">Name</a></h3>
<pre><code class="language-cangjie">Name
</code></pre>
<p>功能：表示 object 中的 name。如果 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a>.peek() 返回的是该类型，可以使用 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html#class-jsonreader">JsonReader</a>.readName() 读取。</p>
<h3 id="func-hashcode-5"><a class="header" href="#func-hashcode-5">func hashCode()</a></h3>
<pre><code class="language-cangjie">public func hashCode(): Int64
</code></pre>
<p>功能：获取 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_enums.html#enum-jsontoken">JsonToken</a> 对象的 hashCode 值。</p>
<p>返回值：</p>
<ul>
<li>Int64 - hashCode 值。</li>
</ul>
<h3 id="operator-func-jsontoken"><a class="header" href="#operator-func-jsontoken">operator func !=(JsonToken)</a></h3>
<pre><code class="language-cangjie">public operator func !=(that: JsonToken): Bool
</code></pre>
<p>功能：判不等。</p>
<p>参数：</p>
<ul>
<li>that: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_enums.html#enum-jsontoken">JsonToken</a> - 被比较的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_enums.html#enum-jsontoken">JsonToken</a> 对象</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - 当前实例与 that 不相等返回 true，否则返回 false</li>
</ul>
<h3 id="operator-func-jsontoken-1"><a class="header" href="#operator-func-jsontoken-1">operator func ==(JsonToken)</a></h3>
<pre><code class="language-cangjie">public operator func ==(that: JsonToken): Bool
</code></pre>
<p>功能：判等。</p>
<p>参数：</p>
<ul>
<li>that: <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_enums.html#enum-jsontoken">JsonToken</a> - 被比较的 <a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_enums.html#enum-jsontoken">JsonToken</a> 对象</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - 当前实例与 that 相等返回 true，否则返回 false</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="结构体-9"><a class="header" href="#结构体-9">结构体</a></h1>
<h2 id="struct-writeconfig"><a class="header" href="#struct-writeconfig">struct WriteConfig</a></h2>
<pre><code class="language-cangjie">public struct WriteConfig {
    public static let compact: WriteConfig
    public static let pretty: WriteConfig
}
</code></pre>
<p>功能：用于表示 <a href="encoding/json_stream/json_stream_package_api/./encoding_json_stream_package_classes.html#class-jsonwriter">JsonWriter</a> 的序列化格式配置。</p>
<p>示例：</p>
<p>使用示例见 <a href="encoding/json_stream/json_stream_package_api/../json_stream_samples/sample_json_writeconfig.html#writeconfig-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B">WriteConfig 使用示例</a>。</p>
<h3 id="static-let-compact"><a class="header" href="#static-let-compact">static let compact</a></h3>
<pre><code class="language-cangjie">public static let compact: WriteConfig
</code></pre>
<p>功能：提供紧凑的序列化格式。</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>compact 的各属性值为：</p>
<ul>
<li>newline: &quot;&quot;，空字符串。</li>
<li>indent: &quot;&quot;，空字符串。</li>
<li>useSpaceAfterSeparators: false。</li>
<li>htmlSafe: false。</li>
<li>dateTimeFormat: DateTimeFormat.RFC3339。</li>
</ul>
</blockquote>
<p>类型：<a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_structs.html#struct-writeconfig">WriteConfig</a></p>
<p>示例：</p>
<pre><code class="language-text">{&quot;Name&quot;:&quot;zhangsan&quot;,&quot;Age&quot;:18,&quot;Scores&quot;:[88.8,99.9],&quot;Class&quot;:{&quot;Name&quot;:&quot;Class A&quot;,&quot;Students Number&quot;:33}}
</code></pre>
<h3 id="static-let-pretty"><a class="header" href="#static-let-pretty">static let pretty</a></h3>
<pre><code class="language-cangjie">public static let pretty: WriteConfig
</code></pre>
<p>功能：提供整洁的序列化格式。</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>pretty 的各属性值为：</p>
<ul>
<li>newline: &quot;\n&quot;。</li>
<li>indent: &quot;    &quot;，包含4个空格的字符串。</li>
<li>useSpaceAfterSeparators: true。</li>
<li>htmlSafe: false。</li>
<li>dateTimeFormat: DateTimeFormat.RFC3339。</li>
</ul>
</blockquote>
<p>类型：<a href="encoding/json_stream/json_stream_package_api/encoding_json_stream_package_structs.html#struct-writeconfig">WriteConfig</a></p>
<p>示例：</p>
<pre><code class="language-text">{
    &quot;Name&quot;: &quot;zhangsan&quot;,
    &quot;Age&quot;: 18,
    &quot;Scores&quot;: [
        88.8,
        99.9
    ],
    &quot;Class&quot;: {
        &quot;Name&quot;: &quot;Class A&quot;,
        &quot;Students Number&quot;: 33
    }
}
</code></pre>
<h3 id="prop-datetimeformat"><a class="header" href="#prop-datetimeformat">prop dateTimeFormat</a></h3>
<pre><code class="language-cangjie">public mut prop dateTimeFormat: String
</code></pre>
<p>功能：用于序列化 DateTime 类型时的格式控制，功能与 DateTime 的 func toString(DateTimeFormat) 一致。</p>
<p>类型：String</p>
<h3 id="prop-htmlsafe"><a class="header" href="#prop-htmlsafe">prop htmlSafe</a></h3>
<pre><code class="language-cangjie">public mut prop htmlSafe: Bool
</code></pre>
<p>功能：用于表示是否转义 HTML 字符 <code>&lt;</code>、<code>&gt;</code>、<code>&amp;</code>、<code>=</code>和<code>'</code>。</p>
<p>该值为 true 时，会将 HTML 字符转义为对应的 Unicode 编码的字符串。</p>
<p>该选项只对 json value 中的字符串字面量有效。</p>
<p>类型：Bool</p>
<h3 id="prop-indent"><a class="header" href="#prop-indent">prop indent</a></h3>
<pre><code class="language-cangjie">public mut prop indent: String
</code></pre>
<p>功能：用于表示序列化时每个缩进级别填入的缩进字符串。取值应匹配正则 <code>^[ \t]*$</code>。</p>
<p>当上述的换行起作用时，该值会作为换行后的填充符。</p>
<p>类型：String</p>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 设置的字符串包含 ' ' 或者 '\t' 以外的字符。</li>
</ul>
<h3 id="prop-newline"><a class="header" href="#prop-newline">prop newline</a></h3>
<pre><code class="language-cangjie">public mut prop newline: String
</code></pre>
<p>功能：用于表示序列化时填入的换行符。取值应匹配正则 <code>^[\r\n]*$</code> 。</p>
<p>当该值不为空字符串且合法时，JsonWriter 调用 startObject 和 startArray 操作、插入元素、以及它们的结束操作会产生新的换行。</p>
<p>当该值为空字符串时，不会触发换行。</p>
<p>类型：String</p>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 设置的字符串包含 '\r' 或者 '\n' 以外的字符。</li>
</ul>
<h3 id="prop-usespaceafterseparators"><a class="header" href="#prop-usespaceafterseparators">prop useSpaceAfterSeparators</a></h3>
<pre><code class="language-cangjie">public mut prop useSpaceAfterSeparators: Bool
</code></pre>
<p>功能：用于表示序列化时在 ':' 和 ',' 后是否加一个空格。</p>
<p>该值为 true 时，每插入一个 field name 或者 array 元素后会自动写入一个空格。</p>
<p>该选项只对 json Object 中的 field 以及 json Array 中的元素有效。</p>
<p>类型：Bool</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用-json-stream-进行反序列化"><a class="header" href="#使用-json-stream-进行反序列化">使用 Json Stream 进行反序列化</a></h1>
<p>示例：</p>
<!-- verify -->
<pre><code class="language-cangjie">import stdx.encoding.json.stream.*
import std.io.*
import std.collection.*

class A &lt;: JsonDeserializable&lt;A&gt; {
    var key1: Option&lt;String&gt; = None
    var key2: Bool = false
    var key3: Float64 = 0.0
    var key4: String = &quot;&quot;
    var key5: Array&lt;Int64&gt; = Array&lt;Int64&gt;()
    var key6: HashMap&lt;String, String&gt; = HashMap&lt;String, String&gt;()

    public static func fromJson(r: JsonReader): A {
        var res = A()
        while (let Some(v) &lt;- r.peek()) {
            match (v) {
                case BeginObject =&gt;
                    r.startObject()
                    while (r.peek() != EndObject) {
                        let n = r.readName()
                        match (n) {
                            case &quot;key1&quot; =&gt; res.key1 = r.readValue&lt;Option&lt;String&gt;&gt;()
                            case &quot;key2&quot; =&gt; res.key2 = r.readValue&lt;Bool&gt;()
                            case &quot;key3&quot; =&gt; res.key3 = r.readValue&lt;Float64&gt;()
                            case &quot;key4&quot; =&gt; res.key4 = r.readValue&lt;String&gt;()
                            case &quot;key5&quot; =&gt; res.key5 = r.readValue&lt;Array&lt;Int64&gt;&gt;()
                            case &quot;key6&quot; =&gt; res.key6 = r.readValue&lt;HashMap&lt;String, String&gt;&gt;()
                            case _ =&gt; ()
                        }
                    }
                    r.endObject()
                    break
                case _ =&gt; throw Exception()
            }
        }
        return res
    }

    func toString(): String {
        return &quot;${key1}\n${key2}\n${key3}\n${key4}\n${key5}\n${key6}&quot;
    }
}

main() {
    let jsonStr = ##&quot;{&quot;key1&quot;: null, &quot;key2&quot;: true, &quot;key3&quot;: 123.456, &quot;key4&quot;: &quot;string&quot;, &quot;key5&quot;: [123, 456], &quot;key6&quot;: {&quot;key7&quot;: &quot; &quot;, &quot;key8&quot;: &quot;\\a&quot;}}&quot;##
    var bas = ByteBuffer()
    unsafe { bas.write(jsonStr.rawData()) }
    var reader = JsonReader(bas)
    var obj = A.fromJson(reader)
    println(obj.toString())
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-text">None
true
123.456000
string
[123, 456]
[(key7,  ), (key8, \a)]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用-json-stream-进行序列化"><a class="header" href="#使用-json-stream-进行序列化">使用 Json Stream 进行序列化</a></h1>
<p>示例：</p>
<!-- verify -->
<pre><code class="language-cangjie">import stdx.encoding.json.stream.*
import std.io.{ByteBuffer, readToEnd}

class Image &lt;: JsonSerializable {
    var width: Int64
    var height: Int64
    var title: String
    var ids: Array&lt;Int64&gt;

    public init() {
        width = 0
        height = 0
        title = &quot;&quot;
        ids = Array&lt;Int64&gt;()
    }

    public func toJson(w: JsonWriter): Unit {
        w.startObject()
        w.writeName(&quot;Width&quot;).writeValue(width)
        w.writeName(&quot;Height&quot;).writeValue(height)
        w.writeName(&quot;Title&quot;).writeValue(title)
        w.writeName(&quot;Ids&quot;).writeValue&lt;Array&lt;Int64&gt;&gt;(ids)
        w.endObject()
    }
}

main() {
    let image = Image()
    image.width = 800
    image.height = 600
    image.title = &quot;View from 15th Floor&quot;
    image.ids = [116, 943, 234, 38793]

    let stream = ByteBuffer()
    let writer = JsonWriter(stream)

    /* 将图片序列化 */
    writer.writeValue(image)
    writer.flush()
    println(String.fromUtf8(readToEnd(stream)))
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-text">{&quot;Width&quot;:800,&quot;Height&quot;:600,&quot;Title&quot;:&quot;View from 15th Floor&quot;,&quot;Ids&quot;:[116,943,234,38793]}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writeconfig-使用示例"><a class="header" href="#writeconfig-使用示例">WriteConfig 使用示例</a></h1>
<p>示例：</p>
<!-- verify -->
<pre><code class="language-cangjie">import stdx.encoding.json.stream.{JsonWriter, WriteConfig, JsonSerializable}
import std.io.ByteBuffer

main() {
    /* 构造 JsonWriter */
    let buffer = ByteBuffer()
    let writer = JsonWriter(buffer)

    /* 设置 JSON 写格式配置 */
    let fmtCfg = WriteConfig.pretty
    writer.writeConfig = fmtCfg

    /* 写 JSON  */
    writer.writeValue(MyObj())

    /* 打印 JSON 序列化字符串 */
    println(String.fromUtf8(buffer.bytes()))
}

class MyObj &lt;: JsonSerializable {
    public func toJson(w: JsonWriter): Unit {
        w.startObject()
        w.writeName(&quot;Name&quot;).writeValue(&quot;zhangsan&quot;)
        w.writeName(&quot;Age&quot;).writeValue(18)
        w.writeName(&quot;Scores&quot;).writeValue([88.8, 99.9])
        w.writeName(&quot;Class&quot;)
        w.startObject()
        w.writeName(&quot;Name&quot;).writeValue(&quot;Class A&quot;)
        w.writeName(&quot;Students Number&quot;).writeValue(33)
        w.endObject()
        w.endObject()
        w.flush()
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-text">{
    &quot;Name&quot;: &quot;zhangsan&quot;,
    &quot;Age&quot;: 18,
    &quot;Scores&quot;: [
        88.8,
        99.9
    ],
    &quot;Class&quot;: {
        &quot;Name&quot;: &quot;Class A&quot;,
        &quot;Students Number&quot;: 33
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdxencodingurl"><a class="header" href="#stdxencodingurl">stdx.encoding.url</a></h1>
<h2 id="功能介绍-9"><a class="header" href="#功能介绍-9">功能介绍</a></h2>
<p>url 包提供了 URL 相关的能力，包括解析 URL 的各个组件，对 URL 进行编解码，合并 URL 或路径等。</p>
<p>URL（Uniform Resource Locator）是统一资源定位符的缩写，它是用来标识互联网上资源位置的一种地址。通常包含协议、主机名、路径和查询参数等信息，其中协议是指访问资源所使用的协议（如 HTTP、FTP 等），主机名是指资源所在的服务器的域名或 IP 地址，路径是指资源所在的具体位置，查询参数是指用于传递参数的字符串。URL 是互联网上标识资源的唯一方式，通过 URL 可以访问网页、图片、视频等各种类型的资源。</p>
<p>URL 一般是以下格式：</p>
<pre><code class="language-text">scheme://host[:port]/path[?query][#fragment]
</code></pre>
<p>其中：</p>
<ul>
<li><code>scheme</code>：协议，例如 <code>http</code>、<code>https</code>、<code>ftp</code> 等；</li>
<li><code>host</code>：主机名或 IP 地址；</li>
<li><code>port</code>：端口号，可选，默认为协议默认端口；</li>
<li><code>path</code>：资源路径，例如 <code>/index.html</code>、<code>/blog/post/123</code> 等；</li>
<li><code>query</code>：查询参数，例如 <code>?page=2&amp;sort=desc</code> 等，可选；</li>
<li><code>fragment</code>：文档片段标识符，例如 <code>#section-1</code>，可选。</li>
</ul>
<p>例如，网址 <code>https://www.example.com/blog/post/123?page=2&amp;sort=desc#section-1</code> 的 URL 格式为：</p>
<ul>
<li>scheme: https</li>
<li>host: <code>www.example.com</code></li>
<li>path: /blog/post/123</li>
<li>query: ?page=2&amp;sort=desc</li>
<li>fragment: #section-1</li>
</ul>
<p>URL 编码的原因和基本过程：</p>
<p>URL 编码是将 URL 中的非 ASCII 字符转换为一种可读性更好的 ASCII 字符的过程。这是因为 URL 中只允许包含 ASCII 字符，而非 ASCII 字符可能会导致 URL 解析错误或传输失败。</p>
<p>URL 编码的基本过程如下：</p>
<ol>
<li>将 URL 字符串转换为字节数组。</li>
<li>对于每个非 <code>ASCII</code> 字符，将其转换为 <code>UTF-8</code> 编码的字节序列。</li>
<li>对于每个字节，将其转换为两个十六进制数字。</li>
<li>在每个十六进制数字前添加一个百分号（%）。</li>
<li>将所有编码后的字符连接起来形成编码后的 URL 字符串。</li>
</ol>
<p>例如，将字符串“你好，世界！”进行 URL 编码，结果为“%E4%BD%A0%E5%A5%BD%EF%BC%8C%E4%B8%96%E7%95%8C%EF%BC%81”。</p>
<h2 id="api-列表-9"><a class="header" href="#api-列表-9">API 列表</a></h2>
<h3 id="类-13"><a class="header" href="#类-13">类</a></h3>
<div class="table-wrapper"><table><thead><tr><th>类名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="encoding/url/./url_package_api/url_package_classes.html#class-form">Form</a></td><td>Form 以 key-value 键值对形式存储 http 请求的参数，同一个 key 可以对应多个 value，value 以数组形式存储。</td></tr>
<tr><td><a href="encoding/url/./url_package_api/url_package_classes.html#class-url">URL</a></td><td>该类提供解析 URL 的函数以及其他相关函数。</td></tr>
<tr><td><a href="encoding/url/./url_package_api/url_package_classes.html#class-userinfo">UserInfo</a></td><td>UserInfo 表示 URL 中用户名和密码信息。</td></tr>
</tbody></table>
</div>
<h3 id="异常类-9"><a class="header" href="#异常类-9">异常类</a></h3>
<div class="table-wrapper"><table><thead><tr><th>异常类名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="encoding/url/./url_package_api/url_package_exceptions.html#class-urlsyntaxexception">UrlSyntaxException</a></td><td>url 解析异常类。</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="类-14"><a class="header" href="#类-14">类</a></h1>
<h2 id="class-form"><a class="header" href="#class-form">class Form</a></h2>
<pre><code class="language-cangjie">public class Form {
    public init()
    public init(queryComponent: String)
}
</code></pre>
<p>功能：<a href="encoding/url/url_package_api/url_package_classes.html#class-form">Form</a> 以 key-value 键值对形式存储 http 请求的表单信息，通常为请求 <a href="encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 中的 query 部分。</p>
<p>同一个 key 可以对应多个 value，value 以数组形式存储。<code>&amp;</code> 符号分隔多个键值对；<code>=</code> 分隔的左侧作为 key 值，右侧作为 value 值（没有 <code>=</code> 或者 value 为空，均是允许的）。使用示例见 <a href="encoding/url/url_package_api/../url_samples/form.html#Form-%E7%9A%84%E6%9E%84%E9%80%A0%E4%BD%BF%E7%94%A8">Form 的构造使用</a>。</p>
<h3 id="init-14"><a class="header" href="#init-14">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="encoding/url/url_package_api/url_package_classes.html#class-form">Form</a> 实例。</p>
<h3 id="initstring-6"><a class="header" href="#initstring-6">init(String)</a></h3>
<pre><code class="language-cangjie">public init(queryComponent: String)
</code></pre>
<p>功能：根据 <a href="encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 编码的查询字符串，即 <a href="encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 实例的 query 部分构造 <a href="encoding/url/url_package_api/url_package_classes.html#class-form">Form</a> 实例。</p>
<p>解析 <a href="encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 编码的查询字符串，得到若干键值对，并将其添加到新构造的 <a href="encoding/url/url_package_api/url_package_classes.html#class-form">Form</a> 实例中。</p>
<p>参数：</p>
<ul>
<li>queryComponent: String - <a href="encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 的 query 组件部分的字符串，但是不包括组件前面的 <code>?</code> 符号。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 当<a href="encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 字符串中包含不符合 utf8 编码规则的字节时，抛出异常。</li>
<li><a href="encoding/url/url_package_api/url_package_exceptions.html#class-urlsyntaxexception">UrlSyntaxException</a> - 当 <a href="encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 字符串中包含非法转义字符时，抛出异常。</li>
</ul>
<h3 id="func-addstring-string"><a class="header" href="#func-addstring-string">func add(String, String)</a></h3>
<pre><code class="language-cangjie">public func add(key: String, value: String): Unit
</code></pre>
<p>功能：新增 key-value 映射，如果 key 已存在，则将 value 添加到原来 value 数组的最后面。</p>
<p>参数：</p>
<ul>
<li>key: String - 指定键，可以是新增的。</li>
<li>value: String - 将该值添加到指定键对应的值数组中。</li>
</ul>
<h3 id="func-clone"><a class="header" href="#func-clone">func clone()</a></h3>
<pre><code class="language-cangjie">public func clone(): Form
</code></pre>
<p>功能：克隆 <a href="encoding/url/url_package_api/url_package_classes.html#class-form">Form</a>。</p>
<p>返回值：</p>
<ul>
<li><a href="encoding/url/url_package_api/url_package_classes.html#class-form">Form</a> - 克隆得到的新 <a href="encoding/url/url_package_api/url_package_classes.html#class-form">Form</a> 实例。</li>
</ul>
<h3 id="func-getstring-1"><a class="header" href="#func-getstring-1">func get(String)</a></h3>
<pre><code class="language-cangjie">public func get(key: String): Option&lt;String&gt;
</code></pre>
<p>功能：根据 key 获取第一个对应的 value 值。</p>
<p>举例：</p>
<ul>
<li>当 query 组件部分是 <code>a=b</code> 时，<code>form.get(&quot;a&quot;)</code>获得 <code>Some(b)</code>。</li>
<li>当 query 组件部分是 <code>a=</code> 时，<code>form.get(&quot;a&quot;)</code>获得 <code>Some()</code>。</li>
<li>当 query 组件部分是 <code>a</code> 时，<code>form.get(&quot;a&quot;)</code>获得 <code>Some()</code>。</li>
<li>当 query 组件部分是 <code>a</code> 时，<code>form.get(&quot;c&quot;)</code>获得 <code>None</code>。</li>
</ul>
<p>参数：</p>
<ul>
<li>key: String - 指定键。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Option&lt;String&gt; - 根据指定键获取的第一个值，用 Option&lt;String&gt; 类型表示。</li>
</ul>
<h3 id="func-getallstring"><a class="header" href="#func-getallstring">func getAll(String)</a></h3>
<pre><code class="language-cangjie">public func getAll(key: String): ArrayList&lt;String&gt;
</code></pre>
<p>功能：根据指定的键（key）获取该键（key）对应的所有 value 值。</p>
<p>参数：</p>
<ul>
<li>key: String - 用户指定的键（key），用于获取对应的 value 值。</li>
</ul>
<p>返回值：</p>
<ul>
<li>ArrayList&lt;String&gt; - 根据指定键（key）获取的全部 value 值对应的数组。当指定键（key）不存在时，返回空数组。</li>
</ul>
<h3 id="func-isempty-1"><a class="header" href="#func-isempty-1">func isEmpty()</a></h3>
<pre><code class="language-cangjie">public func isEmpty(): Bool
</code></pre>
<p>功能：判断 <a href="encoding/url/url_package_api/url_package_classes.html#class-form">Form</a> 是否为空。</p>
<p>返回值：</p>
<ul>
<li>Bool - 如果为空，则返回 true；否则，返回 false。</li>
</ul>
<h3 id="func-removestring"><a class="header" href="#func-removestring">func remove(String)</a></h3>
<pre><code class="language-cangjie">public func remove(key: String): Unit
</code></pre>
<p>功能：删除 key 及其对应 value。</p>
<p>参数：</p>
<ul>
<li>key: String - 需要删除的键。</li>
</ul>
<h3 id="func-setstring-string"><a class="header" href="#func-setstring-string">func set(String, String)</a></h3>
<pre><code class="language-cangjie">public func set(key: String, value: String): Unit
</code></pre>
<p>功能：重置指定 key 对应的 value。</p>
<p>参数：</p>
<ul>
<li>key: String - 指定键。</li>
<li>value: String - 将指定键的值设置为 value。</li>
</ul>
<h3 id="func-toencodestring"><a class="header" href="#func-toencodestring">func toEncodeString()</a></h3>
<pre><code class="language-cangjie">public func toEncodeString(): String
</code></pre>
<p>功能：对表单中的键值对进行编码，编码采用百分号编码。</p>
<p>未保留字符不会被编码，空格将编码为 '+'。</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>RFC 3986 协议中对未保留字符定义如下： unreserved = ALPHA / DIGIT / &quot;-&quot; / &quot;.&quot; / &quot;_&quot; / &quot;~&quot;</p>
</blockquote>
<p>返回值：</p>
<ul>
<li>String - 编码后的字符串。</li>
</ul>
<h2 id="class-url"><a class="header" href="#class-url">class URL</a></h2>
<pre><code class="language-cangjie">public class URL &lt;: ToString {
    public init(scheme!: String, hostName!: String, path!: String)
}
</code></pre>
<p>功能：该类提供解析 <a href="encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 的函数以及其他相关函数。</p>
<p>字符串中被百分号<code>%</code>编码的内容会被解码，保存在相应的组件之中，而初始值保存在相应的 <code>raw</code> 属性之中。<a href="encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 中的用户名和密码部分（如果存在的话）也会按照 RFC 3986 协议的说明被解析。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>RFC 3986 明确说明在任何场景下，明文保存用户信息存在被泄露风险，所以建议不要在 URL 中明文保存用户信息。</p>
</blockquote>
<p>父类型：</p>
<ul>
<li>ToString</li>
</ul>
<h3 id="prop-fragment"><a class="header" href="#prop-fragment">prop fragment</a></h3>
<pre><code class="language-cangjie">public prop fragment: ?String
</code></pre>
<p>功能：获取解码后的锚点组件，用字符串表示。</p>
<p>类型：?String</p>
<h3 id="prop-host"><a class="header" href="#prop-host">prop host</a></h3>
<pre><code class="language-cangjie">public prop host: String
</code></pre>
<p>功能：获取解码后的主机名和端口部分，用字符串表示。</p>
<p>类型：String</p>
<h3 id="prop-hostname"><a class="header" href="#prop-hostname">prop hostName</a></h3>
<pre><code class="language-cangjie">public prop hostName: String
</code></pre>
<p>功能：获取解码后的主机名，用字符串表示。</p>
<p>类型：String</p>
<h3 id="prop-opaque"><a class="header" href="#prop-opaque">prop opaque</a></h3>
<pre><code class="language-cangjie">public prop opaque: String
</code></pre>
<p>功能：获取 <a href="encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 中未被解析的部分，用字符串表示。</p>
<p>类型：String</p>
<p>示例：</p>
<pre><code class="language-cangjie">import stdx.encoding.url.*

main () {
    let url = URL.parse(&quot;https:\\\\/example.com/foo/bar&quot;) // '\' 不是协议规定的分割符，无法被解析。
    println(&quot;url.scheme=${url.scheme}&quot;)
    println(&quot;url.host=${url.host}&quot;)
    println(&quot;url.opaque=${url.opaque}&quot;)
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-text">url.scheme=https
url.host=
url.opaque=\\/example.com/foo/bar
</code></pre>
<h3 id="prop-path"><a class="header" href="#prop-path">prop path</a></h3>
<pre><code class="language-cangjie">public prop path: String
</code></pre>
<p>功能：获取解码后的路径，用字符串表示。</p>
<p>类型：String</p>
<h3 id="prop-port"><a class="header" href="#prop-port">prop port</a></h3>
<pre><code class="language-cangjie">public prop port: String
</code></pre>
<p>功能：获取端口号，用字符串表示，空字符串表示无端口号。</p>
<p>类型：String</p>
<h3 id="prop-query"><a class="header" href="#prop-query">prop query</a></h3>
<pre><code class="language-cangjie">public prop query: ?String
</code></pre>
<p>功能：获取解码后的查询组件，用字符串表示。</p>
<p>类型：?String</p>
<h3 id="prop-queryform"><a class="header" href="#prop-queryform">prop queryForm</a></h3>
<pre><code class="language-cangjie">public prop queryForm: Form
</code></pre>
<p>功能：获取解码后的查询组件，用 <a href="encoding/url/url_package_api/url_package_classes.html#class-form">Form</a> 实例表示。</p>
<p>类型：<a href="encoding/url/url_package_api/url_package_classes.html#class-form">Form</a></p>
<h3 id="prop-rawfragment"><a class="header" href="#prop-rawfragment">prop rawFragment</a></h3>
<pre><code class="language-cangjie">public prop rawFragment: ?String
</code></pre>
<p>功能：获取解码前的锚点组件，用字符串表示。</p>
<p>类型：?String</p>
<h3 id="prop-rawpath"><a class="header" href="#prop-rawpath">prop rawPath</a></h3>
<pre><code class="language-cangjie">public prop rawPath: String
</code></pre>
<p>功能：获取解码前的路径，用字符串表示。</p>
<p>类型：String</p>
<h3 id="prop-rawquery"><a class="header" href="#prop-rawquery">prop rawQuery</a></h3>
<pre><code class="language-cangjie">public prop rawQuery: ?String
</code></pre>
<p>功能：获取解码前的查询组件，用字符串表示。</p>
<p>类型：?String</p>
<h3 id="prop-rawuserinfo"><a class="header" href="#prop-rawuserinfo">prop rawUserInfo</a></h3>
<pre><code class="language-cangjie">public prop rawUserInfo: UserInfo
</code></pre>
<p>功能：获取解码前的用户名和密码信息，用 <a href="encoding/url/url_package_api/url_package_classes.html#class-userinfo">UserInfo</a> 实例表示。</p>
<p>类型：<a href="encoding/url/url_package_api/url_package_classes.html#class-userinfo">UserInfo</a></p>
<h3 id="prop-scheme"><a class="header" href="#prop-scheme">prop scheme</a></h3>
<pre><code class="language-cangjie">public prop scheme: String
</code></pre>
<p>功能：获取 <a href="encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 中协议部分，用字符串表示。</p>
<p>类型：String</p>
<h3 id="prop-userinfo"><a class="header" href="#prop-userinfo">prop userInfo</a></h3>
<pre><code class="language-cangjie">public prop userInfo: UserInfo
</code></pre>
<p>功能：获取解码后的用户名和密码信息，用 <a href="encoding/url/url_package_api/url_package_classes.html#class-userinfo">UserInfo</a> 实例表示。</p>
<p>类型：<a href="encoding/url/url_package_api/url_package_classes.html#class-userinfo">UserInfo</a></p>
<h3 id="initstring-string-string"><a class="header" href="#initstring-string-string">init(String, String, String)</a></h3>
<pre><code class="language-cangjie">public init(scheme!: String, hostName!: String, path!: String)
</code></pre>
<p>功能：构造一个 <a href="encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 实例。</p>
<p>构造实例时需要满足要求：</p>
<ul>
<li>拥有主机名 hostName 时，需要有协议 scheme。</li>
<li>不能只存在协议 scheme。</li>
<li>存在协议和路径的情况下，路径 path 必须是绝对路径。</li>
</ul>
<p>参数：</p>
<ul>
<li>scheme!: String - 协议类型。</li>
<li>hostName!: String - 不包含端口号的主机名。</li>
<li>path!: String - 请求资源的路径。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="encoding/url/url_package_api/url_package_exceptions.html#class-urlsyntaxexception">UrlSyntaxException</a> - 当构造实例不满足要求时，抛出异常。</li>
</ul>
<h3 id="static-func-mergepathsstring-string"><a class="header" href="#static-func-mergepathsstring-string">static func mergePaths(String, String)</a></h3>
<pre><code class="language-cangjie">public static func mergePaths(basePath: String, refPath: String): String
</code></pre>
<p>功能：合并两个路径。</p>
<p>合并规则：将引用路径 refPath 追加到基础路径 basePath 的最后一段。如果 refPath 是绝对路径，结果就是 refPath 原本的值。如果 refPath 不是绝对路径，则将自身拼接至 basePath 最后一个 <code>/</code> 后，所有结果最终都会进行标准化（路径中的<code>.</code>字符，<code>..</code>字符，以及多个连续的 <code>/</code> 字符都会被优化）。具体行为可以参照下面示例。更详细行为参考 RFC 3986 协议。</p>
<p>如需合并 URL 请使用 <a href="encoding/url/url_package_api/url_package_classes.html#func-resolveurlurl">resolveURL</a>。</p>
<p>例如：</p>
<ul>
<li><code>/a/b/c</code> 合并 <code>/d</code> 输出 <code>/d</code>。</li>
<li><code>/a/b/c</code> 合并 <code>d</code> 输出 <code>/a/b/d</code>。</li>
<li><code>/a/b/</code> 合并 <code>d/e/../f</code> 输出 <code>/a/b/d/f</code>。</li>
<li><code>/a/b/c/</code> 合并 <code>./../../g</code> 输出 <code>/a/g</code>。</li>
</ul>
<p>参数：</p>
<ul>
<li>basePath: String - 基础路径。</li>
<li>refPath: String - 引用路径。</li>
</ul>
<p>返回值：</p>
<ul>
<li>String - 合并且标准化后的路径。</li>
</ul>
<h3 id="static-func-parsestring"><a class="header" href="#static-func-parsestring">static func parse(String)</a></h3>
<pre><code class="language-cangjie">public static func parse(rawUrl: String): URL
</code></pre>
<p>功能：将原始 URL 字符串解析成 <a href="encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 对象。</p>
<p>这个函数会将 <a href="encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 按照组件分解，然后分别进行解码并存储在相应的组件属性中，而 rawXXX (此处泛指前缀是 raw 的 URL 属性)属性部分存储的是原始值，不做编解码处理。</p>
<p>使用示例请参见<a href="encoding/url/url_package_api/./../url_samples/url_parse.html#url-%E8%A7%A3%E6%9E%90%E5%87%BD%E6%95%B0-parse-%E7%9A%84%E4%BD%BF%E7%94%A8">URL 解析函数 parse 的使用</a>。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>该函数可以解析 URL 中的用户名和密码（如果存在），这是符合 RFC 3986 协议的解析功能的，但是 RFC 3986 也明确指出，任何场景下，明文保存用户信息存在被泄露风险，所以建议不要在 URL 中明文保存用户信息。</p>
</blockquote>
<p>参数：</p>
<ul>
<li>rawUrl: String - <a href="encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 字符串。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> - 解析字符串得到的 <a href="encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 实例。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="encoding/url/url_package_api/url_package_exceptions.html#class-urlsyntaxexception">UrlSyntaxException</a> - 当 <a href="encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 字符串中包含非法字符时，抛出异常。</li>
<li>IllegalArgumentException - 当被编码的字符不符合 <code>UTF-8</code> 的字节序列规则时，抛出异常。</li>
</ul>
<h3 id="func-isabsoluteurl"><a class="header" href="#func-isabsoluteurl">func isAbsoluteURL()</a></h3>
<pre><code class="language-cangjie">public func isAbsoluteURL(): Bool
</code></pre>
<p>功能：判断 <a href="encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 是否为绝对 <a href="encoding/url/url_package_api/url_package_classes.html#class-url">URL</a>（scheme 存在时，<a href="encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 是绝对 <a href="encoding/url/url_package_api/url_package_classes.html#class-url">URL</a>）。</p>
<p>返回值：</p>
<ul>
<li>Bool - scheme 存在时返回 true，不存在时返回 false。</li>
</ul>
<h3 id="func-replaceoptionstring-optionstring-optionstring-optionstring-optionstring-optionstring-optionstring"><a class="header" href="#func-replaceoptionstring-optionstring-optionstring-optionstring-optionstring-optionstring-optionstring">func replace(Option&lt;String&gt;, Option&lt;String&gt;, Option&lt;String&gt;, Option&lt;String&gt;, Option&lt;String&gt;, Option&lt;String&gt;, Option&lt;String&gt;)</a></h3>
<pre><code class="language-cangjie">public func replace(scheme!: Option&lt;String&gt; = None, userInfo!: Option&lt;String&gt; = None,
 hostName!: Option&lt;String&gt; = None, port!: Option&lt;String&gt; = None, path!: Option&lt;String&gt; = None, 
 query!: Option&lt;String&gt; = None, fragment!: Option&lt;String&gt; = None): URL
</code></pre>
<p>功能：替换 <a href="encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 对象的各组件，并且返回一个新的 <a href="encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 对象。</p>
<p>替换时需要满足以下要求：</p>
<ul>
<li>方案 scheme 为空时，主机名必须为空。</li>
<li>主机名为空时，用户信息或端口号必须为空。</li>
<li>方案 scheme 不为空时，主机名和路径不能同时为空。</li>
<li>方案 scheme 不为空时，路径必须是绝对路径。</li>
<li>任意组件均为合法字符。</li>
</ul>
<p>参数：</p>
<ul>
<li>scheme!: Option&lt;String&gt; - 协议组件。</li>
<li>userInfo!: Option&lt;String&gt; - 用户信息。</li>
<li>hostName!: Option&lt;String&gt; - 主机名。</li>
<li>port!: Option&lt;String&gt; - 端口号。</li>
<li>path!: Option&lt;String&gt; - 资源路径。</li>
<li>query!: Option&lt;String&gt; - 查询组件。</li>
<li>fragment!: Option&lt;String&gt; - 锚点组件。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> - 新的 <a href="encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 对象。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="encoding/url/url_package_api/url_package_exceptions.html#class-urlsyntaxexception">UrlSyntaxException</a> - 不满足替换要求时，抛出异常。</li>
</ul>
<h3 id="func-resolveurlurl"><a class="header" href="#func-resolveurlurl">func resolveURL(URL)</a></h3>
<pre><code class="language-cangjie">public func resolveURL(ref: URL): URL
</code></pre>
<p>功能：以当前 <a href="encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 实例为基础 <a href="encoding/url/url_package_api/url_package_classes.html#class-url">URL</a>，以传入的 <a href="encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 为参考 <a href="encoding/url/url_package_api/url_package_classes.html#class-url">URL</a>，根据 RFC 3986 协议生成一个新的 <a href="encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 实例。</p>
<p>例如：<a href="http://a/b/c/d;p?q">http://a/b/c/d;p?q</a> 为基础 <a href="encoding/url/url_package_api/url_package_classes.html#class-url">URL</a>，以下 = 左边为参考 <a href="encoding/url/url_package_api/url_package_classes.html#class-url">URL</a>，右边为生成的新 <a href="encoding/url/url_package_api/url_package_classes.html#class-url">URL</a>：</p>
<ul>
<li>&quot;g&quot;      =  &quot;<a href="http://a/b/c/g">http://a/b/c/g</a>&quot;</li>
<li>&quot;/g&quot;     =  &quot;<a href="http://a/g">http://a/g</a>&quot;</li>
<li>&quot;g?y&quot;    =  &quot;<a href="http://a/b/c/g?y">http://a/b/c/g?y</a>&quot;</li>
<li>&quot;g?y#s&quot;  =  &quot;<a href="http://a/b/c/g?y#s">http://a/b/c/g?y#s</a>&quot;</li>
<li>&quot;../&quot;    =  &quot;<a href="http://a/b/">http://a/b/</a>&quot;</li>
</ul>
<p>更多详细的 URL 生成规则，请参见 RFC 3968 协议。</p>
<p>参数：</p>
<ul>
<li>ref: <a href="encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> - 参考 <a href="encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 对象。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> - 新的 <a href="encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 实例。</li>
</ul>
<h3 id="func-tostring-26"><a class="header" href="#func-tostring-26">func toString()</a></h3>
<pre><code class="language-cangjie">public func toString(): String
</code></pre>
<p>功能：获取当前 <a href="encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 实例的字符串值。</p>
<p>会把 hostName 编码，其余部分取 rawXXX (此处泛指前缀是 raw 的 URL 属性)属性值，按照 URL 组件构成顺序进行拼接而获得该函数返回值。</p>
<p>返回值：</p>
<ul>
<li>String - 当前 <a href="encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 实例的字符串值。</li>
</ul>
<h2 id="class-userinfo"><a class="header" href="#class-userinfo">class UserInfo</a></h2>
<pre><code class="language-cangjie">public class UserInfo &lt;: ToString {
    public init()
    public init(userName: String)
    public init(userName: String, passWord: String)
    public init(userName: String, passWord: Option&lt;String&gt;)
}
</code></pre>
<p>功能：<a href="encoding/url/url_package_api/url_package_classes.html#class-userinfo">UserInfo</a> 表示 URL 中用户名和密码信息。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>RFC 3986 明确指出，任何场景下，明文保存用户信息存在被泄露风险，所以建议不要在 URL 中明文保存用户信息。</p>
</blockquote>
<p>父类型：</p>
<ul>
<li>ToString</li>
</ul>
<h3 id="init-15"><a class="header" href="#init-15">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：创建 <a href="encoding/url/url_package_api/url_package_classes.html#class-userinfo">UserInfo</a> 实例。</p>
<h3 id="initstring-7"><a class="header" href="#initstring-7">init(String)</a></h3>
<pre><code class="language-cangjie">public init(userName: String)
</code></pre>
<p>功能：根据用户名创建 <a href="encoding/url/url_package_api/url_package_classes.html#class-userinfo">UserInfo</a> 实例。</p>
<p>参数：</p>
<ul>
<li>userName: String - 用户名。</li>
</ul>
<h3 id="initstring-optionstring"><a class="header" href="#initstring-optionstring">init(String, Option&lt;String&gt;)</a></h3>
<pre><code class="language-cangjie">public init(userName: String, passWord: Option&lt;String&gt;)
</code></pre>
<p>功能：根据用户名和密码创建 <a href="encoding/url/url_package_api/url_package_classes.html#class-userinfo">UserInfo</a> 实例。
参数：</p>
<ul>
<li>userName: String - 用户名。</li>
<li>passWord: Option&lt;String&gt; - 密码，用 Option&lt;String&gt; 类型表示。</li>
</ul>
<h3 id="initstring-string"><a class="header" href="#initstring-string">init(String, String)</a></h3>
<pre><code class="language-cangjie">public init(userName: String, passWord: String)
</code></pre>
<p>功能：根据用户名和密码创建 <a href="encoding/url/url_package_api/url_package_classes.html#class-userinfo">UserInfo</a> 实例。
参数：</p>
<ul>
<li>userName: String - 用户名。</li>
<li>passWord: String - 密码。</li>
</ul>
<h3 id="func-password"><a class="header" href="#func-password">func password()</a></h3>
<pre><code class="language-cangjie">public func password(): Option&lt;String&gt;
</code></pre>
<p>功能：获取密码信息。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>RFC 3986 明确指出，任何场景下，明文保存用户信息存在被泄露风险，所以建议不要在 URL 中明文保存用户信息。</p>
</blockquote>
<p>返回值：</p>
<ul>
<li>Option&lt;String&gt; - 将密码以 Option&lt;String&gt; 形式返回。</li>
</ul>
<h3 id="func-tostring-27"><a class="header" href="#func-tostring-27">func toString()</a></h3>
<pre><code class="language-cangjie">public func toString(): String
</code></pre>
<p>功能：将当前 <a href="encoding/url/url_package_api/url_package_classes.html#class-userinfo">UserInfo</a> 实例转换为字符串。</p>
<p>返回值：</p>
<ul>
<li>String - 当前 <a href="encoding/url/url_package_api/url_package_classes.html#class-userinfo">UserInfo</a> 实例的字符串表示。</li>
</ul>
<h3 id="func-username"><a class="header" href="#func-username">func username()</a></h3>
<pre><code class="language-cangjie">public func username(): String
</code></pre>
<p>功能：获取用户名信息。</p>
<p>返回值：</p>
<ul>
<li>String - 字符串类型的用户名。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="异常类-10"><a class="header" href="#异常类-10">异常类</a></h1>
<h2 id="class-urlsyntaxexception"><a class="header" href="#class-urlsyntaxexception">class UrlSyntaxException</a></h2>
<pre><code class="language-cangjie">public class UrlSyntaxException &lt;: Exception {
    public init(reason: String)
    public init(input: String, reason: String)
    public init(input: String, reason: String, pos: String)
}
</code></pre>
<p>功能：URL 解析异常类。</p>
<p>父类型：</p>
<ul>
<li>Exception</li>
</ul>
<h3 id="initstring-8"><a class="header" href="#initstring-8">init(String)</a></h3>
<pre><code class="language-cangjie">public init(reason: String)
</code></pre>
<p>功能：根据错误原因构造 <a href="encoding/url/url_package_api/url_package_exceptions.html#class-urlsyntaxexception">UrlSyntaxException</a> 实例。</p>
<p>参数：</p>
<ul>
<li>reason: String - 解析错误的原因。</li>
</ul>
<h3 id="initstring-string-1"><a class="header" href="#initstring-string-1">init(String, String)</a></h3>
<pre><code class="language-cangjie">public init(input: String, reason: String)
</code></pre>
<p>功能：根据 URL 及错误原因构造 <a href="encoding/url/url_package_api/url_package_exceptions.html#class-urlsyntaxexception">UrlSyntaxException</a> 实例。</p>
<p>参数：</p>
<ul>
<li>input: String - 原生 URL 或其片段。</li>
<li>reason: String - 解析错误的原因。</li>
</ul>
<h3 id="initstring-string-string-1"><a class="header" href="#initstring-string-string-1">init(String, String, String)</a></h3>
<pre><code class="language-cangjie">public init(input: String, reason: String, pos: String)
</code></pre>
<p>功能：根据 URL 字符串，错误原因以及解析失败的部分，构造 <a href="encoding/url/url_package_api/url_package_exceptions.html#class-urlsyntaxexception">UrlSyntaxException</a> 实例。</p>
<p>参数：</p>
<ul>
<li>input: String - 原生 URL 或其片段。</li>
<li>reason: String - 解析错误的原因。</li>
<li>pos: String - 给定 URL 字符串中解析失败的部分。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="form-的构造使用"><a class="header" href="#form-的构造使用">Form 的构造使用</a></h1>
<h2 id="form-的构造与其函数-get-的使用"><a class="header" href="#form-的构造与其函数-get-的使用">Form 的构造与其函数 get 的使用</a></h2>
<p>创建 Form 类，并通过 get 获取 key 对应映射的 value。示例中使用 Form 类的函数 get 获取指定 key = 1 的 value 值 2 。</p>
<p>示例：</p>
<!-- verify -->
<pre><code class="language-cangjie">import stdx.encoding.url.*

main(): Int64 {
    var s = Form(&quot;1=2&amp;2=3&amp;1=2&amp;&amp;&quot;)
    print(s.get(&quot;1&quot;).getOrThrow())
    return 0
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-text">2
</code></pre>
<h2 id="form-的构造与重复-key-情况下函数-get-的使用"><a class="header" href="#form-的构造与重复-key-情况下函数-get-的使用">Form 的构造与重复 key 情况下函数 get 的使用</a></h2>
<p>创建 Form 类，并通过 get 获取 key 对应映射的 value。示例中使用 Form 类的函数 get 获取指定 key = 1 的第一个 value 值 %6AD。value 中的 %6A 被解码为 j，因此得到 value 值 jD 。</p>
<p>示例：</p>
<!-- verify -->
<pre><code class="language-cangjie">import stdx.encoding.url.*

main(): Int64 {
    var s = Form(&quot;2=3&amp;1=%6AD&amp;1=2&quot;)
    /* 对于 %6A 解码成 j，重复的 key 调用 get 获取第一个 value 值 jD */
    print(s.get(&quot;1&quot;).getOrThrow())
    return 0
}
</code></pre>
<p>运行结果如下：</p>
<pre><code class="language-text">jD
</code></pre>
<h2 id="form-的构造与其他函数使用"><a class="header" href="#form-的构造与其他函数使用">Form 的构造与其他函数使用</a></h2>
<p>分别调用 add，set，clone，打印输出前后变化。</p>
<p>示例：</p>
<!-- verify -->
<pre><code class="language-cangjie">import stdx.encoding.url.*

main(): Int64 {
    var f = Form()
    
    /* 给键 k 增加值 v1 和 v2 */
    f.add(&quot;k&quot;, &quot;v1&quot;)
    f.add(&quot;k&quot;, &quot;v2&quot;)

    /* 调用 get 方法时，获取的是第一个值 */
    println(f.get(&quot;k&quot;).getOrThrow())

    /* 设定键 k 的值为 v */
    f.set(&quot;k&quot;, &quot;v&quot;)
    println(f.get(&quot;k&quot;).getOrThrow())
    let clone_f = f.clone()

    /* 给克隆出来的 clone_f 增加键值对 */
    clone_f.add(&quot;k1&quot;, &quot;v1&quot;)

    /* 通过 get 获得值 v1 */
    println(clone_f.get(&quot;k1&quot;).getOrThrow())

    /* 原来的 f 并没有键 k1，所以值是给的默认值 kkk */
    println(f.get(&quot;k1&quot;) ?? &quot;kkk&quot;)
    return 0
}
</code></pre>
<p>运行结果如下：</p>
<pre><code class="language-text">v1
v
v1
kkk
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="url-解析函数-parse-的使用"><a class="header" href="#url-解析函数-parse-的使用">URL 解析函数 parse 的使用</a></h1>
<p>使用 parse 函数解析 URL 字符串，生成 URL 对象。示例中对一个地址进行了解析并获得了 URL 对象，并且打印该对象的各个属性。</p>
<p>示例：</p>
<!-- verify -->
<pre><code class="language-cangjie">import stdx.encoding.url.*

main(): Int64 {
    /* 调用 URL 静态函数 parse 解析网址获得名为 url 的对象 */
    var url = URL.parse(
        &quot;http://www.example.com:80/path%E4%BB%93%E9%A2%89?key=value%E4%BB%93%E9%A2%89#%E4%BD%A0%E5%A5%BD&quot;)

    /* 打印 url 的组件属性 */
    println(&quot;url.scheme = ${url.scheme}&quot;)
    println(&quot;url.opaque = ${url.opaque}&quot;)
    println(&quot;url.userInfo = ${url.userInfo}&quot;)
    println(&quot;url.rawUserInfo = ${url.rawUserInfo}&quot;)
    println(&quot;url.host = ${url.host}&quot;)
    println(&quot;url.hostName = ${url.hostName}&quot;)
    println(&quot;url.port = ${url.port}&quot;)
    println(&quot;url.path = ${url.path}&quot;)
    println(&quot;url.rawPath = ${url.rawPath}&quot;)
    println(&quot;url.query = ${url.query.getOrThrow()}&quot;)
    println(&quot;url.rawQuery = ${url.rawQuery.getOrThrow()}&quot;)
    println(&quot;url.fragment = ${url.fragment.getOrThrow()}&quot;)
    println(&quot;url.rawfragment = ${url.rawFragment.getOrThrow()}&quot;)
    println(&quot;url = ${url}&quot;)
    return 0
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-text">url.scheme = http
url.opaque =
url.userInfo =
url.rawUserInfo =
url.host = www.example.com:80
url.hostName = www.example.com
url.port = 80
url.path = /path仓颉
url.rawPath = /path%E4%BB%93%E9%A2%89
url.query = key=value仓颉
url.rawQuery = key=value%E4%BB%93%E9%A2%89
url.fragment = 你好
url.rawfragment = %E4%BD%A0%E5%A5%BD
url = http://www.example.com:80/path%E4%BB%93%E9%A2%89?key=value%E4%BB%93%E9%A2%89#%E4%BD%A0%E5%A5%BD
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdxfuzzfuzz"><a class="header" href="#stdxfuzzfuzz">stdx.fuzz.fuzz</a></h1>
<h2 id="功能介绍-10"><a class="header" href="#功能介绍-10">功能介绍</a></h2>
<p>Fuzz 技术是一种自动化软件测试方法，旨在发现软件中的漏洞和错误。它通过持续输入随机的或经过变异的测试用例来执行软件程序，并根据程序的覆盖率信息来指导测试的方向。</p>
<p>fuzz 包为开发者提供基于覆盖率反馈的仓颉 fuzz 引擎及对应的接口，开发者可以编写代码对 API 进行测试。当前支持通过传入 fuzz 引擎变异的字节流 (Array&lt;UInt8&gt;) 或符合仓颉的标准数据类型（FuzzDataProvider）进行 fuzz 测试。</p>
<p>使用此包需要配合覆盖率反馈插桩（SanitizerCoverage）功能使用，需要开发者对 fuzz 测试有一定的了解，初学者建议先学习 C 语言的 Fuzz 工具 <a href="https://llvm.org/docs/LibFuzzer.html">libFuzzer</a>。</p>
<p>使用本包需要外部依赖 LLVM 套件 <code>compiler-rt</code> 提供的 <code>libclang_rt.fuzzer_no_main.a</code> 静态库，当前支持 Linux 以及 macOS，不支持 Windows。</p>
<p>通常使用包管理工具即可完成安装，例如 <code>Ubuntu 22.04</code> 系统上可使用 <code>sudo apt install clang</code> 进行安装，安装后可以在 <code>clang -print-runtime-dir</code> 指向的目录下找到对应的 <code>libclang_rt.fuzzer_no_main.a</code> 文件，例如 <code>/usr/lib/llvm-14/lib/clang/14.0.0/lib/linux/libclang_rt.fuzzer_no_main-x86_64.a</code>，将来在链接时会用到它。</p>
<h2 id="api-列表-10"><a class="header" href="#api-列表-10">API 列表</a></h2>
<h3 id="类-15"><a class="header" href="#类-15">类</a></h3>
<div class="table-wrapper"><table><thead><tr><th>类名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="fuzz/./fuzz_package_api/fuzz_package_classes.html#class-fuzzer">Fuzzer</a></td><td>Fuzzer 类提供了 fuzz 工具的创建。</td></tr>
<tr><td><a href="fuzz/./fuzz_package_api/fuzz_package_classes.html#class-fuzzerbuilder">FuzzerBuilder</a></td><td>此类用于 Fuzzer 类的构建。</td></tr>
<tr><td><a href="fuzz/./fuzz_package_api/fuzz_package_classes.html#class-fuzzdataprovider">FuzzDataProvider</a></td><td>FuzzDataProvider 是一个工具类，目的是将变异数据的字节流转化为标准的仓颉基本数据。</td></tr>
<tr><td><a href="fuzz/./fuzz_package_api/fuzz_package_classes.html#class-debugdataprovider">DebugDataProvider</a></td><td>此类继承了 FuzzDataProvider 类型，额外增加了调试信息。</td></tr>
</tbody></table>
</div>
<h3 id="异常类-11"><a class="header" href="#异常类-11">异常类</a></h3>
<div class="table-wrapper"><table><thead><tr><th>异常类名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="fuzz/./fuzz_package_api/fuzz_package_exceptions.html#class-exhaustedexception">ExhaustedException</a></td><td>此异常为转换数据时，剩余数据不足以转换时抛出的异常。</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="常量变量"><a class="header" href="#常量变量">常量&amp;变量</a></h1>
<h2 id="let-fuzz_version"><a class="header" href="#let-fuzz_version">let FUZZ_VERSION</a></h2>
<pre><code class="language-cangjie">public let FUZZ_VERSION = &quot;1.0.0&quot;
</code></pre>
<p>功能：Fuzz 版本。</p>
<p>类型：String</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类-16"><a class="header" href="#类-16">类</a></h1>
<h2 id="class-debugdataprovider"><a class="header" href="#class-debugdataprovider">class DebugDataProvider</a></h2>
<pre><code class="language-cangjie">public class DebugDataProvider &lt;: FuzzDataProvider
</code></pre>
<p>功能：此类继承了 <a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzdataprovider">FuzzDataProvider</a> 类型，额外增加了调试信息。</p>
<p>父类型：</p>
<ul>
<li><a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzdataprovider">FuzzDataProvider</a></li>
</ul>
<h3 id="func-consumeall"><a class="header" href="#func-consumeall">func consumeAll()</a></h3>
<pre><code class="language-cangjie">public override func consumeAll(): Array&lt;UInt8&gt;
</code></pre>
<p>功能：将所有数据转换成 UInt8 类型数组。</p>
<p>返回值：</p>
<ul>
<li>Array&lt;UInt8&gt; - UInt8 类型数组。</li>
</ul>
<h3 id="func-consumeallasascii"><a class="header" href="#func-consumeallasascii">func consumeAllAsAscii()</a></h3>
<pre><code class="language-cangjie">public override func consumeAllAsAscii(): String
</code></pre>
<p>功能：将所有数据转换成 Ascii String 类型。</p>
<p>返回值：</p>
<ul>
<li>String - Ascii String 类型实例。</li>
</ul>
<h3 id="func-consumeallasstring"><a class="header" href="#func-consumeallasstring">func consumeAllAsString()</a></h3>
<pre><code class="language-cangjie">public override func consumeAllAsString(): String
</code></pre>
<p>功能：将所有数据转换成 utf8 String 类型。</p>
<p>返回值：</p>
<ul>
<li>String - utf8 String 类型实例。</li>
</ul>
<h3 id="func-consumeasciistringint64"><a class="header" href="#func-consumeasciistringint64">func consumeAsciiString(Int64)</a></h3>
<pre><code class="language-cangjie">public override func consumeAsciiString(maxLength: Int64): String
</code></pre>
<p>功能：将数据转换成 Ascii  String 类型实例。</p>
<p>参数：</p>
<ul>
<li>maxLength: Int64 - String 类型的最大长度。</li>
</ul>
<p>返回值：</p>
<ul>
<li>String - String 类型实例。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 如果 maxLength 为负数，则抛出异常。</li>
</ul>
<h3 id="func-consumebool"><a class="header" href="#func-consumebool">func consumeBool()</a></h3>
<pre><code class="language-cangjie">public override func consumeBool(): Bool
</code></pre>
<p>功能：将数据转换成 Bool 类型实例。</p>
<p>返回值：</p>
<ul>
<li>Bool - Bool 类型实例。</li>
</ul>
<h3 id="func-consumeboolsint64"><a class="header" href="#func-consumeboolsint64">func consumeBools(Int64)</a></h3>
<pre><code class="language-cangjie">public override func consumeBools(count: Int64): Array&lt;Bool&gt;
</code></pre>
<p>功能：将指定数量的数据转换成 Bool 类型数组。</p>
<p>参数：</p>
<ul>
<li>count: Int64 - 指定转换的数据量。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Array&lt;Bool&gt; - Bool 类型数组。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 如果 count 为负数，则抛出异常。</li>
</ul>
<h3 id="func-consumebyte"><a class="header" href="#func-consumebyte">func consumeByte()</a></h3>
<pre><code class="language-cangjie">public override func consumeByte(): Byte
</code></pre>
<p>功能：将数据转换成 Byte 类型实例。</p>
<p>返回值：</p>
<ul>
<li>Byte - Byte 类型实例。</li>
</ul>
<h3 id="func-consumebytesint64"><a class="header" href="#func-consumebytesint64">func consumeBytes(Int64)</a></h3>
<pre><code class="language-cangjie">public override func consumeBytes(count: Int64): Array&lt;Byte&gt;
</code></pre>
<p>功能：将指定数量的数据转换成 Byte 类型数组。</p>
<p>参数：</p>
<ul>
<li>count: Int64 - 指定转换的数据量。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Array&lt;Byte&gt; - Byte 类型数组。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 如果 count 为负数，则抛出异常。</li>
</ul>
<h3 id="func-consumefloat32"><a class="header" href="#func-consumefloat32">func consumeFloat32()</a></h3>
<pre><code class="language-cangjie">public override func consumeFloat32(): Float32
</code></pre>
<p>功能：将数据转换成 Float32 类型实例。</p>
<p>返回值：</p>
<ul>
<li>Float32 - Float32 类型实例。</li>
</ul>
<h3 id="func-consumefloat64"><a class="header" href="#func-consumefloat64">func consumeFloat64()</a></h3>
<pre><code class="language-cangjie">public override func consumeFloat64(): Float64
</code></pre>
<p>功能：将数据转换成 Float64 类型实例。</p>
<p>返回值：</p>
<ul>
<li>Float64 - Float64 类型实例。</li>
</ul>
<h3 id="func-consumeint16"><a class="header" href="#func-consumeint16">func consumeInt16()</a></h3>
<pre><code class="language-cangjie">public override func consumeInt16(): Int16
</code></pre>
<p>功能：将数据转换成 Int16 类型实例。</p>
<p>返回值：</p>
<ul>
<li>Int16 - Int16 类型实例。</li>
</ul>
<h3 id="func-consumeint16sint64"><a class="header" href="#func-consumeint16sint64">func consumeInt16s(Int64)</a></h3>
<pre><code class="language-cangjie">public override func consumeInt16s(count: Int64): Array&lt;Int16&gt;
</code></pre>
<p>功能：将指定数量的数据转换成 Int16 类型数组。</p>
<p>参数：</p>
<ul>
<li>count: Int64 - 指定转换的数据量。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Array&lt;Int16&gt; - Int16 类型数组。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 如果 count 为负数，则抛出异常。</li>
</ul>
<h3 id="func-consumeint32"><a class="header" href="#func-consumeint32">func consumeInt32()</a></h3>
<pre><code class="language-cangjie">public override func consumeInt32(): Int32
</code></pre>
<p>功能：将数据转换成 Int32 类型实例。</p>
<p>返回值：</p>
<ul>
<li>Int32 - Int32 类型实例。</li>
</ul>
<h3 id="func-consumeint32sint64"><a class="header" href="#func-consumeint32sint64">func consumeInt32s(Int64)</a></h3>
<pre><code class="language-cangjie">public override func consumeInt32s(count: Int64): Array&lt;Int32&gt;
</code></pre>
<p>功能：将指定数量的数据转换成 Int32 类型数组。</p>
<p>参数：</p>
<ul>
<li>count: Int64 - 指定转换的数据量。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Array&lt;Int32&gt; - Int32 类型数组。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 如果 count 为负数，则抛出异常。</li>
</ul>
<h3 id="func-consumeint64"><a class="header" href="#func-consumeint64">func consumeInt64()</a></h3>
<pre><code class="language-cangjie">public override func consumeInt64(): Int64
</code></pre>
<p>功能：将数据转换成 Int64 类型实例。</p>
<p>返回值：</p>
<ul>
<li>Int64 - Int64 类型实例。</li>
</ul>
<h3 id="func-consumeint64sint64"><a class="header" href="#func-consumeint64sint64">func consumeInt64s(Int64)</a></h3>
<pre><code class="language-cangjie">public override func consumeInt64s(count: Int64): Array&lt;Int64&gt;
</code></pre>
<p>功能：将指定数量的数据转换成 Int64 类型数组。</p>
<p>参数：</p>
<ul>
<li>count: Int64 - 指定转换的数据量。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Array&lt;Int64&gt; - Int64 类型数组。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 如果 count 为负数，则抛出异常。</li>
</ul>
<h3 id="func-consumeint8"><a class="header" href="#func-consumeint8">func consumeInt8()</a></h3>
<pre><code class="language-cangjie">public override func consumeInt8(): Int8
</code></pre>
<p>功能：将数据转换成 Int8 类型实例。</p>
<p>返回值：</p>
<ul>
<li>Int8 - Int8 类型实例。</li>
</ul>
<h3 id="func-consumeint8sint64"><a class="header" href="#func-consumeint8sint64">func consumeInt8s(Int64)</a></h3>
<pre><code class="language-cangjie">public override func consumeInt8s(count: Int64): Array&lt;Int8&gt;
</code></pre>
<p>功能：将指定数量的数据转换成 Int8 类型数组。</p>
<p>参数：</p>
<ul>
<li>count: Int64 - 指定转换的数据量。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Array&lt;Int8&gt; - Int8 类型数组。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 如果 count 为负数，则抛出异常。</li>
</ul>
<h3 id="func-consumerune"><a class="header" href="#func-consumerune">func consumeRune()</a></h3>
<pre><code class="language-cangjie">public override func consumeRune(): Rune
</code></pre>
<p>功能：将数据转换成 Rune 类型实例。</p>
<p>返回值：</p>
<ul>
<li>Rune - Rune 类型实例。</li>
</ul>
<h3 id="func-consumestringint64"><a class="header" href="#func-consumestringint64">func consumeString(Int64)</a></h3>
<pre><code class="language-cangjie">public override func consumeString(maxLength: Int64): String
</code></pre>
<p>功能：将数据转换成 utf8 String 类型实例。</p>
<p>参数：</p>
<ul>
<li>maxLength: Int64 - String 类型的最大长度。</li>
</ul>
<p>返回值：</p>
<ul>
<li>String - String 类型实例。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 如果 maxLength 为负数，则抛出异常。</li>
</ul>
<h3 id="func-consumeuint16"><a class="header" href="#func-consumeuint16">func consumeUInt16()</a></h3>
<pre><code class="language-cangjie">public override func consumeUInt16(): UInt16
</code></pre>
<p>功能：将数据转换成 UInt16 类型实例。</p>
<p>返回值：</p>
<ul>
<li>UInt16 - UInt16 类型实例。</li>
</ul>
<h3 id="func-consumeuint16sint64"><a class="header" href="#func-consumeuint16sint64">func consumeUInt16s(Int64)</a></h3>
<pre><code class="language-cangjie">public override func consumeUInt16s(count: Int64): Array&lt;UInt16&gt;
</code></pre>
<p>功能：将指定数量的数据转换成 UInt16 类型数组。</p>
<p>参数：</p>
<ul>
<li>count: Int64 - 指定转换的数据量。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Array&lt;UInt16&gt; - UInt16 类型数组。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 如果 count 为负数，则抛出异常。</li>
</ul>
<h3 id="func-consumeuint32"><a class="header" href="#func-consumeuint32">func consumeUInt32()</a></h3>
<pre><code class="language-cangjie">public override func consumeUInt32(): UInt32
</code></pre>
<p>功能：将数据转换成 UInt32 类型实例。</p>
<p>返回值：</p>
<ul>
<li>UInt32 - UInt32 类型实例。</li>
</ul>
<h3 id="func-consumeuint32sint64"><a class="header" href="#func-consumeuint32sint64">func consumeUInt32s(Int64)</a></h3>
<pre><code class="language-cangjie">public override func consumeUInt32s(count: Int64): Array&lt;UInt32&gt;
</code></pre>
<p>功能：将指定数量的数据转换成 UInt32 类型数组。</p>
<p>参数：</p>
<ul>
<li>count: Int64 - 指定转换的数据量。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Array&lt;UInt32&gt; - UInt32 类型数组。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 如果 count 为负数，则抛出异常。</li>
</ul>
<h3 id="func-consumeuint64"><a class="header" href="#func-consumeuint64">func consumeUInt64()</a></h3>
<pre><code class="language-cangjie">public override func consumeUInt64(): UInt64
</code></pre>
<p>功能：将数据转换成 UInt64 类型实例。</p>
<p>返回值：</p>
<ul>
<li>UInt64 - UInt64 类型实例。</li>
</ul>
<h3 id="func-consumeuint64sint64"><a class="header" href="#func-consumeuint64sint64">func consumeUInt64s(Int64)</a></h3>
<pre><code class="language-cangjie">public override func consumeUInt64s(count: Int64): Array&lt;UInt64&gt;
</code></pre>
<p>功能：将指定数量的数据转换成 UInt64 类型数组。</p>
<p>参数：</p>
<ul>
<li>count: Int64 - 指定转换的数据量。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Array&lt;UInt64&gt; - UInt64 类型数组。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 如果 count 为负数，则抛出异常。</li>
</ul>
<h3 id="func-consumeuint8"><a class="header" href="#func-consumeuint8">func consumeUInt8()</a></h3>
<pre><code class="language-cangjie">public override func consumeUInt8(): UInt8
</code></pre>
<p>功能：将数据转换成 UInt8 类型实例。</p>
<p>返回值：</p>
<ul>
<li>UInt8 - UInt8 类型实例。</li>
</ul>
<h3 id="func-consumeuint8sint64"><a class="header" href="#func-consumeuint8sint64">func consumeUInt8s(Int64)</a></h3>
<pre><code class="language-cangjie">public override func consumeUInt8s(count: Int64): Array&lt;UInt8&gt;
</code></pre>
<p>功能：将指定数量的数据转换成 UInt8 类型数组。</p>
<p>参数：</p>
<ul>
<li>count: Int64 - 指定转换的数据量。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Array&lt;UInt8&gt; - UInt8 类型数组。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 如果 count 为负数，则抛出异常。</li>
</ul>
<h3 id="func-wrapfuzzdataprovider"><a class="header" href="#func-wrapfuzzdataprovider">func wrap(FuzzDataProvider)</a></h3>
<pre><code class="language-cangjie">public static func wrap(dp: FuzzDataProvider): DebugDataProvider
</code></pre>
<p>功能：根据 <a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzdataprovider">FuzzDataProvider</a> 实例创建 <a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-debugdataprovider">DebugDataProvider</a> 实例。</p>
<p>参数：</p>
<ul>
<li>dp: <a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzdataprovider">FuzzDataProvider</a> - <a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzdataprovider">FuzzDataProvider</a> 类型实例。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-debugdataprovider">DebugDataProvider</a> - 类型实例。</li>
</ul>
<h2 id="class-fuzzer"><a class="header" href="#class-fuzzer">class Fuzzer</a></h2>
<pre><code class="language-cangjie">public class Fuzzer {
    public init(targetFunction: (Array&lt;UInt8&gt;) -&gt; Int32)
    public init(targetFunction: (Array&lt;UInt8&gt;) -&gt; Int32, args: Array&lt;String&gt;)
    public init(targetFunction: (FuzzDataProvider) -&gt; Int32)
    public init(targetFunction: (FuzzDataProvider) -&gt; Int32, args: Array&lt;String&gt;)
}
</code></pre>
<p>功能：<a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzer">Fuzzer</a> 类提供了 fuzz 工具的创建。用户提供需要进行 fuzz 测试的函数 <code>targetFunction</code>，以及设置特定的 fuzz 运行参数 <code>args</code> 比如 fuzz 执行次数、初始种子、生成数据最大长度等，可创建相应类型的 <a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzer">Fuzzer</a>。</p>
<h3 id="initarrayuint8---int32"><a class="header" href="#initarrayuint8---int32">init((Array&lt;UInt8&gt;) -&gt; Int32)</a></h3>
<pre><code class="language-cangjie">public init(targetFunction: (Array&lt;UInt8&gt;) -&gt; Int32)
</code></pre>
<p>功能：根据以 UInt8 数组为参数，以 Int32 为返回值的目标函数，创建 <a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzer">Fuzzer</a> 实例。</p>
<p>参数：</p>
<ul>
<li>targetFunction: (Array&lt;UInt8&gt;) -&gt;Int32 - 以 UInt8 数组为参数，以 Int32 为返回值的目标函数。</li>
</ul>
<h3 id="initarrayuint8---int32-arraystring"><a class="header" href="#initarrayuint8---int32-arraystring">init((Array&lt;UInt8&gt;) -&gt; Int32, Array&lt;String&gt;)</a></h3>
<pre><code class="language-cangjie">public init(targetFunction: (Array&lt;UInt8&gt;) -&gt; Int32, args: Array&lt;String&gt;)
</code></pre>
<p>功能：根据以 UInt8 数组为参数，以 Int32 为返回值的目标函数，以及 Fuzz 运行参数，创建 <a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzer">Fuzzer</a> 实例。</p>
<p>参数：</p>
<ul>
<li>targetFunction: (Array&lt;UInt8&gt;) -&gt;Int32 - 以 UInt8 数组为参数，以 Int32 为返回值的目标函数。</li>
<li>args: Array&lt;String&gt; - Fuzz 运行参数。</li>
</ul>
<h3 id="initfuzzdataprovider---int32"><a class="header" href="#initfuzzdataprovider---int32">init((FuzzDataProvider) -&gt; Int32)</a></h3>
<pre><code class="language-cangjie">public init(targetFunction: (FuzzDataProvider) -&gt; Int32)
</code></pre>
<p>功能：根据以 <a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzdataprovider">FuzzDataProvider</a> 为参数，以 Int32 为返回值的目标函数，创建 <a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzer">Fuzzer</a> 实例。</p>
<p>参数：</p>
<ul>
<li>targetFunction: (<a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzdataprovider">FuzzDataProvider</a>) -&gt;Int32 - 以 <a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzdataprovider">FuzzDataProvider</a> 为参数，以 Int32 为返回值的目标函数。</li>
</ul>
<h3 id="initfuzzdataprovider---int32-arraystring"><a class="header" href="#initfuzzdataprovider---int32-arraystring">init((FuzzDataProvider) -&gt; Int32, Array&lt;String&gt;)</a></h3>
<pre><code class="language-cangjie">public init(targetFunction: (FuzzDataProvider) -&gt; Int32, args: Array&lt;String&gt;)
</code></pre>
<p>功能：根据以 <a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzdataprovider">FuzzDataProvider</a> 为参数，以 Int32 为返回值的目标函数，以及 Fuzz 运行参数，创建 <a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzer">Fuzzer</a> 实例。</p>
<p>参数：</p>
<ul>
<li>targetFunction: (<a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzdataprovider">FuzzDataProvider</a>) -&gt;Int32 - 以 <a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzdataprovider">FuzzDataProvider</a> 为参数，以 Int32 为返回值的目标函数。</li>
<li>args: Array&lt;String&gt; - Fuzz 运行参数。</li>
</ul>
<h3 id="func-disabledebugdataprovider"><a class="header" href="#func-disabledebugdataprovider">func disableDebugDataProvider()</a></h3>
<pre><code class="language-cangjie">public func disableDebugDataProvider(): Unit
</code></pre>
<p>功能：关闭调试信息打印功能，当 <a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzdataprovider">FuzzDataProvider</a>.consumeXXX 被调用时，返回值将不被打印到 <code>stdout</code>。</p>
<h3 id="func-disablefakecoverage"><a class="header" href="#func-disablefakecoverage">func disableFakeCoverage()</a></h3>
<pre><code class="language-cangjie">public func disableFakeCoverage(): Unit
</code></pre>
<p>功能：关闭调用 <code>enableFakeCoverage</code> 对 Fuzz 的影响。</p>
<h3 id="func-enabledebugdataprovider"><a class="header" href="#func-enabledebugdataprovider">func enableDebugDataProvider()</a></h3>
<pre><code class="language-cangjie">public func enableDebugDataProvider(): Unit
</code></pre>
<p>功能：启用调试信息打印功能，当 <a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzdataprovider">FuzzDataProvider</a>.consumeXXX 被调用时，返回值将被打印到 <code>stdout</code>。该功能默认为关闭。</p>
<h3 id="func-enablefakecoverage"><a class="header" href="#func-enablefakecoverage">func enableFakeCoverage()</a></h3>
<pre><code class="language-cangjie">public func enableFakeCoverage(): Unit
</code></pre>
<p>功能：创建一块虚假的覆盖率反馈区域，保持 Fuzz 持续进行。在 <a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzdataprovider">FuzzDataProvider</a> 模式下，前几轮运行时可能由于数据不足而导致没有覆盖率，libfuzzer 会退出。该功能默认为关闭。</p>
<h3 id="func-getargs"><a class="header" href="#func-getargs">func getArgs()</a></h3>
<pre><code class="language-cangjie">public func getArgs(): Array&lt;String&gt;
</code></pre>
<p>功能：获取 Fuzz 运行参数。</p>
<p>返回值：</p>
<ul>
<li>Array&lt;String&gt; - 当前 Fuzz 运行参数。</li>
</ul>
<h3 id="func-setargsarraystring"><a class="header" href="#func-setargsarraystring">func setArgs(Array&lt;String&gt;)</a></h3>
<pre><code class="language-cangjie">public func setArgs(args: Array&lt;String&gt;): Unit
</code></pre>
<p>功能：设置 Fuzz 运行参数。</p>
<p>参数：</p>
<ul>
<li>args: Array&lt;String&gt; - Fuzz 运行参数。</li>
</ul>
<h3 id="func-settargetfunctionarrayuint8---int32"><a class="header" href="#func-settargetfunctionarrayuint8---int32">func setTargetFunction((Array&lt;UInt8&gt;) -&gt; Int32)</a></h3>
<pre><code class="language-cangjie">public func setTargetFunction(targetFunction: (Array&lt;UInt8&gt;) -&gt; Int32): Unit
</code></pre>
<p>功能：设置 Fuzz 目标函数。</p>
<p>参数：</p>
<ul>
<li>targetFunction: (Array&lt;UInt8&gt;) -&gt;Int32 - 以 UInt8 数组为参数，以 Int32 为返回值的目标函数。</li>
</ul>
<h3 id="func-settargetfunctionfuzzdataprovider---int32"><a class="header" href="#func-settargetfunctionfuzzdataprovider---int32">func setTargetFunction((FuzzDataProvider) -&gt; Int32)</a></h3>
<pre><code class="language-cangjie">public func setTargetFunction(targetFunction: (FuzzDataProvider) -&gt; Int32): Unit
</code></pre>
<p>功能：设置 Fuzz 目标函数。</p>
<p>参数：</p>
<ul>
<li>targetFunction: (<a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzdataprovider">FuzzDataProvider</a>) -&gt;Int32 - 以 <a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzdataprovider">FuzzDataProvider</a> 为参数，以 Int32 为返回值的目标函数。</li>
</ul>
<h3 id="func-startfuzz"><a class="header" href="#func-startfuzz">func startFuzz()</a></h3>
<pre><code class="language-cangjie">public func startFuzz(): Unit
</code></pre>
<p>功能：执行 Fuzz。</p>
<h2 id="class-fuzzerbuilder"><a class="header" href="#class-fuzzerbuilder">class FuzzerBuilder</a></h2>
<pre><code class="language-cangjie">public class FuzzerBuilder {
    public init(targetFunction: (Array&lt;UInt8&gt;) -&gt; Int32)
    public init(targetFunction: (FuzzDataProvider) -&gt; Int32)
}
</code></pre>
<p>功能：此类用于 <a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzer">Fuzzer</a> 类的构建。</p>
<h3 id="initarrayuint8---int32-1"><a class="header" href="#initarrayuint8---int32-1">init((Array&lt;UInt8&gt;) -&gt; Int32)</a></h3>
<pre><code class="language-cangjie">public init(targetFunction: (Array&lt;UInt8&gt;) -&gt; Int32)
</code></pre>
<p>功能：根据以 UInt8 数组为参数，以 Int32 为返回值的目标函数，创建 <a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzerbuilder">FuzzerBuilder</a> 实例。</p>
<p>参数：</p>
<ul>
<li>targetFunction: (Array&lt;UInt8&gt;) -&gt;Int32 - 以 UInt8 数组为参数，以 Int32 为返回值的目标函数。</li>
</ul>
<h3 id="initfuzzdataprovider---int32-1"><a class="header" href="#initfuzzdataprovider---int32-1">init((FuzzDataProvider) -&gt; Int32)</a></h3>
<pre><code class="language-cangjie">public init(targetFunction: (FuzzDataProvider) -&gt; Int32)
</code></pre>
<p>功能：根据以 <a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzdataprovider">FuzzDataProvider</a> 为参数，以 Int32 为返回值的目标函数，创建 <a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzerbuilder">FuzzerBuilder</a> 实例。</p>
<p>参数：</p>
<ul>
<li>targetFunction: (<a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzdataprovider">FuzzDataProvider</a>) -&gt;Int32 - 以 <a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzdataprovider">FuzzDataProvider</a> 为参数，以 Int32 为返回值的目标函数。</li>
</ul>
<h3 id="func-build"><a class="header" href="#func-build">func build()</a></h3>
<pre><code class="language-cangjie">public func build(): Fuzzer
</code></pre>
<p>功能：生成一个 <a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzer">Fuzzer</a> 实例。</p>
<p>返回值：</p>
<ul>
<li><a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzer">Fuzzer</a> - <a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzer">Fuzzer</a> 实例。</li>
</ul>
<h3 id="func-setargsarraystring-1"><a class="header" href="#func-setargsarraystring-1">func setArgs(Array&lt;String&gt;)</a></h3>
<pre><code class="language-cangjie">public func setArgs(args: Array&lt;String&gt;): FuzzerBuilder
</code></pre>
<p>功能：设置 Fuzz 运行参数。</p>
<p>参数：</p>
<ul>
<li>args: Array&lt;String&gt; - Fuzz 运行参数。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzerbuilder">FuzzerBuilder</a> - 当前 <a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzerbuilder">FuzzerBuilder</a> 实例。</li>
</ul>
<h3 id="func-settargetfunctionarrayuint8---int32-1"><a class="header" href="#func-settargetfunctionarrayuint8---int32-1">func setTargetFunction((Array&lt;UInt8&gt;) -&gt; Int32)</a></h3>
<pre><code class="language-cangjie">public func setTargetFunction(targetFunction: (Array&lt;UInt8&gt;) -&gt; Int32): FuzzerBuilder
</code></pre>
<p>功能：设置 Fuzz 目标函数。</p>
<p>参数：</p>
<ul>
<li>targetFunction: (Array&lt;UInt8&gt;) -&gt;Int32 - 以 UInt8 数组为参数，以 Int32 为返回值的目标函数。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzerbuilder">FuzzerBuilder</a> - 当前 <a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzerbuilder">FuzzerBuilder</a> 实例。</li>
</ul>
<h3 id="func-settargetfunctionfuzzdataprovider---int32-1"><a class="header" href="#func-settargetfunctionfuzzdataprovider---int32-1">func setTargetFunction((FuzzDataProvider) -&gt; Int32)</a></h3>
<pre><code class="language-cangjie">public func setTargetFunction(targetFunction: (FuzzDataProvider) -&gt; Int32): FuzzerBuilder
</code></pre>
<p>功能：设置 Fuzz 目标函数。</p>
<p>参数：</p>
<ul>
<li>targetFunction: (<a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzdataprovider">FuzzDataProvider</a>) -&gt;Int32 - 以 <a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzdataprovider">FuzzDataProvider</a> 为参数，以 Int32 为返回值的目标函数。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzerbuilder">FuzzerBuilder</a> - 当前 <a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzerbuilder">FuzzerBuilder</a> 实例。</li>
</ul>
<h2 id="class-fuzzdataprovider"><a class="header" href="#class-fuzzdataprovider">class FuzzDataProvider</a></h2>
<pre><code class="language-cangjie">public open class FuzzDataProvider {
    public let data: Array&lt;UInt8&gt;
    public var remainingBytes: Int64
    public var offset: Int64
}
</code></pre>
<p>功能：<a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzdataprovider">FuzzDataProvider</a> 是一个工具类，目的是将变异数据的字节流转化为标准的仓颉基本数据。</p>
<p>当前支持的数据结构如下：</p>
<div class="table-wrapper"><table><thead><tr><th>目标类型</th><th>API</th><th>说明</th></tr></thead><tbody>
<tr><td>Bool</td><td>consumeBool()</td><td>获取 1 个 Bool，变异数据长度不足时，抛出 <a href="fuzz/fuzz_package_api/fuzz_package_exceptions.html#class-exhaustedexception">ExhaustedException</a>。</td></tr>
<tr><td>Array&lt;Bool&gt;</td><td>consumeBools(count: Int64)</td><td>获取 N 个 Bool，变异数据长度不足时，抛出 <a href="fuzz/fuzz_package_api/fuzz_package_exceptions.html#class-exhaustedexception">ExhaustedException</a>。</td></tr>
<tr><td>Byte</td><td>consumeByte()</td><td>获取 1 个 Byte，变异数据长度不足时，抛出 <a href="fuzz/fuzz_package_api/fuzz_package_exceptions.html#class-exhaustedexception">ExhaustedException</a>。</td></tr>
<tr><td>Array&lt;Byte&gt;</td><td>consumeBytes(count: Int64)</td><td>获取 N 个 Byte，变异数据长度不足时，抛出 <a href="fuzz/fuzz_package_api/fuzz_package_exceptions.html#class-exhaustedexception">ExhaustedException</a>。</td></tr>
<tr><td>UInt8</td><td>consumeUInt8()</td><td>获取 1 个 UInt8，变异数据长度不足时，抛出 <a href="fuzz/fuzz_package_api/fuzz_package_exceptions.html#class-exhaustedexception">ExhaustedException</a>。</td></tr>
<tr><td>UInt16</td><td>consumeUInt16()</td><td>获取 1 个 UInt16，变异数据长度不足时，抛出 <a href="fuzz/fuzz_package_api/fuzz_package_exceptions.html#class-exhaustedexception">ExhaustedException</a>。</td></tr>
<tr><td>UInt32</td><td>consumeUInt32()</td><td>获取 1 个 UInt32，变异数据长度不足时，抛出 <a href="fuzz/fuzz_package_api/fuzz_package_exceptions.html#class-exhaustedexception">ExhaustedException</a>。</td></tr>
<tr><td>UInt64</td><td>consumeUInt64()</td><td>获取 1 个 UInt64，变异数据长度不足时，抛出 <a href="fuzz/fuzz_package_api/fuzz_package_exceptions.html#class-exhaustedexception">ExhaustedException</a>。</td></tr>
<tr><td>Int8</td><td>consumeInt8()</td><td>获取 1 个 Int8，变异数据长度不足时，抛出 <a href="fuzz/fuzz_package_api/fuzz_package_exceptions.html#class-exhaustedexception">ExhaustedException</a>。</td></tr>
<tr><td>Int16</td><td>consumeInt16()</td><td>获取 1 个 Int16，变异数据长度不足时，抛出 <a href="fuzz/fuzz_package_api/fuzz_package_exceptions.html#class-exhaustedexception">ExhaustedException</a>。</td></tr>
<tr><td>Int32</td><td>consumeInt32()</td><td>获取 1 个 Int32，变异数据长度不足时，抛出 <a href="fuzz/fuzz_package_api/fuzz_package_exceptions.html#class-exhaustedexception">ExhaustedException</a>。</td></tr>
<tr><td>Int64</td><td>consumeInt64()</td><td>获取 1 个 Int64，变异数据长度不足时，抛出 <a href="fuzz/fuzz_package_api/fuzz_package_exceptions.html#class-exhaustedexception">ExhaustedException</a>。</td></tr>
<tr><td>Float32</td><td>consumeFloat32()</td><td>获取 1 个 Float32，变异数据长度不足时，抛出 <a href="fuzz/fuzz_package_api/fuzz_package_exceptions.html#class-exhaustedexception">ExhaustedException</a>。</td></tr>
<tr><td>Float64</td><td>consumeFloat64()</td><td>获取 1 个 Float64，变异数据长度不足时，抛出 <a href="fuzz/fuzz_package_api/fuzz_package_exceptions.html#class-exhaustedexception">ExhaustedException</a>。</td></tr>
<tr><td>Array&lt;UInt8&gt;</td><td>consumeUInt8s(count: Int64)</td><td>获取 N 个 UInt8，变异数据长度不足时，抛出 <a href="fuzz/fuzz_package_api/fuzz_package_exceptions.html#class-exhaustedexception">ExhaustedException</a>。</td></tr>
<tr><td>Array&lt;UInt16&gt;</td><td>consumeUInt16s(count: Int64)</td><td>获取 N 个 UInt16，变异数据长度不足时，抛出 <a href="fuzz/fuzz_package_api/fuzz_package_exceptions.html#class-exhaustedexception">ExhaustedException</a>。</td></tr>
<tr><td>Array&lt;UInt32&gt;</td><td>consumeUInt32s(count: Int64)</td><td>获取 N 个 UInt32，变异数据长度不足时，抛出 <a href="fuzz/fuzz_package_api/fuzz_package_exceptions.html#class-exhaustedexception">ExhaustedException</a>。</td></tr>
<tr><td>Array&lt;UInt64&gt;</td><td>consumeUInt64s(count: Int64)</td><td>获取 N 个 UInt64，变异数据长度不足时，抛出 <a href="fuzz/fuzz_package_api/fuzz_package_exceptions.html#class-exhaustedexception">ExhaustedException</a>。</td></tr>
<tr><td>Array&lt;Int8&gt;</td><td>consumeInt8s(count: Int64)</td><td>获取 N 个 Int8，变异数据长度不足时，抛出 <a href="fuzz/fuzz_package_api/fuzz_package_exceptions.html#class-exhaustedexception">ExhaustedException</a>。</td></tr>
<tr><td>Array&lt;Int16&gt;</td><td>consumeInt16s(count: Int64)</td><td>获取 N 个 Int16，变异数据长度不足时，抛出 <a href="fuzz/fuzz_package_api/fuzz_package_exceptions.html#class-exhaustedexception">ExhaustedException</a>。</td></tr>
<tr><td>Array&lt;Int32&gt;</td><td>consumeInt32s(count: Int64)</td><td>获取 N 个 Int32，变异数据长度不足时，抛出 <a href="fuzz/fuzz_package_api/fuzz_package_exceptions.html#class-exhaustedexception">ExhaustedException</a>。</td></tr>
<tr><td>Array&lt;Int64&gt;</td><td>consumeInt64s(count: Int64)</td><td>获取 N 个 Int64，变异数据长度不足时，抛出 <a href="fuzz/fuzz_package_api/fuzz_package_exceptions.html#class-exhaustedexception">ExhaustedException</a>。</td></tr>
<tr><td>Rune</td><td>consumeRune()</td><td>获取 1 个 Rune，变异数据长度不足时，抛出 <a href="fuzz/fuzz_package_api/fuzz_package_exceptions.html#class-exhaustedexception">ExhaustedException</a>。</td></tr>
<tr><td>String</td><td>consumeAsciiString(maxLength: Int64)</td><td>获取 1 个纯 ASCII 的 String，长度为 0 到 maxLength，可以为 0。</td></tr>
<tr><td>String</td><td>consumeString(maxLength: Int64)</td><td>获取 1 个 UTF8 String，长度为 0 到 maxLength，可以为 0。</td></tr>
<tr><td>Array&lt;UInt8&gt;</td><td>consumeAll()</td><td>将 <a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzdataprovider">FuzzDataProvider</a> 中的剩余内容全部转化为字节数组。</td></tr>
<tr><td>String</td><td>consumeAllAsAscii()</td><td>将 <a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzdataprovider">FuzzDataProvider</a> 中的剩余内容全部转化为纯 ASCII 的 String。</td></tr>
<tr><td>String</td><td>consumeAllAsString()</td><td>将 <a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzdataprovider">FuzzDataProvider</a> 中的剩余内容全部转化为 UTF8 String，末尾多余的字符不会被消耗。</td></tr>
</tbody></table>
</div>
<p>在数据长度不足时，调用上述大部分虽然会抛出 <a href="fuzz/fuzz_package_api/fuzz_package_exceptions.html#class-exhaustedexception">ExhaustedException</a>，但编写 fuzz 函数时通常并不需要对它进行处理，<a href="fuzz/fuzz_package_api/fuzz_package_exceptions.html#class-exhaustedexception">ExhaustedException</a> 默认会被 fuzz 框架捕获，告诉 libfuzzer 该次运行无效，请继续下一轮变异。随着执行时间的变长，变异数据也会逐渐变长，直到满足 <a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzdataprovider">FuzzDataProvider</a> 的需求。</p>
<p>如果达到了 <code>max_len</code> 仍无法满足 <a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzdataprovider">FuzzDataProvider</a> 的需求，则进程退出，请修改 fuzz 测试用例（推荐） 或 增大 <code>max_len</code>（不推荐）。</p>
<h3 id="let-data"><a class="header" href="#let-data">let data</a></h3>
<pre><code class="language-cangjie">public let data: Array&lt;UInt8&gt;
</code></pre>
<p>功能：变异数据。</p>
<p>类型：Array&lt;UInt8&gt;</p>
<h3 id="var-offset"><a class="header" href="#var-offset">var offset</a></h3>
<pre><code class="language-cangjie">public var offset: Int64
</code></pre>
<p>功能：已转化的字节数。</p>
<p>类型：Int64</p>
<h3 id="var-remainingbytes"><a class="header" href="#var-remainingbytes">var remainingBytes</a></h3>
<pre><code class="language-cangjie">public var remainingBytes: Int64
</code></pre>
<p>功能：剩余字节数。</p>
<p>类型：Int64</p>
<h3 id="func-consumeall-1"><a class="header" href="#func-consumeall-1">func consumeAll()</a></h3>
<pre><code class="language-cangjie">public open func consumeAll(): Array&lt;UInt8&gt;
</code></pre>
<p>功能：将所有数据转换成 UInt8 类型数组。</p>
<p>返回值：</p>
<ul>
<li>Array&lt;UInt8&gt; - UInt8 类型数组。</li>
</ul>
<h3 id="func-consumeallasascii-1"><a class="header" href="#func-consumeallasascii-1">func consumeAllAsAscii()</a></h3>
<pre><code class="language-cangjie">public open func consumeAllAsAscii(): String
</code></pre>
<p>功能：将所有数据转换成 Ascii String 类型。</p>
<p>返回值：</p>
<ul>
<li>String - Ascii String 类型实例。</li>
</ul>
<h3 id="func-consumeallasstring-1"><a class="header" href="#func-consumeallasstring-1">func consumeAllAsString()</a></h3>
<pre><code class="language-cangjie">public open func consumeAllAsString(): String
</code></pre>
<p>功能：将所有数据转换成 utf8 String 类型。</p>
<p>返回值：</p>
<ul>
<li>String - utf8 String 类型实例。</li>
</ul>
<h3 id="func-consumeasciistringint64-1"><a class="header" href="#func-consumeasciistringint64-1">func consumeAsciiString(Int64)</a></h3>
<pre><code class="language-cangjie">public open func consumeAsciiString(maxLength: Int64): String
</code></pre>
<p>功能：将数据转换成 Ascii  String 类型实例。</p>
<p>参数：</p>
<ul>
<li>maxLength: Int64 - String 类型的最大长度。</li>
</ul>
<p>返回值：</p>
<ul>
<li>String - String 类型实例。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 如果 maxLength 为负数，则抛出异常。</li>
</ul>
<h3 id="func-consumebool-1"><a class="header" href="#func-consumebool-1">func consumeBool()</a></h3>
<pre><code class="language-cangjie">public open func consumeBool(): Bool
</code></pre>
<p>功能：将数据转换成 Bool 类型实例。</p>
<p>返回值：</p>
<ul>
<li>Bool - Bool 类型实例。</li>
</ul>
<h3 id="func-consumeboolsint64-1"><a class="header" href="#func-consumeboolsint64-1">func consumeBools(Int64)</a></h3>
<pre><code class="language-cangjie">public open func consumeBools(count: Int64): Array&lt;Bool&gt;
</code></pre>
<p>功能：将指定数量的数据转换成 Bool 类型数组。</p>
<p>参数：</p>
<ul>
<li>count: Int64 - 指定转换的数据量。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Array&lt;Bool&gt; - Bool 类型数组。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 如果 count 为负数，则抛出异常。</li>
</ul>
<h3 id="func-consumebyte-1"><a class="header" href="#func-consumebyte-1">func consumeByte()</a></h3>
<pre><code class="language-cangjie">public open func consumeByte(): Byte
</code></pre>
<p>功能：将数据转换成 Byte 类型实例。</p>
<p>返回值：</p>
<ul>
<li>Byte - Byte 类型实例。</li>
</ul>
<h3 id="func-consumebytesint64-1"><a class="header" href="#func-consumebytesint64-1">func consumeBytes(Int64)</a></h3>
<pre><code class="language-cangjie">public open func consumeBytes(count: Int64): Array&lt;Byte&gt;
</code></pre>
<p>功能：将指定数量的数据转换成 Byte 类型数组。</p>
<p>参数：</p>
<ul>
<li>count: Int64 - 指定转换的数据量。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Array&lt;Byte&gt; - Byte 类型数组。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 如果 count 为负数，则抛出异常。</li>
</ul>
<h3 id="func-consumefloat32-1"><a class="header" href="#func-consumefloat32-1">func consumeFloat32()</a></h3>
<pre><code class="language-cangjie">public open func consumeFloat32(): Float32
</code></pre>
<p>功能：将数据转换成 Float32 类型实例。</p>
<p>返回值：</p>
<ul>
<li>Float32 - Float32 类型实例。</li>
</ul>
<h3 id="func-consumefloat64-1"><a class="header" href="#func-consumefloat64-1">func consumeFloat64()</a></h3>
<pre><code class="language-cangjie">public open func consumeFloat64(): Float64
</code></pre>
<p>功能：将数据转换成 Float64 类型实例。</p>
<p>返回值：</p>
<ul>
<li>Float64 - Float64 类型实例。</li>
</ul>
<h3 id="func-consumeint16-1"><a class="header" href="#func-consumeint16-1">func consumeInt16()</a></h3>
<pre><code class="language-cangjie">public open func consumeInt16(): Int16
</code></pre>
<p>功能：将数据转换成 Int16 类型实例。</p>
<p>返回值：</p>
<ul>
<li>Int16 - Int16 类型实例。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 如果 count 为负数，则抛出异常。</li>
</ul>
<h3 id="func-consumeint16sint64-1"><a class="header" href="#func-consumeint16sint64-1">func consumeInt16s(Int64)</a></h3>
<pre><code class="language-cangjie">public open func consumeInt16s(count: Int64): Array&lt;Int16&gt;
</code></pre>
<p>功能：将指定数量的数据转换成 Int16 类型数组。</p>
<p>参数：</p>
<ul>
<li>count: Int64 - 指定转换的数据量。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Array&lt;Int16&gt; - Int16 类型数组。</li>
</ul>
<h3 id="func-consumeint32-1"><a class="header" href="#func-consumeint32-1">func consumeInt32()</a></h3>
<pre><code class="language-cangjie">public open func consumeInt32(): Int32
</code></pre>
<p>功能：将数据转换成 Int32 类型实例。</p>
<p>返回值：</p>
<ul>
<li>Int32 - Int32 类型实例。</li>
</ul>
<h3 id="func-consumeint32sint64-1"><a class="header" href="#func-consumeint32sint64-1">func consumeInt32s(Int64)</a></h3>
<pre><code class="language-cangjie">public open func consumeInt32s(count: Int64): Array&lt;Int32&gt;
</code></pre>
<p>功能：将指定数量的数据转换成 Int32 类型数组。</p>
<p>参数：</p>
<ul>
<li>count: Int64 - 指定转换的数据量。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Array&lt;Int32&gt; - Int32 类型数组。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 如果 count 为负数，则抛出异常。</li>
</ul>
<h3 id="func-consumeint64-1"><a class="header" href="#func-consumeint64-1">func consumeInt64()</a></h3>
<pre><code class="language-cangjie">public open func consumeInt64(): Int64
</code></pre>
<p>功能：将数据转换成 Int64 类型实例。</p>
<p>返回值：</p>
<ul>
<li>Int64 - Int64 类型实例。</li>
</ul>
<h3 id="func-consumeint64sint64-1"><a class="header" href="#func-consumeint64sint64-1">func consumeInt64s(Int64)</a></h3>
<pre><code class="language-cangjie">public open func consumeInt64s(count: Int64): Array&lt;Int64&gt;
</code></pre>
<p>功能：将指定数量的数据转换成 Int64 类型数组。</p>
<p>参数：</p>
<ul>
<li>count: Int64 - 指定转换的数据量。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Array&lt;Int64&gt; - Int64 类型数组。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 如果 count 为负数，则抛出异常。</li>
</ul>
<h3 id="func-consumeint8-1"><a class="header" href="#func-consumeint8-1">func consumeInt8()</a></h3>
<pre><code class="language-cangjie">public open func consumeInt8(): Int8
</code></pre>
<p>功能：将数据转换成 Int8 类型实例。</p>
<p>返回值：</p>
<ul>
<li>Int8 - Int8 类型实例。</li>
</ul>
<h3 id="func-consumeint8sint64-1"><a class="header" href="#func-consumeint8sint64-1">func consumeInt8s(Int64)</a></h3>
<pre><code class="language-cangjie">public open func consumeInt8s(count: Int64): Array&lt;Int8&gt;
</code></pre>
<p>功能：将指定数量的数据转换成 Int8 类型数组。</p>
<p>参数：</p>
<ul>
<li>count: Int64 - 指定转换的数据量。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Array&lt;Int8&gt; - Int8 类型数组。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 如果 count 为负数，则抛出异常。</li>
</ul>
<h3 id="func-consumerune-1"><a class="header" href="#func-consumerune-1">func consumeRune()</a></h3>
<pre><code class="language-cangjie">public open func consumeRune(): Rune
</code></pre>
<p>功能：将数据转换成 Rune 类型实例。</p>
<p>返回值：</p>
<ul>
<li>Rune - Rune 类型实例。</li>
</ul>
<h3 id="func-consumestringint64-1"><a class="header" href="#func-consumestringint64-1">func consumeString(Int64)</a></h3>
<pre><code class="language-cangjie">public open func consumeString(maxLength: Int64): String
</code></pre>
<p>功能：将数据转换成 utf8 String 类型实例。</p>
<p>参数：</p>
<ul>
<li>maxLength: Int64 - String 类型的最大长度。</li>
</ul>
<p>返回值：</p>
<ul>
<li>String - String 类型实例。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 如果 maxLength 为负数，则抛出异常。</li>
</ul>
<h3 id="func-consumeuint16-1"><a class="header" href="#func-consumeuint16-1">func consumeUInt16()</a></h3>
<pre><code class="language-cangjie">public open func consumeUInt16(): UInt16
</code></pre>
<p>功能：将数据转换成 UInt16 类型实例。</p>
<p>返回值：</p>
<ul>
<li>UInt16 - UInt16 类型实例。</li>
</ul>
<h3 id="func-consumeuint16sint64-1"><a class="header" href="#func-consumeuint16sint64-1">func consumeUInt16s(Int64)</a></h3>
<pre><code class="language-cangjie">public open func consumeUInt16s(count: Int64): Array&lt;UInt16&gt;
</code></pre>
<p>功能：将指定数量的数据转换成 UInt16 类型数组。</p>
<p>参数：</p>
<ul>
<li>count: Int64 - 指定转换的数据量。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Array&lt;UInt16&gt; - UInt16 类型数组。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 如果 count 为负数，则抛出异常。</li>
</ul>
<h3 id="func-consumeuint32-1"><a class="header" href="#func-consumeuint32-1">func consumeUInt32()</a></h3>
<pre><code class="language-cangjie">public open func consumeUInt32(): UInt32
</code></pre>
<p>功能：将数据转换成 UInt32 类型实例。</p>
<p>返回值：</p>
<ul>
<li>UInt32 - UInt32 类型实例。</li>
</ul>
<h3 id="func-consumeuint32sint64-1"><a class="header" href="#func-consumeuint32sint64-1">func consumeUInt32s(Int64)</a></h3>
<pre><code class="language-cangjie">public open func consumeUInt32s(count: Int64): Array&lt;UInt32&gt;
</code></pre>
<p>功能：将指定数量的数据转换成 UInt32 类型数组。</p>
<p>参数：</p>
<ul>
<li>count: Int64 - 指定转换的数据量。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Array&lt;UInt32&gt; - UInt32 类型数组。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 如果 count 为负数，则抛出异常。</li>
</ul>
<h3 id="func-consumeuint64-1"><a class="header" href="#func-consumeuint64-1">func consumeUInt64()</a></h3>
<pre><code class="language-cangjie">public open func consumeUInt64(): UInt64
</code></pre>
<p>功能：将数据转换成 UInt64 类型实例。</p>
<p>返回值：</p>
<ul>
<li>UInt64 - UInt64 类型实例。</li>
</ul>
<h3 id="func-consumeuint64sint64-1"><a class="header" href="#func-consumeuint64sint64-1">func consumeUInt64s(Int64)</a></h3>
<pre><code class="language-cangjie">public open func consumeUInt64s(count: Int64): Array&lt;UInt64&gt;
</code></pre>
<p>功能：将指定数量的数据转换成 UInt64 类型数组。</p>
<p>参数：</p>
<ul>
<li>count: Int64 - 指定转换的数据量。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Array&lt;UInt64&gt; - UInt64 类型数组。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 如果 count 为负数，则抛出异常。</li>
</ul>
<h3 id="func-consumeuint8-1"><a class="header" href="#func-consumeuint8-1">func consumeUInt8()</a></h3>
<pre><code class="language-cangjie">public open func consumeUInt8(): UInt8
</code></pre>
<p>功能：将数据转换成 UInt8 类型实例。</p>
<p>返回值：</p>
<ul>
<li>UInt8 - UInt8 类型实例。</li>
</ul>
<h3 id="func-consumeuint8sint64-1"><a class="header" href="#func-consumeuint8sint64-1">func consumeUInt8s(Int64)</a></h3>
<pre><code class="language-cangjie">public open func consumeUInt8s(count: Int64): Array&lt;UInt8&gt;
</code></pre>
<p>功能：将指定数量的数据转换成 UInt8 类型数组。</p>
<p>参数：</p>
<ul>
<li>count: Int64 - 指定转换的数据量。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Array&lt;UInt8&gt; - UInt8 类型数组。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 如果 count 为负数，则抛出异常。</li>
</ul>
<h3 id="static-func-withcangjiedataarrayuint8"><a class="header" href="#static-func-withcangjiedataarrayuint8">static func withCangjieData(Array&lt;UInt8&gt;)</a></h3>
<pre><code class="language-cangjie">public static func withCangjieData(data: Array&lt;UInt8&gt;): FuzzDataProvider
</code></pre>
<p>功能：使用 Array&lt;UInt8&gt; 类型的数据生成 <a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzdataprovider">FuzzDataProvider</a> 类型实例。</p>
<p>参数：</p>
<ul>
<li>data: Array&lt;UInt8&gt; - 输入的外部数据。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzdataprovider">FuzzDataProvider</a> - 构造的 <a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzdataprovider">FuzzDataProvider</a> 类型实例。</li>
</ul>
<h3 id="static-func-withnativedatacpointeruint8-int64"><a class="header" href="#static-func-withnativedatacpointeruint8-int64">static func withNativeData(CPointer&lt;UInt8&gt;, Int64)</a></h3>
<pre><code class="language-cangjie">public static unsafe func withNativeData(data: CPointer&lt;UInt8&gt;, length: Int64): FuzzDataProvider
</code></pre>
<p>功能：使用 C 指针数据生成 <a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzdataprovider">FuzzDataProvider</a> 类型实例。</p>
<p>参数：</p>
<ul>
<li>data: CPointer&lt;UInt8&gt; - 输入的外部数据。</li>
<li>length: Int64 - 数据长度。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzdataprovider">FuzzDataProvider</a> - 构造的 <a href="fuzz/fuzz_package_api/fuzz_package_classes.html#class-fuzzdataprovider">FuzzDataProvider</a> 类型实例。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="异常类-12"><a class="header" href="#异常类-12">异常类</a></h1>
<h2 id="class-exhaustedexception"><a class="header" href="#class-exhaustedexception">class ExhaustedException</a></h2>
<pre><code class="language-cangjie">public class ExhaustedException &lt;: Exception {
    public init()
    public init(message: String)
}
</code></pre>
<p>功能：此异常为转换数据时，剩余数据不足以转换时抛出的异常。</p>
<p>父类型：</p>
<ul>
<li>Exception</li>
</ul>
<h3 id="init-16"><a class="header" href="#init-16">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：创建 <a href="fuzz/fuzz_package_api/fuzz_package_exceptions.html#class-exhaustedexception">ExhaustedException</a> 实例。</p>
<h3 id="initstring-9"><a class="header" href="#initstring-9">init(String)</a></h3>
<pre><code class="language-cangjie">public init(message: String)
</code></pre>
<p>功能：创建 <a href="fuzz/fuzz_package_api/fuzz_package_exceptions.html#class-exhaustedexception">ExhaustedException</a> 实例。</p>
<p>参数：</p>
<ul>
<li>message: String - 异常提示信息。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="测试猜测字符功能"><a class="header" href="#测试猜测字符功能">测试猜测字符功能</a></h1>
<ul>
<li>编写被测 API，当且仅当输入数组长度是 8、内容是 &quot;Cangjie!&quot; 对应的 ASCII 时抛出异常，纯随机的情况下最差需要 2<sup>64</sup> 次猜测才会触发异常。</li>
<li>创建 Fuzzer 并且调用待测 API，进入主流程。</li>
</ul>
<pre><code class="language-cangjie">// 导入依赖的类
import stdx.fuzz.fuzz.Fuzzer

main() {
    // 创建Fuzzer并启动fuzz流程
    Fuzzer(api).startFuzz()
    return 0
}


// 被测函数，在满足特定条件会抛出异常，该异常会被 Fuzzer 捕获
public func api(data: Array&lt;UInt8&gt;): Int32 {
    if (data.size == 8 &amp;&amp; data[0] == b'C' &amp;&amp; data[1] == b'a' &amp;&amp; data[2] == b'n' &amp;&amp; data[3] == b'g' &amp;&amp; data[4] == b'j' &amp;&amp;
        data[5] == b'i' &amp;&amp; data[6] == b'e' &amp;&amp; data[7] == b'!') {
        throw Exception(&quot;TRAP&quot;)
    }
    return 0
}
</code></pre>
<blockquote>
<p>下方的命令中的 CANGJIE_STDX_PATH 指向存放 stdx 系列的路径，例如 &quot;./static/stdx&quot;</p>
</blockquote>
<p>Linux 的编译命令是：<code>cjc fuzz_main.cj -L $CANGJIE_STDX_PATH -lstdx.fuzz.fuzz --import-path $CANGJIE_STDX_PATH --link-options=&quot;--whole-archive $CANGJIE_HOME/lib/linux_x86_64_llvm/libclang_rt.fuzzer_no_main.a -no-whole-archive -lstdc++&quot; --sanitizer-coverage-inline-8bit-counters</code></p>
<p>macOS 的编译命令是：<code>cjc fuzz_main.cj -L $CANGJIE_STDX_PATH -lstdx.fuzz.fuzz --import-path $CANGJIE_STDX_PATH --link-options=&quot;$CANGJIE_HOME/lib/linux_x86_64_llvm/libclang_rt.fuzzer_no_main.a -lc++&quot; --sanitizer-coverage-inline-8bit-counters</code></p>
<p>释义：</p>
<ul>
<li>link-options 是链接时选项，fuzz 库本身依赖符号 <code>LLVMFuzzerRunDriver</code>，该符号需要开发者自行解决。
<ul>
<li>仓颉语言在 $CANGJIE_HOME/lib/linux_x86_64_llvm/libclang_rt.fuzzer_no_main.a 存放一份 <strong>修改过</strong> 的 libfuzzer，对标准的 libfuzzer 进行了增强，见 <a href="fuzz/fuzz_samples/./print_coverage.html">实验性特性-覆盖率信息打印</a>。</li>
<li>可以使用 <code>find $(clang -print-runtime-dir) -name &quot;libclang_rt.fuzzer_no_main*.a&quot;</code> 寻找本地安装好的静态库文件。</li>
</ul>
</li>
<li>向 Linux 编译需要使用 <code>whole-archive libfuzzer.a</code> 是因为 cjc 调用 ld 后端时，从左到右顺序是 <code>libfuzzer.a</code> 、 <code>libcangjie-fuzz-fuzz.a</code>、 libc 等基础库，该顺序会导致 <code>libcangjie-fuzz-fuzz.a</code> 依赖的 <code>LLVMFuzzerRunDriver</code> 符号未被找到。解决方案有：
<ul>
<li>将 <code>libfuzzer.a</code> 放到 <code>libcangjie-fuzz-fuzz.a</code> 后面；</li>
<li>使用 <code>whole-archive libfuzzer.a</code> 来规避符号找不到的问题。</li>
</ul>
</li>
<li><code>-lstdc++</code> (Linux) / <code>-lc++</code> (macOS) 用于链接 libfuzzer 依赖的 std 库。</li>
<li><code>--sanitizer-coverage-inline-8bit-counters</code> 是 <code>cjc</code> 的编译选项，它会对当前 <code>package</code> 执行覆盖率反馈插桩，详见 cjc 编译器使用手册。
<ul>
<li>其他高级的参数有：<code>--sanitizer-coverage-trace-compares</code>（提高Fuzz变异的效率）、<code>--sanitizer-coverage-pc-table</code>（Fuzz结束后打印覆盖率信息）。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>注意：</strong></p>
<p>如果您使用的Linux系统版本较低，可能出现GLIBC版本过低的链接器报错，请在 <code>link-options</code> 参数中添加 <code>-lpthread</code> 来解决此问题。</p>
</blockquote>
<p>与 <code>libfuzzer</code> 体验类似，可以直接运行，数秒后（取决于 CPU 性能）可获得 crash，且输入的数据是 &quot;Cangjie!&quot;</p>
<p>运行结果如下：</p>
<pre><code class="language-text">$ ./main
INFO: Seed: 246468919
INFO: Loaded 1 modules   (15 inline 8-bit counters): 15 [0x55bb7c76dcb0, 0x55bb7c76dcbf),
INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytes
INFO: A corpus is not provided, starting from an empty corpus
#2      INITED ft: 4 corp: 1/1b exec/s: 0 rss: 28Mb
#420    NEW    ft: 5 corp: 2/9b lim: 8 exec/s: 0 rss: 28Mb L: 8/8 MS: 3 CrossOver-InsertByte-InsertRepeatedBytes-
#1323   NEW    ft: 6 corp: 3/17b lim: 14 exec/s: 0 rss: 28Mb L: 8/8 MS: 3 InsertByte-InsertByte-CrossOver-
#131072 pulse  ft: 6 corp: 3/17b lim: 1300 exec/s: 65536 rss: 35Mb
#262144 pulse  ft: 6 corp: 3/17b lim: 2600 exec/s: 65536 rss: 41Mb
#295225 NEW    ft: 7 corp: 4/25b lim: 2930 exec/s: 73806 rss: 43Mb L: 8/8 MS: 2 ShuffleBytes-ChangeByte-
#514006 NEW    ft: 8 corp: 5/33b lim: 4096 exec/s: 73429 rss: 53Mb L: 8/8 MS: 1 ChangeByte-
#524288 pulse  ft: 8 corp: 5/33b lim: 4096 exec/s: 74898 rss: 53Mb
#1048576        pulse  ft: 8 corp: 5/33b lim: 4096 exec/s: 61680 rss: 78Mb
#1064377        NEW    ft: 9 corp: 6/41b lim: 4096 exec/s: 62610 rss: 79Mb L: 8/8 MS: 1 ChangeByte-
#1287268        NEW    ft: 10 corp: 7/49b lim: 4096 exec/s: 61298 rss: 90Mb L: 8/8 MS: 1 ChangeByte-
#2097152        pulse  ft: 10 corp: 7/49b lim: 4096 exec/s: 59918 rss: 128Mb
#2875430        NEW    ft: 11 corp: 8/57b lim: 4096 exec/s: 61179 rss: 165Mb L: 8/8 MS: 2 ChangeBinInt-ChangeByte-
#4194304        pulse  ft: 11 corp: 8/57b lim: 4096 exec/s: 59918 rss: 227Mb
#4208258        NEW    ft: 12 corp: 9/65b lim: 4096 exec/s: 60117 rss: 228Mb L: 8/8 MS: 3 CrossOver-CrossOver-ChangeBit-
[WARNING]: Detect uncatched exception, maybe caused by bugs, exit now
An exception has occurred:
Exception: TRAP
         at default.api(std/core::Array&lt;...&gt;)(/data/Cangjie/fuzz_main.cj:14)
         at _ZN7default3apiER_ZN8std$core5ArrayIhE_cc_wrapper(/data/Cangjie/fuzz_main.cj:0)
         at libfuzzerCallback(fuzz/fuzz/callback.cj:20)
[INFO]: data is: [67, 97, 110, 103, 106, 105, 101, 33]
[INFO]: data base64: Q2FuZ2ppZSE=
crash file will stored with libfuzzer
==899957== ERROR: libFuzzer: fuzz target exited
SUMMARY: libFuzzer: fuzz target exited
MS: 1 ChangeByte-; base unit: 7d8b0108ce76a937161065eafcde95bbf3d47dbf
0x43,0x61,0x6e,0x67,0x6a,0x69,0x65,0x21,
Cangjie!
artifact_prefix='./'; Test unit written to ./crash-555e7af32a2ceb585cdd9ce810c4804e65d41cea
Base64: Q2FuZ2ppZSE=
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用-dataprovider-功能进行测试"><a class="header" href="#使用-dataprovider-功能进行测试">使用 DataProvider 功能进行测试</a></h1>
<p>除了使用字节流对 API 进行测试的方法之外，fuzz 包提供了 FuzzDataProvider 类，用于更友好地从变异的数据源产生仓颉的标准数据类型，方便对 API 进行测试。</p>
<pre><code class="language-cangjie">public func api2(dp: FuzzDataProvider): Int32 {
    if(dp.consumeBool() &amp;&amp; dp.consumeByte() == b'A' &amp;&amp; dp.consumeuint32() == 0xdeadbeef){
        throw Exception(&quot;TRAP&quot;)
    }
    return 0
}
</code></pre>
<p>此案例中，开启 <code>--sanitizer-coverage-trace-compares</code> 可有效提高 fuzz 效率。</p>
<p>DataProvider 模式下，无法直观地判断各个 API 返回值分别是什么，因此提供了 Fuzzer.enableDebugDataProvider() 和 <code>DebugDataProvider</code>，在 <code>startFuzz</code> 前调用 <code>enableDebugDataProvider()</code> 即可令本次 fuzz 每次调用 <code>consumeXXX</code> 时打印日志。</p>
<p>例如，上文代码触发异常后，添加 <code>enableDebugDataProvider</code> 重新编译，效果如下。</p>
<pre><code class="language-cangjie">import stdx.fuzz.fuzz.*

main() {
    let fuzzer = Fuzzer(api2)
    fuzzer.enableDebugDataProvider()
    fuzzer.startFuzz()
    return 0
}
</code></pre>
<p>运行结果如下：</p>
<pre><code class="language-text">./main crash-d7ece8e77ff25769a5d55eb8d3093d4bace78e1b
Running: crash-d7ece8e77ff25769a5d55eb8d3093d4bace78e1b
[DEBUG] consumeBool return true
[DEBUG] consumeByte return 65
[DEBUG] consumeUInt32 return 3735928559
[WARNING]: Detect uncatched exception, maybe caused by bugs, exit now
An exception has occurred:
Exception: TRAP
         at default.api2(fuzz/fuzz::FuzzDataProvider)(/tmp/test.cj:12)
         at _ZN7default4api2EC_ZN9fuzz$fuzz16FuzzDataProviderE_cc_wrapper(/tmp/test.cj:0)
         at libfuzzerCallback(fuzz/fuzz/callback.cj:0)
[INFO]: data is: [191, 65, 239, 190, 173, 222]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用-fakecoverage-避免-dataprovider-模式下-fuzz-异常终止"><a class="header" href="#使用-fakecoverage-避免-dataprovider-模式下-fuzz-异常终止">使用 FakeCoverage 避免 DataProvider 模式下 Fuzz 异常终止</a></h1>
<p>在链接了 libfuzzer &lt;= 14 的情况下，且处于 DataProvider 模式下，遇到了类似如下的错误，可能需要阅读此章节：</p>
<pre><code class="language-text">ERROR: no interesting inputs were found. Is the code instrumented for coverage? Exiting.
</code></pre>
<p><a href="https://github.com/llvm/llvm-project/commit/92fb310151d2b1e349695fc0f1c5d5d50afb3b52">libfuzzer 15</a> 起，修复了该 feature，即使初始化时拒绝了输入，也不会停止执行。</p>
<p><strong>注意：请确认被测试的库确实被插入了覆盖率反馈，因为在没有覆盖率反馈插桩的情况下，也会出现该错误！</strong></p>
<p>当前 fuzz 后端对接到了 libfuzzer，而 libfuzzer 在启动时会先输入空字节流、再输入仅包含一个 <code>'\n'</code> 的字节流对待测函数进行试探，在两轮结束后检测覆盖率是否新增。在 DataProvider 模式下，如果先消耗数据，再调用待测库的 API，会导致消耗数据时长度不足而提前返回，从而 libfuzzer 认为覆盖率信息为零。</p>
<p>例如下方代码，会触发该错误</p>
<p>触发的代码：</p>
<pre><code class="language-cangjie">// main.cj
import stdx.fuzz.fuzz.*

main() {
    let f = Fuzzer(api)
    f.disableFakeCoverage()
    f.startFuzz()
    return 0
}

// fuzz_target.cj, with sancov
public func api(dp: FuzzDataProvider): Int32 {
    if (dp.consumeBool() &amp;&amp; dp.consumeBool()) {
        throw Exception(&quot;TRAP!&quot;)
    }
    return 0
}
</code></pre>
<p>运行结果如下：</p>
<pre><code class="language-text">...
ERROR: no interesting inputs were found. Is the code instrumented for coverage? Exiting.
...
</code></pre>
<p>因此，需要使用 Fake Coverage 创建虚假的覆盖率信息，让 libfuzzer 在初始化期间认为待测模块确实被插桩，等到 DataProvider 收集到足够数据后，再进行有效的 fuzz 测试。该模式被称为 Fake Coverage 模式。</p>
<p>将上文的 <code>disableFakeCoverage()</code> 替换为 <code>enableFakeCoverage()</code> 即可继续运行，最终触发 TRAP。</p>
<p>此外，除了使用 Fake Coverage 模式，还可以在测试用例中主动调用待测函数的某些不重要的API来将覆盖率信息传递给 libfuzzer，也能起到让 fuzz 继续下去的作用。</p>
<pre><code class="language-cangjie">// main.cj
import stdx.fuzz.fuzz.*

main() {
    let f = Fuzzer(api)
    f.enableFakeCoverage()
    f.startFuzz()
    return 0
}

// fuzz_target.cj, with sancov
public func api(dp: FuzzDataProvider): Int32 {
    if (dp.consumeBool() &amp;&amp; dp.consumeBool()) {
        throw Exception(&quot;TRAP!&quot;)
    }
    return 0
}
</code></pre>
<p>运行结果如下：</p>
<pre><code class="language-text">INFO: Running with entropic power schedule (0xFF, 100).
INFO: Seed: 3187548846
INFO: Loaded 2 modules   (8 inline 8-bit counters): 7 [0x55bf83ea8790, 0x55bf83ea8797), 1 [0x55bf83e97b00, 0x55bf83e97b01),
INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytes
INFO: A corpus is not provided, starting from an empty corpus
#2      INITED ft: 5 corp: 1/1b exec/s: 0 rss: 33Mb
#9      NEW    ft: 6 corp: 2/2b lim: 4 exec/s: 0 rss: 33Mb L: 1/1 MS: 2 CopyPart-ChangeByte-
[WARNING]: Detect uncatched exception, maybe caused by bugs, exit now
An exception has occurred:
Exception: TRAP!
...
...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="打印-fuzz-使用方法"><a class="header" href="#打印-fuzz-使用方法">打印 fuzz 使用方法</a></h1>
<p>可以使用 <code>-help=1</code> 打印帮助，<code>-seed=246468919</code> 指定随机数的种子。</p>
<p>运行结果如下：</p>
<pre><code class="language-text">$ ./main -help=1                                                                                                                                                                                        exit 130
Usage:
To run fuzzing pass 0 or more directories.
program_name [-flag1=val1 [-flag2=val2 ...] ] [dir1 [dir2 ...] ]
To run individual tests without fuzzing pass 1 or more files:
program_name [-flag1=val1 [-flag2=val2 ...] ] file1 [file2 ...]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实验性特性-覆盖率信息打印"><a class="header" href="#实验性特性-覆盖率信息打印">实验性特性-覆盖率信息打印</a></h1>
<p>仓颉 fuzzer 支持使用 <code>-print_coverage=1</code> 作为启动参数运行 fuzzer，用于统计各函数的测试情况，该特性在持续完善中，只与输出覆盖率报告有关，不影响 fuzz 过程。</p>
<p>由于该功能需要对 libfuzzer 进行侵入式修改，使用该功能需要链接仓颉自带的 libfuzzer，路径是：$CANGJIE_HOME/lib/{linux_x86_64_llvm, linux_aarch64_llvm}/libclang_rt-fuzzer_no_main.a。</p>
<p>编译时需要同时启用<code>--sanitizer-coverage-inline-8bit-counters</code> 和 <code>--sanitizer-coverage-pc-table</code>。</p>
<p>C 语言 libfuzzer 输出举例</p>
<pre><code class="language-text">./a.out -print_coverage=1
COVERAGE:
COVERED_FUNC: hits: 5 edges: 6/8 LLVMFuzzerTestOneInput /tmp/test.cpp:5
  UNCOVERED_PC: /tmp/test.cpp:6
  UNCOVERED_PC: /tmp/test.cpp:9
</code></pre>
<p>仓颉语言 cj-fuzz 输出举例</p>
<pre><code class="language-text">./main -print_coverage=1 -runs=100
Done 100 runs in 0 second(s)
COVERAGE:
COVERED_FUNC: hits: 1 edges: 3/12 ttt &lt;unknown cj filename&gt;:&lt;unknown cj line number&gt;
  UNCOVERED_PC: &lt;unknown cj filename&gt;:&lt;unknown cj line number&gt;
  UNCOVERED_PC: &lt;unknown cj filename&gt;:&lt;unknown cj line number&gt;
  UNCOVERED_PC: &lt;unknown cj filename&gt;:&lt;unknown cj line number&gt;
  UNCOVERED_PC: &lt;unknown cj filename&gt;:&lt;unknown cj line number&gt;
  UNCOVERED_PC: &lt;unknown cj filename&gt;:&lt;unknown cj line number&gt;
  UNCOVERED_PC: &lt;unknown cj filename&gt;:&lt;unknown cj line number&gt;
  UNCOVERED_PC: &lt;unknown cj filename&gt;:&lt;unknown cj line number&gt;
  UNCOVERED_PC: &lt;unknown cj filename&gt;:&lt;unknown cj line number&gt;
  UNCOVERED_PC: &lt;unknown cj filename&gt;:&lt;unknown cj line number&gt;
UNCOVERED_FUNC: hits: 0 edges: 0/2 main &lt;unknown cj filename&gt;:&lt;unknown cj line number&gt;
COVERED_FUNC: hits: 1 edges: 1/1 ttt_cc_wrapper &lt;unknown cj filename&gt;:&lt;unknown cj line number&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="栈回溯缺失的处理方案"><a class="header" href="#栈回溯缺失的处理方案">栈回溯缺失的处理方案</a></h1>
<p>当前在启动 fuzz 时默认会有这三条 WARNING，因为当前 cj-fuzz 没有对它们进行实现。</p>
<pre><code class="language-text">WARNING: Failed to find function &quot;__sanitizer_acquire_crash_state&quot;.
WARNING: Failed to find function &quot;__sanitizer_print_stack_trace&quot;.
WARNING: Failed to find function &quot;__sanitizer_set_death_callback&quot;.
</code></pre>
<p>在 fuzz 过程中，可能会因为以下 3 种情况而结束 fuzz 流程：</p>
<ol>
<li>抛出异常</li>
<li>超时</li>
<li>在 C 代码中 crash</li>
</ol>
<p>其中“抛出异常”的情况，fuzz 框架对异常进行捕获后会打印栈回溯，不会造成栈回溯缺失的现象。</p>
<p>“超时”和“在 C 代码中 crash”实际是在 native 代码中触发了 SIGNAL，不属于仓颉异常，因此会造成栈回溯的缺失。</p>
<p>libfuzzer 会尝试使用 <code>__sanitizer_acquire_crash_state</code>、<code>__sanitizer_print_stack_trace</code>、<code>__sanitizer_set_death_callback</code> 等函数处理异常情况，其中 <code>__sanitizer_print_stack_trace</code> 会打印栈回溯，目前成熟的实现在 <code>llvm</code> <code>compiler-rt</code> 中的 <code>asan</code> 等模块中。</p>
<p>因此，建议的解决方案是在链接时额外加入如下的静态库文件和链接选项，释义如下：</p>
<p><code>/usr/lib/llvm-14/lib/clang/14.0.0/lib/linux/libclang_rt.asan-x86_64.a -lgcc_s --eh-frame-hdr</code></p>
<ul>
<li><code>/usr/lib/llvm-14/lib/clang/14.0.0/lib/linux/libclang_rt.asan-x86_64.a</code> 因为该 .a 文件实现了 <code>__sanitizer_print_stack_trace</code>，出于方便就直接用它；</li>
<li><code>-lgcc_s</code> 栈回溯依赖 gcc_s；</li>
<li><code>--eh-frame-hdr</code> ld 链接时生成 eh_frame_hdr 节，帮助完成栈回溯。</li>
</ul>
<p>可选的环境变量：<code>ASAN_SYMBOLIZER_PATH=$CANGJIE_HOME/third_party/llvm/bin/llvm-symbolizer</code>，可能在某些情况下有用。</p>
<p>最终会得到两套栈回溯，一套是 Exception.printStackTrace，一套是 <code>__sanitizer_print_stack_trace</code>，内容如下：</p>
<pre><code class="language-text">[WARNING]: Detect uncatched exception, maybe caused by bugs, exit now
An exception has occurred:
Exception: TRAP!
         at default.ttt(std/core::Array&lt;...&gt;)(/data/cangjie/libs/fuzz/ci_fuzzer0.cj:11)
         at _ZN7default3tttER_ZN8std$core5ArrayIhE_cc_wrapper(/data/cangjie/libs/fuzz/ci_fuzzer0.cj:0)
         at libfuzzerCallback(/data/cangjie/libs/fuzz/fuzz/callback.cj:34)
[INFO]: data is: [0, 202, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]
[INFO]: crash file will stored with libfuzzer
==425243== ERROR: libFuzzer: fuzz target exited
    #0 0x563a233fadf1 in __sanitizer_print_stack_trace (/data/cangjie/libs/fuzz/main+0x280df1)
    #1 0x563a2337c0b8 in fuzzer::PrintStackTrace() (/data/cangjie/libs/fuzz/main+0x2020b8)
    #2 0x563a2338726c in fuzzer::Fuzzer::ExitCallback() (/data/cangjie/libs/fuzz/main+0x20d26c)
    #3 0x7f485cf36494 in __run_exit_handlers stdlib/exit.c:113:8
    #4 0x7f485cf3660f in exit stdlib/exit.c:143:3
    #5 0x563a23224e68 in libfuzzerCallback$real /data/cangjie/libs/fuzz/fuzz/callback.cj:62:18
    #6 0x7f485d22718b in CJ_MCC_N2CStub (/data/cangjie/output/runtime/lib/linux_x86_64_llvm/libcangjie-runtime.so+0x2718b)
    #7 0x563a2322fc26 in libfuzzerCallback /data/cangjie/libs/fuzz/fuzz/callback.cj:20
    #8 0x563a23387883 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) (/data/cangjie/libs/fuzz/main+0x20d883)
    #9 0x563a2338a3f9 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long, bool, fuzzer::InputInfo*, bool, bool*) (/data/cangjie/libs/fuzz/main+0x2103f9)
    #10 0x563a23387e49 in fuzzer::Fuzzer::MutateAndTestOne() (/data/cangjie/libs/fuzz/main+0x20de49)
    #11 0x563a2338a2b5 in fuzzer::Fuzzer::Loop(std::vector&lt;fuzzer::SizedFile, std::allocator&lt;fuzzer::SizedFile&gt;&gt;&amp;) (/data/cangjie/libs/fuzz/main+0x2102b5)
    #12 0x563a23377a12 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) (/data/cangjie/libs/fuzz/main+0x1fda12)
    #13 0x563a231ad2b6 in fuzz_fake$fuzz::Fuzzer::startFuzz() /data/cangjie/libs/fuzz/fuzz/fuzzer.cj:200:13
    #14 0x563a23405fad in default::main() /data/cangjie/libs/fuzz/ci_fuzzer0.cj:5:5
    #15 0x563a23405fe7 in user.main /data/cangjie/libs/fuzz/&lt;stdin&gt;
    #16 0x563a234060e1 in cj_entry$ (/data/cangjie/libs/fuzz/main+0x28c0e1)
    #17 0x7f485d227220  (/data/cangjie/output/runtime/lib/linux_x86_64_llvm/libcangjie-runtime.so+0x27220)
    #18 0x7f485d223898  (/data/cangjie/output/runtime/lib/linux_x86_64_llvm/libcangjie-runtime.so+0x23898)
    #19 0x7f485d2607b9 in CJ_CJThreadEntry (/data/cangjie/output/runtime/lib/linux_x86_64_llvm/libcangjie-runtime.so+0x607b9)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdxlog"><a class="header" href="#stdxlog">stdx.log</a></h1>
<h2 id="功能介绍-11"><a class="header" href="#功能介绍-11">功能介绍</a></h2>
<p>log 包提供了一个单一的日志API，它抽象了实际的日志实现。</p>
<h2 id="api-列表-11"><a class="header" href="#api-列表-11">API 列表</a></h2>
<h3 id="函数-4"><a class="header" href="#函数-4">函数</a></h3>
<div class="table-wrapper"><table><thead><tr><th>函数名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="log/./log_package_api/log_package_funcs.html#func-getgloballoggerarrayattr">getGlobalLogger(Array&lt;Attr&gt;)</a></td><td>获取全局Logger对象。</td></tr>
<tr><td><a href="log/./log_package_api/log_package_funcs.html#func-setgloballoggerlogger">setGlobalLogger(Logger)</a></td><td>设置全局Logger对象。</td></tr>
</tbody></table>
</div>
<h3 id="类型别名-2"><a class="header" href="#类型别名-2">类型别名</a></h3>
<div class="table-wrapper"><table><thead><tr><th>类型别名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="log/./log_package_api/log_package_types.html#type-attr">Attr</a></td><td>日志消息的键值对类型，是 (String, <a href="log/./log_package_api/log_package_interfaces.html#interface-logvalue">LogValue</a>) 的类型别名。</td></tr>
</tbody></table>
</div>
<h3 id="接口-6"><a class="header" href="#接口-6">接口</a></h3>
<div class="table-wrapper"><table><thead><tr><th>接口名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="log/./log_package_api/log_package_interfaces.html#interface-logvalue">LogValue</a></td><td>为仓颉数据类型提供序列化到日志输出目标的接口。</td></tr>
</tbody></table>
</div>
<h3 id="类-17"><a class="header" href="#类-17">类</a></h3>
<div class="table-wrapper"><table><thead><tr><th>类名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="log/./log_package_api/log_package_classes.html#class-logger">Logger</a></td><td>此抽象类提供基础的日志打印和管理功能。</td></tr>
<tr><td><a href="log/./log_package_api/log_package_classes.html#class-logrecord">LogRecord</a></td><td>日志消息的“负载”。</td></tr>
<tr><td><a href="log/./log_package_api/log_package_classes.html#class-logwriter">LogWriter</a></td><td><a href="log/./log_package_api/log_package_classes.html#class-logwriter">LogWriter</a> 提供了将仓颉数据类型序列化到日志输出目标的能力。</td></tr>
<tr><td><a href="log/./log_package_api/log_package_classes.html#class-nooplogger">NoopLogger</a></td><td><a href="log/./log_package_api/log_package_classes.html#class-logger">Logger</a> 的 NO-OP（无操作）实现。</td></tr>
</tbody></table>
</div>
<h3 id="结构体-10"><a class="header" href="#结构体-10">结构体</a></h3>
<div class="table-wrapper"><table><thead><tr><th>结构体名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="log/./log_package_api/log_package_structs.html#struct-loglevel">LogLevel</a></td><td><a href="log/./log_package_api/log_package_structs.html#struct-loglevel">LogLevel</a> 为日志级别结构体。</td></tr>
</tbody></table>
</div>
<h3 id="异常类-13"><a class="header" href="#异常类-13">异常类</a></h3>
<div class="table-wrapper"><table><thead><tr><th>异常类名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="log/./log_package_api/log_package_exceptions.html#class-logexception">LogException</a></td><td>用于处理 log 相关的异常。</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="类型别名-3"><a class="header" href="#类型别名-3">类型别名</a></h1>
<h2 id="type-attr"><a class="header" href="#type-attr">type Attr</a></h2>
<pre><code class="language-cangjie">public type Attr = (String, LogValue)
</code></pre>
<p>功能：日志消息的键值对类型，是 (String, <a href="log/log_package_api/./log_package_interfaces.html#interface-logvalue">LogValue</a>) 的类型别名。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函数-5"><a class="header" href="#函数-5">函数</a></h1>
<h2 id="func-getgloballoggerarrayattr"><a class="header" href="#func-getgloballoggerarrayattr">func getGlobalLogger(Array&lt;Attr&gt;)</a></h2>
<pre><code class="language-cangjie">public func getGlobalLogger(attrs: Array&lt;Attr&gt;): Logger
</code></pre>
<p>功能：获取 <a href="log/log_package_api/log_package_classes.html#class-logger">Logger</a> 对象。</p>
<blockquote>
<p>如果未传入 attrs 参数，那么获取的是同一个 <a href="log/log_package_api/log_package_classes.html#class-logger">Logger</a> 对象，传入了 attrs 参数，则创建一个包含指定的属性的  <a href="log/log_package_api/log_package_classes.html#class-logger">Logger</a> 对象副本。</p>
</blockquote>
<p>参数：</p>
<ul>
<li>attrs: Array&lt;<a href="log/log_package_api/log_package_types.html#type-attr">Attr</a>&gt; - 日志数据键值对属性，获取的 <a href="log/log_package_api/log_package_classes.html#class-logger">Logger</a> 对象会包含这些属性。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="log/log_package_api/log_package_classes.html#class-logger">Logger</a> - <a href="log/log_package_api/log_package_classes.html#class-logger">Logger</a> 类的对象实例。</li>
</ul>
<h2 id="func-setgloballoggerlogger"><a class="header" href="#func-setgloballoggerlogger">func setGlobalLogger(Logger)</a></h2>
<pre><code class="language-cangjie">public func setGlobalLogger(logger: Logger): Unit
</code></pre>
<p>功能：设置全局 <a href="log/log_package_api/log_package_classes.html#class-logger">Logger</a> 对象。</p>
<blockquote>
<p>注意，这个函数在程序的生命周期中只应该被调用一次。对 setGlobalLogger 的调用完成之前发生的任何日志事件都将被忽略。</p>
<p>此函数通常不需要手动调用。日志实现提供者应提供包含了调用本方法的的初始化方法。</p>
</blockquote>
<p>参数：</p>
<ul>
<li>logger: <a href="log/log_package_api/log_package_classes.html#class-logger">Logger</a> - 实现了 <a href="log/log_package_api/log_package_classes.html#class-logger">Logger</a> 类的对象实例。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="接口-7"><a class="header" href="#接口-7">接口</a></h1>
<h2 id="interface-logvalue"><a class="header" href="#interface-logvalue">interface LogValue</a></h2>
<pre><code class="language-cangjie">public interface LogValue {
    func writeTo(w: LogWriter): Unit
}
</code></pre>
<p>功能：为类型提供序列化到日志输出目标的接口。</p>
<p>与 <a href="log/log_package_api/log_package_classes.html#class-logwriter">LogWriter</a> 搭配使用， <a href="log/log_package_api/log_package_classes.html#class-logwriter">LogWriter</a> 可以通过 writeValue 将实现了 <a href="log/log_package_api/log_package_interfaces.html#interface-logvalue">LogValue</a> 接口的类型写入到日志输出目标中。</p>
<h3 id="func-writetologwriter"><a class="header" href="#func-writetologwriter">func writeTo(LogWriter)</a></h3>
<pre><code class="language-cangjie">func writeTo(w: LogWriter): Unit
</code></pre>
<p>功能：将实现了 <a href="log/log_package_api/log_package_interfaces.html#interface-logvalue">LogValue</a> 接口的类型写入参数 <code>w</code> 指定的 <a href="log/log_package_api/log_package_classes.html#class-logwriter">LogWriter</a> 实例中。</p>
<p>参数：</p>
<ul>
<li>w:  <a href="log/log_package_api/log_package_classes.html#class-logwriter">LogWriter</a> - 写入序列化结果的 <a href="log/log_package_api/log_package_classes.html#class-logwriter">LogWriter</a> 实例。</li>
</ul>
<h3 id="extend-bool--logvalue"><a class="header" href="#extend-bool--logvalue">extend Bool &lt;: LogValue</a></h3>
<pre><code class="language-cangjie">extend Bool &lt;: LogValue
</code></pre>
<p>功能：为 Bool 类型实现 LogValue 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="log/log_package_api/log_package_interfaces.html#interface-logvalue">LogValue</a></li>
</ul>
<h4 id="func-writetologwriter-1"><a class="header" href="#func-writetologwriter-1">func writeTo(LogWriter)</a></h4>
<pre><code class="language-cangjie">public func writeTo(w: LogWriter): Unit
</code></pre>
<p>功能：提供 Bool 类型序列化到流的功能。</p>
<p>参数：</p>
<ul>
<li>w:  <a href="log/log_package_api/log_package_classes.html#class-logwriter">LogWriter</a> - 写入序列化结果的 <a href="log/log_package_api/log_package_classes.html#class-logwriter">LogWriter</a> 实例。</li>
</ul>
<h3 id="extend-exception--logvalue"><a class="header" href="#extend-exception--logvalue">extend Exception &lt;: LogValue</a></h3>
<pre><code class="language-cangjie">extend Exception &lt;: LogValue
</code></pre>
<p>功能：为 Exception 类型实现 <a href="log/log_package_api/./log_package_interfaces.html#interface-logvalue">LogValue</a> 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="log/log_package_api/log_package_interfaces.html#interface-logvalue">LogValue</a></li>
</ul>
<h4 id="func-writetologwriter-2"><a class="header" href="#func-writetologwriter-2">func writeTo(LogWriter)</a></h4>
<pre><code class="language-cangjie">public func writeTo(w: LogWriter): Unit
</code></pre>
<p>功能：提供 Exception 类型序列化到流的功能。</p>
<p>参数：</p>
<ul>
<li>w:  <a href="log/log_package_api/log_package_classes.html#class-logwriter">LogWriter</a> - 写入序列化结果的 <a href="log/log_package_api/log_package_classes.html#class-logwriter">LogWriter</a> 实例。</li>
</ul>
<h3 id="extend-int64--logvalue"><a class="header" href="#extend-int64--logvalue">extend Int64 &lt;: LogValue</a></h3>
<pre><code class="language-cangjie">extend Int64 &lt;: LogValue
</code></pre>
<p>功能：为 Int64 类型实现 LogValue 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="log/log_package_api/log_package_interfaces.html#interface-logvalue">LogValue</a></li>
</ul>
<h4 id="func-writetologwriter-3"><a class="header" href="#func-writetologwriter-3">func writeTo(LogWriter)</a></h4>
<pre><code class="language-cangjie">public func writeTo(w: LogWriter): Unit
</code></pre>
<p>功能：提供 Int64 类型序列化到流的功能。</p>
<p>参数：</p>
<ul>
<li>w:  <a href="log/log_package_api/log_package_classes.html#class-logwriter">LogWriter</a> - 写入序列化结果的 <a href="log/log_package_api/log_package_classes.html#class-logwriter">LogWriter</a> 实例。</li>
</ul>
<h3 id="extend-float64--logvalue"><a class="header" href="#extend-float64--logvalue">extend Float64 &lt;: LogValue</a></h3>
<pre><code class="language-cangjie">extend Float64 &lt;: LogValue
</code></pre>
<p>功能：为 Float64 类型实现 LogValue 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="log/log_package_api/log_package_interfaces.html#interface-logvalue">LogValue</a></li>
</ul>
<h4 id="func-writetologwriter-4"><a class="header" href="#func-writetologwriter-4">func writeTo(LogWriter)</a></h4>
<pre><code class="language-cangjie">public func writeTo(w: LogWriter): Unit
</code></pre>
<p>功能：提供 Float64 类型序列化到流的功能。</p>
<p>参数：</p>
<ul>
<li>w:  <a href="log/log_package_api/log_package_classes.html#class-logwriter">LogWriter</a> - 写入序列化结果的 <a href="log/log_package_api/log_package_classes.html#class-logwriter">LogWriter</a> 实例。</li>
</ul>
<h3 id="extend-string--logvalue"><a class="header" href="#extend-string--logvalue">extend String &lt;: LogValue</a></h3>
<pre><code class="language-cangjie">extend String &lt;: LogValue
</code></pre>
<p>功能：为 String 类型实现 LogValue 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="log/log_package_api/log_package_interfaces.html#interface-logvalue">LogValue</a></li>
</ul>
<h4 id="func-writetologwriter-5"><a class="header" href="#func-writetologwriter-5">func writeTo(LogWriter)</a></h4>
<pre><code class="language-cangjie">public func writeTo(w: LogWriter): Unit
</code></pre>
<p>功能：提供 String 类型序列化到流的功能。</p>
<p>参数：</p>
<ul>
<li>w:  <a href="log/log_package_api/log_package_classes.html#class-logwriter">LogWriter</a> - 写入序列化结果的 <a href="log/log_package_api/log_package_classes.html#class-logwriter">LogWriter</a> 实例。</li>
</ul>
<h3 id="extend-datetime--logvalue"><a class="header" href="#extend-datetime--logvalue">extend DateTime &lt;: LogValue</a></h3>
<pre><code class="language-cangjie">extend DateTime &lt;: LogValue
</code></pre>
<p>功能：为 DateTime 类型实现 LogValue 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="log/log_package_api/log_package_interfaces.html#interface-logvalue">LogValue</a></li>
</ul>
<h4 id="func-writetologwriter-6"><a class="header" href="#func-writetologwriter-6">func writeTo(LogWriter)</a></h4>
<pre><code class="language-cangjie">public func writeTo(w: LogWriter): Unit
</code></pre>
<p>功能：提供 DateTime 类型序列化到流的功能。</p>
<p>参数：</p>
<ul>
<li>w:  <a href="log/log_package_api/log_package_classes.html#class-logwriter">LogWriter</a> - 写入序列化结果的 <a href="log/log_package_api/log_package_classes.html#class-logwriter">LogWriter</a> 实例。</li>
</ul>
<h3 id="extend-duration--logvalue"><a class="header" href="#extend-duration--logvalue">extend Duration &lt;: LogValue</a></h3>
<pre><code class="language-cangjie">extend Duration &lt;: LogValue
</code></pre>
<p>功能：为 Duration 类型实现 LogValue 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="log/log_package_api/log_package_interfaces.html#interface-logvalue">LogValue</a></li>
</ul>
<h4 id="func-writetologwriter-7"><a class="header" href="#func-writetologwriter-7">func writeTo(LogWriter)</a></h4>
<pre><code class="language-cangjie">public func writeTo(w: LogWriter): Unit
</code></pre>
<p>功能：提供 Duration 类型序列化到流的功能。</p>
<p>参数：</p>
<ul>
<li>w:  <a href="log/log_package_api/log_package_classes.html#class-logwriter">LogWriter</a> - 写入序列化结果的 <a href="log/log_package_api/log_package_classes.html#class-logwriter">LogWriter</a> 实例。</li>
</ul>
<h3 id="extendt-arrayt--logvalue-where-t--logvalue"><a class="header" href="#extendt-arrayt--logvalue-where-t--logvalue">extend&lt;T&gt; Array&lt;T&gt; &lt;: LogValue where T &lt;: LogValue</a></h3>
<pre><code class="language-cangjie">extend&lt;T&gt; Array&lt;T&gt; &lt;: LogValue where T &lt;: LogValue
</code></pre>
<p>功能：为 Array&lt;T&gt; 类型实现 LogValue 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="log/log_package_api/log_package_interfaces.html#interface-logvalue">LogValue</a></li>
</ul>
<h4 id="func-writetologwriter-8"><a class="header" href="#func-writetologwriter-8">func writeTo(LogWriter)</a></h4>
<pre><code class="language-cangjie">public func writeTo(w: LogWriter): Unit
</code></pre>
<p>功能：提供 Array&lt;T&gt; 类型序列化到流的功能。</p>
<p>参数：</p>
<ul>
<li>w:  <a href="log/log_package_api/log_package_classes.html#class-logwriter">LogWriter</a> - 写入序列化结果的 <a href="log/log_package_api/log_package_classes.html#class-logwriter">LogWriter</a> 实例。</li>
</ul>
<h3 id="extendv-hashmapstring-v--logvalue-where-v--logvalue"><a class="header" href="#extendv-hashmapstring-v--logvalue-where-v--logvalue">extend&lt;V&gt; HashMap&lt;String, V&gt; &lt;: LogValue where V &lt;: LogValue</a></h3>
<pre><code class="language-cangjie">extend&lt;V&gt; HashMap&lt;String, V&gt; &lt;: LogValue where V &lt;: LogValue
</code></pre>
<p>功能：为 HashMap&lt;K, V&gt; 类型实现 LogValue 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="log/log_package_api/log_package_interfaces.html#interface-logvalue">LogValue</a></li>
</ul>
<h4 id="func-writetologwriter-9"><a class="header" href="#func-writetologwriter-9">func writeTo(LogWriter)</a></h4>
<pre><code class="language-cangjie">public func writeTo(w: LogWriter): Unit
</code></pre>
<p>功能：提供 HashMap&lt;K, V&gt; 类型序列化到流的功能。</p>
<p>参数：</p>
<ul>
<li>w:  <a href="log/log_package_api/log_package_classes.html#class-logwriter">LogWriter</a> - 写入序列化结果的 <a href="log/log_package_api/log_package_classes.html#class-logwriter">LogWriter</a> 实例。</li>
</ul>
<h3 id="extendv-treemapstring-v--logvalue-where-v--logvalue"><a class="header" href="#extendv-treemapstring-v--logvalue-where-v--logvalue">extend&lt;V&gt; TreeMap&lt;String, V&gt; &lt;: LogValue where V &lt;: LogValue</a></h3>
<pre><code class="language-cangjie">extend&lt;V&gt; TreeMap&lt;String, V&gt; &lt;: LogValue where V &lt;: LogValue
</code></pre>
<p>功能：为 TreeMap&lt;K, V&gt; 类型实现 LogValue 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="log/log_package_api/log_package_interfaces.html#interface-logvalue">LogValue</a></li>
</ul>
<h4 id="func-writetologwriter-10"><a class="header" href="#func-writetologwriter-10">func writeTo(LogWriter)</a></h4>
<pre><code class="language-cangjie">public func writeTo(w: LogWriter): Unit
</code></pre>
<p>功能：提供 TreeMap&lt;K, V&gt; 类型序列化到流的功能。</p>
<p>参数：</p>
<ul>
<li>w:  <a href="log/log_package_api/log_package_classes.html#class-logwriter">LogWriter</a> - 写入序列化结果的 <a href="log/log_package_api/log_package_classes.html#class-logwriter">LogWriter</a> 实例。</li>
</ul>
<h3 id="extendt-optiont--logvalue-where-t--logvalue"><a class="header" href="#extendt-optiont--logvalue-where-t--logvalue">extend&lt;T&gt; Option&lt;T&gt; &lt;: LogValue where T &lt;: LogValue</a></h3>
<pre><code class="language-cangjie">extend&lt;T&gt; Option&lt;T&gt; &lt;: LogValue where T &lt;: LogValue
</code></pre>
<p>功能：为 Option&lt;T&gt; 类型实现 LogValue 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="log/log_package_api/log_package_interfaces.html#interface-logvalue">LogValue</a></li>
</ul>
<h4 id="func-writetologwriter-11"><a class="header" href="#func-writetologwriter-11">func writeTo(LogWriter)</a></h4>
<pre><code class="language-cangjie">public func writeTo(w: LogWriter): Unit
</code></pre>
<p>功能：提供 Option&lt;T&gt; 类型序列化到流的功能。</p>
<p>参数：</p>
<ul>
<li>w:  <a href="log/log_package_api/log_package_classes.html#class-logwriter">LogWriter</a> - 写入序列化结果的 <a href="log/log_package_api/log_package_classes.html#class-logwriter">LogWriter</a> 实例。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类-18"><a class="header" href="#类-18">类</a></h1>
<h2 id="class-logger"><a class="header" href="#class-logger">class Logger</a></h2>
<pre><code class="language-cangjie">public abstract class Logger &lt;: Resource {
}
</code></pre>
<p>功能：此抽象类提供基础的日志打印和管理功能。</p>
<p>父类型：</p>
<ul>
<li>Resource</li>
</ul>
<h3 id="prop-level"><a class="header" href="#prop-level">prop level</a></h3>
<pre><code class="language-cangjie">public mut open prop level: LogLevel
</code></pre>
<p>功能：获取和修改日志打印级别。</p>
<p>类型：<a href="log/log_package_api/log_package_structs.html#struct-loglevel">LogLevel</a></p>
<h3 id="func-debugstring-arrayattr"><a class="header" href="#func-debugstring-arrayattr">func debug(String, Array&lt;Attr&gt;)</a></h3>
<pre><code class="language-cangjie">public func debug(message: String, attrs: Array&lt;Attr&gt;): Unit
</code></pre>
<p>功能：打印 <a href="log/log_package_api/log_package_structs.html#static-const-debug">DEBUG</a> 级别的日志的便捷函数。</p>
<p>参数：</p>
<ul>
<li>message: String - 日志消息。</li>
<li>attrs: Array&lt;<a href="log/log_package_api/log_package_types.html#type-attr">Attr</a>&gt; - 日志数据键值对。</li>
</ul>
<h3 id="func-debug---string-arrayattr"><a class="header" href="#func-debug---string-arrayattr">func debug(() -&gt; String, Array&lt;Attr&gt;)</a></h3>
<pre><code class="language-cangjie">public func debug(message: () -&gt; String, attrs: Array&lt;Attr&gt;): Unit
</code></pre>
<p>功能：打印 <a href="log/log_package_api/log_package_structs.html#static-const-debug">DEBUG</a> 级别的日志的便捷函数。</p>
<p>参数：</p>
<ul>
<li>message: () -&gt; String - 日志消息。</li>
<li>attrs: Array&lt;<a href="log/log_package_api/log_package_types.html#type-attr">Attr</a>&gt; - 日志数据键值对。</li>
</ul>
<h3 id="func-enabledloglevel"><a class="header" href="#func-enabledloglevel">func enabled(LogLevel)</a></h3>
<pre><code class="language-cangjie">public func enabled(level: LogLevel): Bool
</code></pre>
<p>功能：确定是否记录指定日志级别的日志消息。</p>
<p>这个函数允许调用者提前判断日志是否会被丢弃，以避免耗时的日志消息参数计算。</p>
<p>参数：</p>
<ul>
<li>level: <a href="log/log_package_api/log_package_structs.html#struct-loglevel">LogLevel</a> - 日志级别。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - 如果指定的日志级别处于使能状态，则返回 <code>true</code>；否则，返回 <code>false</code>。</li>
</ul>
<h3 id="func-errorstring-arrayattr"><a class="header" href="#func-errorstring-arrayattr">func error(String, Array&lt;Attr&gt;)</a></h3>
<pre><code class="language-cangjie">public func error(message: String, attrs: Array&lt;Attr&gt;): Unit
</code></pre>
<p>功能：打印 <a href="log/log_package_api/log_package_structs.html#static-const-error">ERROR</a> 级别的日志的便捷函数。</p>
<p>参数：</p>
<ul>
<li>message: String - 日志消息。</li>
<li>attrs: Array&lt;<a href="log/log_package_api/log_package_types.html#type-attr">Attr</a>&gt; - 日志数据键值对。</li>
</ul>
<h3 id="func-error---string-arrayattr"><a class="header" href="#func-error---string-arrayattr">func error(() -&gt; String, Array&lt;Attr&gt;)</a></h3>
<pre><code class="language-cangjie">public func error(message: () -&gt; String, attrs: Array&lt;Attr&gt;): Unit
</code></pre>
<p>功能：打印 <a href="log/log_package_api/log_package_structs.html#static-const-error">ERROR</a> 级别的日志的便捷函数。</p>
<p>参数：</p>
<ul>
<li>message: () -&gt; String - 日志消息。</li>
<li>attrs: Array&lt;<a href="log/log_package_api/log_package_types.html#type-attr">Attr</a>&gt; - 日志数据键值对。</li>
</ul>
<h3 id="func-fatalstring-arrayattr"><a class="header" href="#func-fatalstring-arrayattr">func fatal(String, Array&lt;Attr&gt;)</a></h3>
<pre><code class="language-cangjie">public func fatal(message: String, attrs: Array&lt;Attr&gt;): Unit
</code></pre>
<p>功能：打印 <a href="log/log_package_api/log_package_structs.html#static-const-fatal">FATAL</a> 级别的日志的便捷函数。</p>
<p>参数：</p>
<ul>
<li>message: String - 日志消息。</li>
<li>attrs: Array&lt;<a href="log/log_package_api/log_package_types.html#type-attr">Attr</a>&gt; - 日志数据键值对。</li>
</ul>
<h3 id="func-fatal---string-arrayattr"><a class="header" href="#func-fatal---string-arrayattr">func fatal(() -&gt; String, Array&lt;Attr&gt;)</a></h3>
<pre><code class="language-cangjie">public func fatal(message: () -&gt; String, attrs: Array&lt;Attr&gt;): Unit
</code></pre>
<p>功能：打印 <a href="log/log_package_api/log_package_structs.html#static-const-fatal">FATAL</a> 级别的日志的便捷函数。</p>
<p>参数：</p>
<ul>
<li>message: () -&gt; String - 日志消息。</li>
<li>attrs: Array&lt;<a href="log/log_package_api/log_package_types.html#type-attr">Attr</a>&gt; - 日志数据键值对。</li>
</ul>
<h3 id="func-infostring-arrayattr"><a class="header" href="#func-infostring-arrayattr">func info(String, Array&lt;Attr&gt;)</a></h3>
<pre><code class="language-cangjie">public func info(message: String, attrs: Array&lt;Attr&gt;): Unit
</code></pre>
<p>功能：打印 <a href="log/log_package_api/log_package_structs.html#static-const-info">INFO</a> 级别的日志的便捷函数。</p>
<p>参数：</p>
<ul>
<li>message: String - 日志消息。</li>
<li>attrs: Array&lt;<a href="log/log_package_api/log_package_types.html#type-attr">Attr</a>&gt; - 日志数据键值对。</li>
</ul>
<h3 id="func-info---string-arrayattr"><a class="header" href="#func-info---string-arrayattr">func info(() -&gt; String, Array&lt;Attr&gt;)</a></h3>
<pre><code class="language-cangjie">public func info(message: () -&gt; String, attrs: Array&lt;Attr&gt;): Unit
</code></pre>
<p>功能：打印 <a href="log/log_package_api/log_package_structs.html#static-const-info">INFO</a> 级别的日志的便捷函数。</p>
<p>参数：</p>
<ul>
<li>message: () -&gt; String - 日志消息。</li>
<li>attrs: Array&lt;<a href="log/log_package_api/log_package_types.html#type-attr">Attr</a>&gt; - 日志数据键值对。</li>
</ul>
<h3 id="func-logloglevel-string-arrayattr"><a class="header" href="#func-logloglevel-string-arrayattr">func log(LogLevel, String, Array&lt;Attr&gt;)</a></h3>
<pre><code class="language-cangjie">public open func log(level: LogLevel, message: String, attrs: Array&lt;Attr&gt;): Unit
</code></pre>
<p>功能：打印日志的通用函数，需指定日志级别。</p>
<p>参数：</p>
<ul>
<li>level: <a href="log/log_package_api/log_package_structs.html#struct-loglevel">LogLevel</a> - 日志级别。</li>
<li>message: String - 日志消息。</li>
<li>attrs: Array&lt;<a href="log/log_package_api/log_package_types.html#type-attr">Attr</a>&gt; - 日志数据键值对。</li>
</ul>
<h3 id="func-logloglevel----string-arrayattr"><a class="header" href="#func-logloglevel----string-arrayattr">func log(LogLevel, () -&gt; String, Array&lt;Attr&gt;)</a></h3>
<pre><code class="language-cangjie">public open func log(level: LogLevel, message: () -&gt; String, attrs: Array&lt;Attr&gt;): Unit
</code></pre>
<p>功能：打印日志的通用函数，需指定日志级别。</p>
<p>参数：</p>
<ul>
<li>level: <a href="log/log_package_api/log_package_structs.html#struct-loglevel">LogLevel</a> - 日志级别。</li>
<li>message: () -&gt; String - 日志消息。</li>
<li>attrs: Array&lt;<a href="log/log_package_api/log_package_types.html#type-attr">Attr</a>&gt; - 日志数据键值对。</li>
</ul>
<h3 id="func-loglogrecord"><a class="header" href="#func-loglogrecord">func log(LogRecord)</a></h3>
<pre><code class="language-cangjie">public open func log(record: LogRecord): Unit
</code></pre>
<p>功能：打印日志的通用函数。</p>
<p>参数：</p>
<ul>
<li>record: <a href="log/log_package_api/log_package_classes.html#class-logrecord">LogRecord</a> - 日志级别。</li>
</ul>
<h3 id="func-tracestring-arrayattr"><a class="header" href="#func-tracestring-arrayattr">func trace(String, Array&lt;Attr&gt;)</a></h3>
<pre><code class="language-cangjie">public func trace(message: String, attrs: Array&lt;Attr&gt;): Unit
</code></pre>
<p>功能：打印 <a href="log/log_package_api/log_package_structs.html#static-const-trace">TRACE</a> 级别的日志的便捷函数。</p>
<p>参数：</p>
<ul>
<li>message: String - 日志消息。</li>
<li>attrs: Array&lt;<a href="log/log_package_api/log_package_types.html#type-attr">Attr</a>&gt; - 日志数据键值对。</li>
</ul>
<h3 id="func-trace---string-arrayattr"><a class="header" href="#func-trace---string-arrayattr">func trace(() -&gt; String, Array&lt;Attr&gt;)</a></h3>
<pre><code class="language-cangjie">public func trace(message: () -&gt; String, attrs: Array&lt;Attr&gt;): Unit
</code></pre>
<p>功能：打印 <a href="log/log_package_api/log_package_structs.html#static-const-trace">TRACE</a> 级别的日志的便捷函数。</p>
<p>参数：</p>
<ul>
<li>message: () -&gt; String - 日志消息。</li>
<li>attrs: Array&lt;<a href="log/log_package_api/log_package_types.html#type-attr">Attr</a>&gt; - 日志数据键值对。</li>
</ul>
<h3 id="func-warnstring-arrayattr"><a class="header" href="#func-warnstring-arrayattr">func warn(String, Array&lt;Attr&gt;)</a></h3>
<pre><code class="language-cangjie">public func warn(message: String, attrs: Array&lt;Attr&gt;): Unit
</code></pre>
<p>功能：打印 <a href="log/log_package_api/log_package_structs.html#static-const-warn">WARN</a> 级别的日志的便捷函数。</p>
<p>参数：</p>
<ul>
<li>message: String - 日志消息。</li>
<li>attrs: Array&lt;<a href="log/log_package_api/log_package_types.html#type-attr">Attr</a>&gt; - 日志数据键值对。</li>
</ul>
<h3 id="func-warn---string-arrayattr"><a class="header" href="#func-warn---string-arrayattr">func warn(() -&gt; String, Array&lt;Attr&gt;)</a></h3>
<pre><code class="language-cangjie">public func warn(message: () -&gt; String, attrs: Array&lt;Attr&gt;): Unit
</code></pre>
<p>功能：打印 <a href="log/log_package_api/log_package_structs.html#static-const-warn">WARN</a> 级别的日志的便捷函数。</p>
<p>参数：</p>
<ul>
<li>message: () -&gt; String - 日志消息。</li>
<li>attrs: Array&lt;<a href="log/log_package_api/log_package_types.html#type-attr">Attr</a>&gt; - 日志数据键值对。</li>
</ul>
<h3 id="func-withattrsarrayattr"><a class="header" href="#func-withattrsarrayattr">func withAttrs(Array&lt;Attr&gt;)</a></h3>
<pre><code class="language-cangjie">public open func withAttrs(attrs: Array&lt;Attr&gt;): Logger
</code></pre>
<p>功能：创建当前对象的副本，新的副本会包含指定的属性。</p>
<p>参数：</p>
<ul>
<li>attrs: Array&lt;<a href="log/log_package_api/log_package_types.html#type-attr">Attr</a>&gt; - 日志数据键值对属性。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="log/log_package_api/log_package_classes.html#class-logger">Logger</a> - <a href="log/log_package_api/log_package_classes.html#class-logger">Logger</a> 类的对象实例。</li>
</ul>
<h2 id="class-logrecord"><a class="header" href="#class-logrecord">class LogRecord</a></h2>
<pre><code class="language-cangjie">public class LogRecord {
    public init(time: DateTime, level: LogLevel, msg: String, attrs: Array&lt;Attr&gt;)
}
</code></pre>
<p>功能：日志消息的“负载”。</p>
<p>记录结构作为参数传递给 <a href="log/log_package_api/log_package_classes.html#class-logger">Logger</a> 类的 <a href="log/log_package_api/log_package_classes.html#func-loglogrecord">log</a>方法。日志提供者处理这些结构以显示日志消息。记录是由日志对象自动创建，因此日志用户看不到。</p>
<h3 id="initdatetime-loglevel-string-arrayattr"><a class="header" href="#initdatetime-loglevel-string-arrayattr">init(DateTime, LogLevel, String, Array&lt;Attr&gt;)</a></h3>
<pre><code class="language-cangjie">public init(time: DateTime, level: LogLevel, msg: String, attrs: Array&lt;Attr&gt;)
</code></pre>
<p>功能：创建一个 <a href="log/log_package_api/log_package_classes.html#class-logrecord">LogRecord</a> 实例，指定时间戳，日志打印级别，日志消息和日志数据键值对。</p>
<p>参数：</p>
<ul>
<li>time: DateTime - 记录日志时的时间戳</li>
<li>level: <a href="log/log_package_api/log_package_structs.html#struct-loglevel">LogLevel</a> - 日志级别。</li>
<li>msg: String - 日志消息。</li>
<li>attrs: Array&lt;<a href="log/log_package_api/log_package_types.html#type-attr">Attr</a>&gt; - 日志数据键值对。</li>
</ul>
<h3 id="prop-attrs"><a class="header" href="#prop-attrs">prop attrs</a></h3>
<pre><code class="language-cangjie">public mut prop attrs: Array&lt;Attr&gt;
</code></pre>
<p>功能：获取或设置日志数据键值对。</p>
<p>类型：Array&lt;<a href="log/log_package_api/log_package_types.html#type-attr">Attr</a>&gt;</p>
<h3 id="prop-level-1"><a class="header" href="#prop-level-1">prop level</a></h3>
<pre><code class="language-cangjie">public prop level: LogLevel
</code></pre>
<p>功能：获取日志打印级别，只有级别小于等于该值的日志会被打印。</p>
<p>类型：<a href="log/log_package_api/log_package_structs.html#struct-loglevel">LogLevel</a></p>
<h3 id="prop-message"><a class="header" href="#prop-message">prop message</a></h3>
<pre><code class="language-cangjie">public mut prop message: String
</code></pre>
<p>功能：获取或设置日志消息。</p>
<p>类型：String</p>
<h3 id="prop-time"><a class="header" href="#prop-time">prop time</a></h3>
<pre><code class="language-cangjie">public prop time: DateTime
</code></pre>
<p>功能：获取日志打印时的时间戳。</p>
<p>类型：DateTime</p>
<h3 id="func-clone-1"><a class="header" href="#func-clone-1">func clone()</a></h3>
<pre><code class="language-cangjie">public func clone(): LogRecord
</code></pre>
<p>功能：创建当前对象的副本。</p>
<p>返回值：</p>
<ul>
<li><a href="log/log_package_api/log_package_classes.html#class-logrecord">LogRecord</a> - 当前对象的副本。</li>
</ul>
<h2 id="class-logwriter"><a class="header" href="#class-logwriter">class LogWriter</a></h2>
<pre><code class="language-cangjie">public abstract class LogWriter {
}
</code></pre>
<p>功能：<a href="log/log_package_api/log_package_classes.html#class-logwriter">LogWriter</a> 提供了将仓颉对象序列化成日志输出目标的能力。</p>
<p><a href="log/log_package_api/log_package_classes.html#class-logwriter">LogWriter</a> 需要和 interface <a href="log/log_package_api/log_package_interfaces.html#interface-logvalue">LogValue</a> 搭配使用，<a href="log/log_package_api/log_package_classes.html#class-logwriter">LogWriter</a> 可以通过 writeValue 系列方法来将实现了 <a href="log/log_package_api/log_package_interfaces.html#interface-logvalue">LogValue</a> 接口的类型写入到日志输出目标中。</p>
<h3 id="func-endarray-2"><a class="header" href="#func-endarray-2">func endArray()</a></h3>
<pre><code class="language-cangjie">public func endArray(): Unit
</code></pre>
<p>功能：结束序列化当前的 <a href="log/log_package_api/log_package_interfaces.html#interface-logvalue">LogValue</a> 数组。</p>
<p>异常：</p>
<ul>
<li>IllegalStateException - 当前 writer 没有匹配的 startArray 时。</li>
</ul>
<h3 id="func-endobject-2"><a class="header" href="#func-endobject-2">func endObject()</a></h3>
<pre><code class="language-cangjie">public func endObject(): Unit
</code></pre>
<p>功能：结束序列化当前的 <a href="log/log_package_api/log_package_interfaces.html#interface-logvalue">LogValue</a> object。</p>
<p>异常：</p>
<ul>
<li>IllegalStateException - 当前 writer 的状态不应该结束一个 <a href="log/log_package_api/log_package_interfaces.html#interface-logvalue">LogValue</a> object 时。</li>
</ul>
<h3 id="func-startarray-2"><a class="header" href="#func-startarray-2">func startArray()</a></h3>
<pre><code class="language-cangjie">public func startArray(): Unit
</code></pre>
<p>功能：开始序列化一个新的 <a href="log/log_package_api/log_package_interfaces.html#interface-logvalue">LogValue</a> 数组，每一个 startArray 都必须有一个 endArray 对应。</p>
<p>异常：</p>
<ul>
<li>IllegalStateException - 当前 writer 的状态不应该写入 <a href="log/log_package_api/log_package_interfaces.html#interface-logvalue">LogValue</a> array 时。</li>
</ul>
<h3 id="func-startobject-2"><a class="header" href="#func-startobject-2">func startObject()</a></h3>
<pre><code class="language-cangjie">public func startObject(): Unit
</code></pre>
<p>功能：开始序列化一个新的 <a href="log/log_package_api/log_package_interfaces.html#interface-logvalue">LogValue</a> object，每一个 startObject 都必须有一个 endObject 对应。</p>
<p>异常：</p>
<ul>
<li>IllegalStateException - 当前 writer 的状态不应该写入 <a href="log/log_package_api/log_package_interfaces.html#interface-logvalue">LogValue</a> object 时。</li>
</ul>
<h3 id="func-writeboolbool"><a class="header" href="#func-writeboolbool">func writeBool(Bool)</a></h3>
<pre><code class="language-cangjie">public func writeBool(v: Bool): Unit
</code></pre>
<p>功能：向日志输出目标中写入 Bool 值。</p>
<p>参数：</p>
<ul>
<li>v: Bool - 待写入的 Bool 值。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalStateException - 当前 writer 的状态不应该写入 value 时。</li>
</ul>
<h3 id="func-writefloatfloat64"><a class="header" href="#func-writefloatfloat64">func writeFloat(Float64)</a></h3>
<pre><code class="language-cangjie">public func writeFloat(v: Float64): Unit
</code></pre>
<p>功能：向日志输出目标中写入 Float64 值。</p>
<p>参数：</p>
<ul>
<li>v: Float64 - 待写入的 Float64 值。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalStateException - 当前 writer 的状态不应该写入 value 时。</li>
</ul>
<h3 id="func-writedatetimedatetime"><a class="header" href="#func-writedatetimedatetime">func writeDateTime(DateTime)</a></h3>
<pre><code class="language-cangjie">public func writeDateTime(v: DateTime): Unit
</code></pre>
<p>功能：向日志输出目标中写入 DateTime 值。</p>
<p>参数：</p>
<ul>
<li>v: DateTime - 待写入的 DateTime 值。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalStateException - 当前 writer 的状态不应该写入 value 时。</li>
</ul>
<h3 id="func-writedurationduration"><a class="header" href="#func-writedurationduration">func writeDuration(Duration)</a></h3>
<pre><code class="language-cangjie">public func writeDuration(v: Duration): Unit
</code></pre>
<p>功能：向日志输出目标中写入 Duration 值。</p>
<p>参数：</p>
<ul>
<li>v: Duration - 待写入的 Duration 值。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalStateException - 当前 writer 的状态不应该写入 value 时。</li>
</ul>
<h3 id="func-writeexceptionexception"><a class="header" href="#func-writeexceptionexception">func writeException(Exception)</a></h3>
<pre><code class="language-cangjie">public func writeException(v: Exception): Unit
</code></pre>
<p>功能：向日志输出目标中写入 Exception 值。</p>
<p>参数：</p>
<ul>
<li>v: Exception - 待写入的 Exception 值。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalStateException - 当前 writer 的状态不应该写入 value 时，抛出该异常。</li>
</ul>
<h3 id="func-writeintint64"><a class="header" href="#func-writeintint64">func writeInt(Int64)</a></h3>
<pre><code class="language-cangjie">public func writeInt(v: Int64): Unit
</code></pre>
<p>功能：向日志输出目标中写入 Int64 值。</p>
<p>参数：</p>
<ul>
<li>v: Int64 - 待写入的 Int64 值。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalStateException - 当前 writer 的状态不应该写入 value 时。</li>
</ul>
<h3 id="func-writekeystring"><a class="header" href="#func-writekeystring">func writeKey(String)</a></h3>
<pre><code class="language-cangjie">public func writeKey(v: String): Unit
</code></pre>
<p>功能：向日志输出目标中写入 name。</p>
<p>参数：</p>
<ul>
<li>v: String - 待写入的 Key 值。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalStateException - 当前 writer 的状态不应写入参数 <code>name</code> 指定字符串时。</li>
</ul>
<h3 id="func-writenone"><a class="header" href="#func-writenone">func writeNone()</a></h3>
<pre><code class="language-cangjie">public func writeNone(): Unit
</code></pre>
<p>功能：向日志输出目标中写入 None，具体写成什么格式由 Logger 的提供者自行决定。</p>
<p>异常：</p>
<ul>
<li>IllegalStateException - 当前 writer 的状态不应该写入 value 时。</li>
</ul>
<h3 id="func-writestringstring"><a class="header" href="#func-writestringstring">func writeString(String)</a></h3>
<pre><code class="language-cangjie">public func writeString(v: String): Unit
</code></pre>
<p>功能：向日志输出目标中写入 String 值。</p>
<p>参数：</p>
<ul>
<li>v: String  - 待写入的 String 值。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalStateException - 当前 writer 的状态不应该写入 value 时。</li>
</ul>
<h3 id="func-writevaluelogvalue"><a class="header" href="#func-writevaluelogvalue">func writeValue(LogValue)</a></h3>
<pre><code class="language-cangjie">public func writeValue(v: LogValue): Unit
</code></pre>
<p>功能：将实现了 <a href="log/log_package_api/log_package_interfaces.html#interface-logvalue">LogValue</a> 接口的类型写入到日志输出目标中。该接口会调用 <a href="log/log_package_api/log_package_interfaces.html#interface-logvalue">LogValue</a> 的 <a href="log/log_package_api/log_package_interfaces.html#func-writetologwriter">writeTo</a> 方法向日志输出目标中写入数据。</p>
<p>log 包已经为基础类型 Int64、Float64、Bool、String 类型扩展实现了 <a href="log/log_package_api/log_package_interfaces.html#interface-logvalue">LogValue</a>，并且为 DateTime、Duration、 Collection 类型 Array、HashMap 和 TreeMap 以及 Option&lt;T&gt; 扩展实现了 <a href="log/log_package_api/log_package_interfaces.html#interface-logvalue">LogValue</a>。</p>
<p>参数：</p>
<ul>
<li>v: <a href="log/log_package_api/log_package_interfaces.html#interface-logvalue">LogValue</a> - 待写入的 <a href="log/log_package_api/log_package_interfaces.html#interface-logvalue">LogValue</a> 值。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalStateException - 当前 writer 的状态不应该写入 value 时。</li>
</ul>
<h2 id="class-nooplogger"><a class="header" href="#class-nooplogger">class NoopLogger</a></h2>
<pre><code class="language-cangjie">public class NoopLogger &lt;: Logger {
    public init()
}
</code></pre>
<p>功能：<a href="log/log_package_api/log_package_classes.html#class-logger">Logger</a> 的 NO-OP（无操作）实现，会丢弃所有的日志。</p>
<p>父类型：</p>
<ul>
<li><a href="log/log_package_api/log_package_classes.html#class-logger">Logger</a></li>
</ul>
<h3 id="init-17"><a class="header" href="#init-17">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：创建一个 <a href="log/log_package_api/log_package_classes.html#class-nooplogger">NoopLogger</a> 实例。</p>
<h3 id="prop-level-2"><a class="header" href="#prop-level-2">prop level</a></h3>
<pre><code class="language-cangjie">public mut prop level: LogLevel
</code></pre>
<p>功能：永远只能获取到 OFF 日志打印级别，设置日志打印级别不会生效。</p>
<p>类型：<a href="log/log_package_api/log_package_structs.html#struct-loglevel">LogLevel</a></p>
<h3 id="func-close-4"><a class="header" href="#func-close-4">func close()</a></h3>
<pre><code class="language-cangjie">public func close(): Unit
</code></pre>
<p>功能：NOOP 实现。</p>
<h3 id="func-isclosed"><a class="header" href="#func-isclosed">func isClosed()</a></h3>
<pre><code class="language-cangjie">public func isClosed(): Bool
</code></pre>
<p>功能：NOOP 实现。</p>
<p>返回值：</p>
<ul>
<li>Bool。</li>
</ul>
<h3 id="func-logloglevel-string-arrayattr-1"><a class="header" href="#func-logloglevel-string-arrayattr-1">func log(LogLevel, String, Array&lt;Attr&gt;)</a></h3>
<pre><code class="language-cangjie">public func log(level: LogLevel, message: String, attrs: Array&lt;Attr&gt;): Unit
</code></pre>
<p>功能：NOOP 实现。</p>
<p>参数：</p>
<ul>
<li>level: <a href="log/log_package_api/log_package_structs.html#struct-loglevel">LogLevel</a> - 日志级别。</li>
<li>message: String - 日志消息。</li>
<li>attrs: Array&lt;<a href="log/log_package_api/log_package_types.html#type-attr">Attr</a>&gt; - 日志数据键值对。</li>
</ul>
<h3 id="func-logloglevel----string-arrayattr-1"><a class="header" href="#func-logloglevel----string-arrayattr-1">func log(LogLevel, () -&gt; String, Array&lt;Attr&gt;)</a></h3>
<pre><code class="language-cangjie">public func log(level: LogLevel, message: () -&gt; String, attrs: Array&lt;Attr&gt;): Unit
</code></pre>
<p>功能：NOOP 实现。</p>
<p>参数：</p>
<ul>
<li>level: <a href="log/log_package_api/log_package_structs.html#struct-loglevel">LogLevel</a> - 日志级别。</li>
<li>message: () -&gt; String - 日志消息。</li>
<li>attrs: Array&lt;<a href="log/log_package_api/log_package_types.html#type-attr">Attr</a>&gt; - 日志数据键值对。</li>
</ul>
<h3 id="func-loglogrecord-1"><a class="header" href="#func-loglogrecord-1">func log(LogRecord)</a></h3>
<pre><code class="language-cangjie">public func log(record: LogRecord): Unit
</code></pre>
<p>功能：NOOP 实现。</p>
<p>参数：</p>
<ul>
<li>record: <a href="log/log_package_api/log_package_classes.html#class-logrecord">LogRecord</a> - 日志级别。</li>
</ul>
<h3 id="func-withattrsarrayattr-1"><a class="header" href="#func-withattrsarrayattr-1">func withAttrs(Array&lt;Attr&gt;)</a></h3>
<pre><code class="language-cangjie">public func withAttrs(attrs: Array&lt;Attr&gt;): Logger
</code></pre>
<p>功能：NOOP 实现。</p>
<p>参数：</p>
<ul>
<li>attrs: Array&lt;<a href="log/log_package_api/log_package_types.html#type-attr">Attr</a>&gt; - 日志数据键值对。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="log/log_package_api/./log_package_classes.html#class-logger">Logger</a> - Logger</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="结构体-11"><a class="header" href="#结构体-11">结构体</a></h1>
<h2 id="struct-loglevel"><a class="header" href="#struct-loglevel">struct LogLevel</a></h2>
<pre><code class="language-cangjie">public struct LogLevel &lt;: ToString &amp; Comparable&lt;LogLevel&gt; {
    public static const OFF = LogLevel(&quot;OFF&quot;, 0x7FFF_FFFF)
    public static const FATAL = LogLevel(&quot;FATAL&quot;, 6000)
    public static const ERROR = LogLevel(&quot;ERROR&quot;, 5000)
    public static const WARN = LogLevel(&quot;WARN&quot;, 4000)
    public static const INFO = LogLevel(&quot;INFO&quot;, 3000)
    public static const DEBUG = LogLevel(&quot;DEBUG&quot;, 2000)
    public static const TRACE = LogLevel(&quot;TRACE&quot;, 1000)
    public static const ALL = LogLevel(&quot;ALL&quot;, -0x8000_0000)
    public let name: String
    public let value: Int32
    public const init(name: String, value: Int32)
}
</code></pre>
<p>功能：<a href="log/log_package_api/log_package_structs.html#struct-loglevel">LogLevel</a> 为日志级别结构体。</p>
<p>定义了日志打印的七个级别，级别从低到高分别为 <code>OFF</code>、 <code>FATAL</code>、<code>ERROR</code>、<code>WARN</code>、<code>INFO</code>、<code>DEBUG</code>、<code>TRACE</code>、<code>ALL</code>。</p>
<p>我们期望只有级别小于等于指定打印级别的日志条目会被打印到输出流中。</p>
<p>父类型：</p>
<ul>
<li>ToString</li>
<li>Comparable&lt;<a href="log/log_package_api/log_package_structs.html#struct-loglevel">LogLevel</a>&gt;</li>
</ul>
<h3 id="let-name"><a class="header" href="#let-name">let name</a></h3>
<pre><code class="language-cangjie">public let name: String
</code></pre>
<p>功能：日志级别名。</p>
<h3 id="let-value"><a class="header" href="#let-value">let value</a></h3>
<pre><code class="language-cangjie">public let value: Int32
</code></pre>
<p>功能：日志级别值。</p>
<h3 id="initstring-int32"><a class="header" href="#initstring-int32">init(String, Int32)</a></h3>
<pre><code class="language-cangjie">public const init(name: String, value: Int32)
</code></pre>
<p>功能：常量构造函数，创建 LogLevel 对象。</p>
<p>参数：</p>
<ul>
<li>name: String - 日志级别名。</li>
<li>value: Int32 - 日志级别值。</li>
</ul>
<h3 id="static-const-all"><a class="header" href="#static-const-all">static const ALL</a></h3>
<pre><code class="language-cangjie">public static const ALL = LogLevel(&quot;ALL&quot;, -0x8000_0000)
</code></pre>
<p>功能：获取一个日志打印级别的静态常量实例，等级为所有。</p>
<h3 id="static-const-debug"><a class="header" href="#static-const-debug">static const DEBUG</a></h3>
<pre><code class="language-cangjie">public static const DEBUG = LogLevel(&quot;DEBUG&quot;, 2000)
</code></pre>
<p>功能：获取一个日志打印级别的静态常量实例，等级为调试。</p>
<h3 id="static-const-error"><a class="header" href="#static-const-error">static const ERROR</a></h3>
<pre><code class="language-cangjie">public static const ERROR = LogLevel(&quot;ERROR&quot;, 5000)
</code></pre>
<p>功能：获取一个日志打印级别的静态常量实例，等级为错误。</p>
<h3 id="static-const-fatal"><a class="header" href="#static-const-fatal">static const FATAL</a></h3>
<pre><code class="language-cangjie">public static const FATAL = LogLevel(&quot;FATAL&quot;, 6000)
</code></pre>
<p>功能：获取一个日志打印级别的静态常量实例，等级为严重错误。</p>
<h3 id="static-const-info"><a class="header" href="#static-const-info">static const INFO</a></h3>
<pre><code class="language-cangjie">public static const INFO = LogLevel(&quot;INFO&quot;, 3000)
</code></pre>
<p>功能：获取一个日志打印级别的静态常量实例，等级为通知。</p>
<h3 id="static-const-off"><a class="header" href="#static-const-off">static const OFF</a></h3>
<pre><code class="language-cangjie">public static const OFF = LogLevel(&quot;OFF&quot;, 0x7FFF_FFFF)
</code></pre>
<p>功能：获取一个日志打印级别的静态常量实例，等级为禁用。</p>
<h3 id="static-const-trace"><a class="header" href="#static-const-trace">static const TRACE</a></h3>
<pre><code class="language-cangjie">public static const TRACE = LogLevel(&quot;TRACE&quot;, 1000)
</code></pre>
<p>功能：获取一个日志打印级别的静态常量实例，等级为跟踪。</p>
<h3 id="static-const-warn"><a class="header" href="#static-const-warn">static const WARN</a></h3>
<pre><code class="language-cangjie">public static const WARN = LogLevel(&quot;WARN&quot;, 4000)
</code></pre>
<p>功能：获取一个日志打印级别的静态常量实例，等级为警告。</p>
<h3 id="func-compareloglevel"><a class="header" href="#func-compareloglevel">func compare(LogLevel)</a></h3>
<pre><code class="language-cangjie">public func compare(rhs: LogLevel): Ordering
</code></pre>
<p>功能：判断当前 <a href="log/log_package_api/log_package_structs.html#struct-loglevel">LogLevel</a> 类型实例与参数指向的 <a href="log/log_package_api/log_package_structs.html#struct-loglevel">LogLevel</a> 类型实例的大小关系。</p>
<p>参数：</p>
<ul>
<li>rhs: <a href="log/log_package_api/log_package_structs.html#struct-loglevel">LogLevel</a> - 待与当前实例比较的另一个实例。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Ordering - 如果大于，返回 Ordering.GT，如果等于，返回 Ordering.EQ，如果小于，返回 Ordering.LT。</li>
</ul>
<h3 id="func-tostring-28"><a class="header" href="#func-tostring-28">func toString()</a></h3>
<pre><code class="language-cangjie">public func toString(): String
</code></pre>
<p>功能：获取日志级别对应的名称。</p>
<p>返回值：</p>
<ul>
<li>String - 当前的日志级别的名称。</li>
</ul>
<h3 id="operator-func-loglevel"><a class="header" href="#operator-func-loglevel">operator func ==(LogLevel)</a></h3>
<pre><code class="language-cangjie">public operator func ==(rhs: LogLevel): Bool
</code></pre>
<p>功能：比较日志级别高低。</p>
<p>参数：</p>
<ul>
<li>rhs: <a href="log/log_package_api/log_package_structs.html#struct-loglevel">LogLevel</a> - 将当前日志级别和 <code>target</code> 进行比较。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - 如果当前日志级别等于 <code>target</code>，返回 <code>true</code>，否则返回 <code>false</code>。</li>
</ul>
<h3 id="operator-func-loglevel-1"><a class="header" href="#operator-func-loglevel-1">operator func !=(LogLevel)</a></h3>
<pre><code class="language-cangjie">public operator func !=(rhs: LogLevel): Bool
</code></pre>
<p>功能：比较日志级别高低。</p>
<p>参数：</p>
<ul>
<li>rhs: <a href="log/log_package_api/log_package_structs.html#struct-loglevel">LogLevel</a> - 将当前日志级别和 <code>target</code> 进行比较。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - 如果当前日志级别不等于 <code>target</code>，返回 <code>true</code>，否则返回 <code>false</code>。</li>
</ul>
<h3 id="operator-func-loglevel-2"><a class="header" href="#operator-func-loglevel-2">operator func &gt;=(LogLevel)</a></h3>
<pre><code class="language-cangjie">public operator func &gt;=(rhs: LogLevel): Bool
</code></pre>
<p>功能：比较日志级别高低。</p>
<p>参数：</p>
<ul>
<li>rhs: <a href="log/log_package_api/log_package_structs.html#struct-loglevel">LogLevel</a> - 将当前日志级别和 <code>target</code> 进行比较。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - 如果当前日志级别大于等于 <code>target</code>，返回 <code>true</code>，否则返回 <code>false</code>。</li>
</ul>
<h3 id="operator-func-loglevel-3"><a class="header" href="#operator-func-loglevel-3">operator func &lt;=(LogLevel)</a></h3>
<pre><code class="language-cangjie">public operator func &lt;=(rhs: LogLevel): Bool
</code></pre>
<p>功能：比较日志级别高低。</p>
<p>参数：</p>
<ul>
<li>rhs: <a href="log/log_package_api/log_package_structs.html#struct-loglevel">LogLevel</a> - 将当前日志级别和 <code>target</code> 进行比较。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - 如果当前日志级别小于等于 <code>target</code>，返回 <code>true</code>，否则返回 <code>false</code>。</li>
</ul>
<h3 id="operator-func-loglevel-4"><a class="header" href="#operator-func-loglevel-4">operator func &gt;(LogLevel)</a></h3>
<pre><code class="language-cangjie">public operator func &gt;(rhs: LogLevel): Bool
</code></pre>
<p>功能：比较日志级别高低。</p>
<p>参数：</p>
<ul>
<li>rhs: <a href="log/log_package_api/log_package_structs.html#struct-loglevel">LogLevel</a> - 将当前日志级别和 <code>target</code> 进行比较。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - 如果当前日志级别大于 <code>target</code>，返回 <code>true</code>，否则返回 <code>false</code>。</li>
</ul>
<h3 id="operator-func-loglevel-5"><a class="header" href="#operator-func-loglevel-5">operator func &lt;(LogLevel)</a></h3>
<pre><code class="language-cangjie">public operator func &lt;(rhs: LogLevel): Bool
</code></pre>
<p>功能：比较日志级别高低。</p>
<p>参数：</p>
<ul>
<li>rhs: <a href="log/log_package_api/log_package_structs.html#struct-loglevel">LogLevel</a> - 将当前日志级别和 <code>target</code> 进行比较。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - 如果当前日志级别小于 <code>target</code>，返回 <code>true</code>，否则返回 <code>false</code>。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="异常类-14"><a class="header" href="#异常类-14">异常类</a></h1>
<h2 id="class-logexception"><a class="header" href="#class-logexception">class LogException</a></h2>
<pre><code class="language-cangjie">public open class LogException &lt;: Exception {
    public init()
    public init(message: String)
}
</code></pre>
<p>功能：用于处理 log 相关的异常。</p>
<p>父类型：</p>
<ul>
<li>Exception</li>
</ul>
<h3 id="init-18"><a class="header" href="#init-18">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：无参构造函数。</p>
<h3 id="initstring-10"><a class="header" href="#initstring-10">init(String)</a></h3>
<pre><code class="language-cangjie">public init(message: String)
</code></pre>
<p>功能：根据异常信息创建 <a href="log/log_package_api/log_package_exceptions.html#class-logexception">LogException</a> 实例。</p>
<p>参数：</p>
<ul>
<li>message: String - 异常信息。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="日志打印示例"><a class="header" href="#日志打印示例">日志打印示例</a></h1>
<h2 id="库开发场景记录日志"><a class="header" href="#库开发场景记录日志">库开发场景记录日志</a></h2>
<p>下面是开发仓颉库时，打印日志的示例。</p>
<p>代码如下：</p>
<!-- run -->
<pre><code class="language-cangjie">import stdx.log.*
import stdx.logger.*
import std.env.*

public class PGConnection {
    let objId: Int64 = 1
    let logger = getGlobalLogger((&quot;name&quot;, &quot;PGConnection&quot;))

    public func close(): Unit {
        logger.trace(&quot;driver conn closed&quot;, (&quot;id&quot;, objId))
    }
}

main ():Unit {
    let tl = SimpleLogger(getStdOut())
    tl.level = LogLevel.TRACE
    setGlobalLogger(tl)
    var conn = PGConnection()
    conn.close()
}
</code></pre>
<p>运行结果可能如下：</p>
<pre><code class="language-text">2024-11-21T20:16:43.33200773+08:00 TRACE driver conn closed name=&quot;PGConnection&quot; id=1
</code></pre>
<h2 id="应用程序开发场景日志打印"><a class="header" href="#应用程序开发场景日志打印">应用程序开发场景日志打印</a></h2>
<p>下面是 自定义 PasswordFilter 和 TextLogger 日志打印示例。</p>
<p>代码如下：</p>
<!-- run -->
<pre><code class="language-cangjie">import std.time.*
import std.io.{OutputStream, ByteBuffer, BufferedOutputStream}
import std.env.*
import std.fs.*
import std.collection.{ArrayList, Map, HashMap}
import std.collection.concurrent.*
import std.sync.AtomicBool
import std.time.DateTime
import stdx.log.*

public class PasswordFilter &lt;: Logger {
    var _level = LogLevel.INFO
    let processor: Logger
    public init(logger: Logger) {
        processor = logger
    }
    public mut prop level: LogLevel {
        get() {
            _level
        }
        set(v) {
            _level = v
        }
    }
    public func withAttrs(attrs: Array&lt;Attr&gt;): Logger {
        this
    }
    // log
    public func log(level: LogLevel, message: String, attrs: Array&lt;Attr&gt;): Unit {
        let record: LogRecord = LogRecord(DateTime.now(), level, message, attrs)
        log(record)
    }
    // lazy
    public func log(level: LogLevel, message: () -&gt; String, attrs: Array&lt;Attr&gt;): Unit {
        let record: LogRecord = LogRecord(DateTime.now(), level, message(), attrs)
        log(record)
    }
    // 根据键值对的名字过滤，将密码值换成 &quot;***&quot;
    public func log(record: LogRecord): Unit {
        var attrs = record.attrs.clone()
        for (i in 0..attrs.size) {
            var attr = attrs[i]
            if (attr[0] == &quot;password&quot;) {
                attrs[i] = (attr[0], &quot;***&quot;)
            }
        }
        let r = LogRecord(record.time, record.level, record.message, attrs)
        processor.log(r)
    }
    public func isClosed(): Bool {
        false
    }
    public func close(): Unit {
    }
}

main() {
    let o = ByteBuffer()
    let tl = TextLogger(getStdOut())
    tl.level = LogLevel.TRACE
    let l = PasswordFilter(tl)
    setGlobalLogger(l)
    let logger = getGlobalLogger([(&quot;name&quot;, &quot;main&quot;)])
    let user = User()
    // 普通记录信息日志
    logger.info(&quot;Hello, World!&quot;, (&quot;k1&quot;, [[1, 4], [2, 5], [3]]), (&quot;password&quot;, &quot;v22222&quot;))
    // 记录诊断日志，如果 DEBUG 级别未开启，直接返回，几乎无cost
    logger.debug(&quot;Logging in user ${user.name} with birthday ${user.birthdayCalendar}&quot;)

    // lazy 方式记录耗时日志数据
    logger.log(LogLevel.ERROR, &quot;long-running operation msg&quot;, (&quot;k1&quot;, 100), (&quot;k2&quot;, user.birthdayCalendar),
        (&quot;oper&quot;, ToStringWrapper({=&gt; &quot;Some long-running operation returned&quot;})))

    logger.log(LogLevel.ERROR, &quot;long-running operation msg&quot;, (&quot;sourcePackage&quot;, @sourcePackage()),
        (&quot;sourceFile&quot;, @sourceFile()), (&quot;sourceLine&quot;, @sourceLine()), (&quot;birthdayCalendar&quot;, user.birthdayCalendar),
        (&quot;oper&quot;, ToStringWrapper({=&gt; &quot;Some long-running operation returned&quot;})))

    let m = HashMap&lt;String, String&gt;()
    m.add(&quot;k1&quot;, &quot;1&quot;)
    m.add(&quot;k2&quot;, &quot;2&quot;)
    m.add(&quot;k3&quot;, &quot;3&quot;)
    logger.trace({=&gt; &quot;Some long-running operation returned&quot;}, (&quot;k1&quot;, m))
    let m2 = HashMap&lt;String, LogValue&gt;()
    m2.add(&quot;g1&quot;, m)

    // 如果TRACE 级别没有开启，那么lambda表达式不会被执行
    logger.trace({=&gt; &quot;Some long-running operation returned&quot;}, (&quot;k2&quot;, m2))

    // Console.stdOut.write(o.bytes())
    // Console.stdOut.flush()
}

public class User {
    public prop name: String {
        get() {
            &quot;foo&quot;
        }
    }
    public prop birthdayCalendar: DateTime {
        get() {
            DateTime.now()
        }
    }
}

public class ToStringWrapper &lt;: ToString &amp; LogValue {
    let _fn: () -&gt; String
    public init(fn: () -&gt; String) {
        _fn = fn
    }
    public func toString(): String {
        return _fn()
    }
    public func writeTo(w: LogWriter): Unit {
        w.writeValue(_fn())
    }
}

func expensiveOperation(): String {
    for (_ in 0..1000000) {
        unsafe {
            let b = LibC.malloc&lt;Byte&gt;(count: 1000)
            LibC.free(b)
        }
    }
    &quot;Some long-running operation returned&quot;
}

public class TextLogger &lt;: Logger {
    let w: TextLogWriter
    let opts = HashMap&lt;String, String&gt;()
    let _closed = AtomicBool(false)
    let queue = ConcurrentLinkedQueue&lt;LogRecord&gt;()
    let bo: BufferedOutputStream&lt;OutputStream&gt;
    let _attrs = ArrayList&lt;Attr&gt;()
    var _level = LogLevel.INFO
    public init(output: OutputStream) {
        bo = BufferedOutputStream&lt;OutputStream&gt;(output)
        w = TextLogWriter(bo)
    }

    public mut prop level: LogLevel {
        get() {
            _level
        }
        set(v) {
            _level = v
        }
    }
    public func withAttrs(attrs: Array&lt;Attr&gt;): Logger {
        if (attrs.size &gt; 0) {
            let nl = TextLogger(w.out)
            nl._attrs.add(all: attrs)
            return nl
        }
        return this
    }
    // log
    public func log(level: LogLevel, message: String, attrs: Array&lt;Attr&gt;): Unit {
        if (this.enabled(level)) {
            let record: LogRecord = LogRecord(DateTime.now(), level, message, attrs)
            log(record)
        }
    }
    // lazy
    public func log(level: LogLevel, message: () -&gt; String, attrs: Array&lt;Attr&gt;): Unit {
        if (this.enabled(level)) {
            let record: LogRecord = LogRecord(DateTime.now(), level, message(), attrs)
            log(record)
        }
    }
    public func log(record: LogRecord): Unit {
        // write time
        w.writeKey(&quot;time&quot;)
        w.writeValue(record.time)
        w.writeString(&quot; &quot;)
        // write level
        w.writeKey(&quot;level&quot;)
        w.writeString(record.level.toString())
        w.writeString(&quot; &quot;)
        // write message
        w.writeKey(&quot;msg&quot;)
        w.writeValue(record.message)
        w.writeString(&quot; &quot;)
        // write source

        // write attrs
        for (i in 0..record.attrs.size) {
            let attr = record.attrs[i]
            w.writeKey(attr[0])
            w.writeValue(attr[1])
            if (i &lt; record.attrs.size - 1) {
                w.writeString(&quot; &quot;)
            }
        }
        w.writeString(&quot;\n&quot;)
        bo.flush()
    }
    public func isClosed(): Bool {
        _closed.load()
    }
    public func close(): Unit {
        if (isClosed()) {
            return
        }
        _closed.store(true)
    }
}

class TextLogWriter &lt;: LogWriter {
    var out: OutputStream
    init(out: OutputStream) {
        this.out = out
    }
    public func writeNone(): Unit {
        out.write(&quot;None&quot;.toArray())
    }
    public func writeInt(v: Int64): Unit {
        out.write(v.toString().toArray())
    }
    public func writeUInt(v: UInt64): Unit {
        out.write(v.toString().toArray())
    }
    public func writeBool(v: Bool): Unit {
        out.write(v.toString().toArray())
    }
    public func writeFloat(v: Float64): Unit {
        out.write(v.toString().toArray())
    }
    public func writeString(v: String): Unit {
        out.write(v.toArray())
    }
    public func writeDateTime(v: DateTime): Unit {
        out.write(v.toString().toArray())
    }
    public func writeDuration(v: Duration): Unit {
        out.write(v.toString().toArray())
    }
    public func writeException(v: Exception): Unit {
        out.write(v.toString().toArray())
    }
    public func writeKey(v: String): Unit {
        out.write(v.toString().toArray())
        out.write(&quot;=&quot;.toArray())
    }
    public func writeValue(v: LogValue): Unit {
        match (v) {
            case vv: String =&gt;
                out.write(&quot;\&quot;&quot;.toArray())
                out.write(vv.toArray())
                out.write(&quot;\&quot;&quot;.toArray())
            case vv: ToString =&gt;
                out.write(&quot;\&quot;&quot;.toArray())
                out.write(vv.toString().toArray())
                out.write(&quot;\&quot;&quot;.toArray())
            case _ =&gt;
                out.write(&quot;\&quot;&quot;.toArray())
                v.writeTo(this)
                out.write(&quot;\&quot;&quot;.toArray())
        }
    }
    public func startArray(): Unit {
        out.write(&quot;[&quot;.toArray())
    }
    public func endArray(): Unit {
        out.write(&quot;]&quot;.toArray())
    }
    public func startObject(): Unit {
        out.write(&quot;{&quot;.toArray())
    }
    public func endObject(): Unit {
        out.write(&quot;}&quot;.toArray())
    }
}
</code></pre>
<p>运行结果可能如下：</p>
<pre><code class="language-text">time=&quot;2024-06-17T14:10:07.1861349Z&quot; level=INFO msg=&quot;Hello, World!&quot; k1=&quot;[[1, 4], [2, 5], [3]]&quot; password=&quot;***&quot;
time=&quot;2024-06-17T14:10:07.1864929Z&quot; level=DEBUG msg=&quot;Logging in user foo with birthday 2024-06-17T14:10:07.1864802Z&quot;
time=&quot;2024-06-17T14:10:07.1869579Z&quot; level=ERROR msg=&quot;long-running operation msg&quot; k1=&quot;100&quot; k2=&quot;2024-06-17T14:10:07.186957Z&quot; oper=&quot;Some long-running operation returned&quot;
time=&quot;2024-06-17T14:10:07.18742Z&quot; level=ERROR msg=&quot;long-running operation msg&quot; sourcePackage=&quot;log&quot; sourceFile=&quot;main.cj&quot; sourceLine=&quot;77&quot; birthdayCalendar=&quot;2024-06-17T14:10:07.1874188Z&quot; oper=&quot;Some long-running operation returned&quot;
time=&quot;2024-06-17T14:10:07.1879195Z&quot; level=TRACE msg=&quot;Some long-running operation returned&quot; k1=&quot;[(k1, 1), (k2, 2), (k3, 3)]&quot;
time=&quot;2024-06-17T14:10:07.1881599Z&quot; level=TRACE msg=&quot;Some long-running operation returned&quot; k2=&quot;{g1=&quot;[(k1, 1), (k2, 2), (k3, 3)]&quot;}&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdxlogger"><a class="header" href="#stdxlogger">stdx.logger</a></h1>
<h2 id="功能介绍-12"><a class="header" href="#功能介绍-12">功能介绍</a></h2>
<p><code>logger</code> 包提供文本格式和 <code>JSON</code> 格式日志打印功能。</p>
<h2 id="api-列表-12"><a class="header" href="#api-列表-12">API 列表</a></h2>
<h3 id="类-19"><a class="header" href="#类-19">类</a></h3>
<div class="table-wrapper"><table><thead><tr><th>类名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="logger/./logger_package_api/logger_package_classes.html#class-jsonlogger">JsonLogger</a></td><td>输出 <code>JSON</code> 格式的 <a href="logger/../log/log_package_api/log_package_classes.html#class-logger">Logger</a> 类实现。</td></tr>
<tr><td><a href="logger/./logger_package_api/logger_package_classes.html#class-simplelogger">SimpleLogger</a></td><td>输出传统文本格式的 <a href="logger/../log/log_package_api/log_package_classes.html#class-logger">Logger</a> 类实现。</td></tr>
<tr><td><a href="logger/./logger_package_api/logger_package_classes.html#class-textlogger">TextLogger</a></td><td>输出文本 <code>KV</code> 格式的 <a href="logger/../log/log_package_api/log_package_classes.html#class-logger">Logger</a> 类实现。</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="类-20"><a class="header" href="#类-20">类</a></h1>
<h2 id="class-jsonlogger"><a class="header" href="#class-jsonlogger">class JsonLogger</a></h2>
<pre><code class="language-cangjie">public class JsonLogger &lt;: Logger {
    public init(output: OutputStream)
}
</code></pre>
<p>功能：此类实现了输出 <code>JSON</code> 格式的日志打印功能，形如 <code>{&quot;time&quot;:&quot;2024-07-27T11:51:59+08:00&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;msg&quot;:&quot;foo&quot;,&quot;name&quot;:&quot;bar&quot;}</code>。</p>
<p>父类型：</p>
<ul>
<li><a href="logger/logger_package_api/../../log/log_package_api/log_package_classes.html#class-logger">Logger</a></li>
</ul>
<h3 id="initoutputstream-1"><a class="header" href="#initoutputstream-1">init(OutputStream)</a></h3>
<pre><code class="language-cangjie">public init(output: OutputStream)
</code></pre>
<p>功能：创建 <a href="logger/logger_package_api/logger_package_classes.html#class-jsonlogger">JsonLogger</a> 对象。</p>
<p>参数：</p>
<ul>
<li>output: OutputStream - 绑定的输出流，日志格式化后将写入该输出流。</li>
</ul>
<h3 id="prop-level-3"><a class="header" href="#prop-level-3">prop level</a></h3>
<pre><code class="language-cangjie">public mut prop level: LogLevel
</code></pre>
<p>功能：获取和修改日志打印级别。</p>
<p>类型：<a href="logger/logger_package_api/../../log/log_package_api/log_package_structs.html#struct-loglevel">LogLevel</a></p>
<h3 id="func-close-5"><a class="header" href="#func-close-5">func close()</a></h3>
<pre><code class="language-cangjie">public func close(): Unit
</code></pre>
<p>功能：关闭 Logger。</p>
<h3 id="func-isclosed-1"><a class="header" href="#func-isclosed-1">func isClosed()</a></h3>
<pre><code class="language-cangjie">public func isClosed(): Bool
</code></pre>
<p>功能：判断当前 Logger 是否关闭。</p>
<p>返回值：</p>
<ul>
<li>Bool - 是否关闭。</li>
</ul>
<h3 id="func-loglogrecord-2"><a class="header" href="#func-loglogrecord-2">func log(LogRecord)</a></h3>
<pre><code class="language-cangjie">public func log(record: LogRecord): Unit
</code></pre>
<p>功能：打印日志的通用函数。</p>
<p>参数：</p>
<ul>
<li>record: <a href="logger/logger_package_api/../../log/log_package_api/log_package_classes.html#class-logrecord">LogRecord</a> - 日志级别。</li>
</ul>
<h3 id="func-withattrsarrayattr-2"><a class="header" href="#func-withattrsarrayattr-2">func withAttrs(Array&lt;Attr&gt;)</a></h3>
<pre><code class="language-cangjie">public func withAttrs(attrs: Array&lt;Attr&gt;): Logger
</code></pre>
<p>功能：创建当前对象的副本，新的副本会包含指定的属性。</p>
<p>参数：</p>
<ul>
<li>attrs: Array&lt;<a href="logger/logger_package_api/../../log/log_package_api/log_package_types.html#type-attr">Attr</a>&gt; - 日志数据键值对属性。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="logger/logger_package_api/../../log/log_package_api/#class-logger">Logger</a> - <a href="logger/logger_package_api/../../log/log_package_api/#class-logger">Logger</a> 类的对象实例。</li>
</ul>
<h2 id="class-simplelogger"><a class="header" href="#class-simplelogger">class SimpleLogger</a></h2>
<pre><code class="language-cangjie">public class SimpleLogger &lt;: Logger {
    public init(output: OutputStream)
}
</code></pre>
<p>功能：此类实现了输出文本格式的日志打印功能，形如 <code>2024-07-27T11:50:47.6616733+08:00 INFO foo  name=&quot;bar&quot;</code>。</p>
<p>父类型：</p>
<ul>
<li><a href="logger/logger_package_api/../../log/log_package_api/log_package_classes.html#class-logger">Logger</a></li>
</ul>
<h3 id="initoutputstream-2"><a class="header" href="#initoutputstream-2">init(OutputStream)</a></h3>
<pre><code class="language-cangjie">public init(output: OutputStream)
</code></pre>
<p>功能：创建 <a href="logger/logger_package_api/logger_package_classes.html#class-simplelogger">SimpleLogger</a> 对象。</p>
<p>参数：</p>
<ul>
<li>output: OutputStream - 绑定的输出流，日志格式化后将写入该输出流。</li>
</ul>
<h3 id="prop-level-4"><a class="header" href="#prop-level-4">prop level</a></h3>
<pre><code class="language-cangjie">public mut prop level: LogLevel
</code></pre>
<p>功能：获取和修改日志打印级别。</p>
<p>类型：<a href="logger/logger_package_api/../../log/log_package_api/log_package_structs.html#struct-loglevel">LogLevel</a></p>
<h3 id="func-close-6"><a class="header" href="#func-close-6">func close()</a></h3>
<pre><code class="language-cangjie">public func close(): Unit
</code></pre>
<p>功能：关闭 Logger。</p>
<h3 id="func-isclosed-2"><a class="header" href="#func-isclosed-2">func isClosed()</a></h3>
<pre><code class="language-cangjie">public func isClosed(): Bool
</code></pre>
<p>功能：判断当前 Logger 是否关闭。</p>
<p>返回值：</p>
<ul>
<li>Bool - 是否关闭。</li>
</ul>
<h3 id="func-loglogrecord-3"><a class="header" href="#func-loglogrecord-3">func log(LogRecord)</a></h3>
<pre><code class="language-cangjie">public func log(record: LogRecord): Unit
</code></pre>
<p>功能：打印日志的通用函数。</p>
<p>参数：</p>
<ul>
<li>record: <a href="logger/logger_package_api/../../log/log_package_api/log_package_classes.html#class-logrecord">LogRecord</a> - 日志级别。</li>
</ul>
<h3 id="func-withattrsarrayattr-3"><a class="header" href="#func-withattrsarrayattr-3">func withAttrs(Array&lt;Attr&gt;)</a></h3>
<pre><code class="language-cangjie">public func withAttrs(attrs: Array&lt;Attr&gt;): Logger
</code></pre>
<p>功能：创建当前对象的副本，新的副本会包含指定的属性。</p>
<p>参数：</p>
<ul>
<li>attrs: Array&lt;<a href="logger/logger_package_api/../../log/log_package_api/log_package_types.html#type-attr">Attr</a>&gt; - 日志数据键值对属性。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="logger/logger_package_api/../../log/log_package_api/#class-logger">Logger</a> - <a href="logger/logger_package_api/../../log/log_package_api/#class-logger">Logger</a> 类的对象实例。</li>
</ul>
<h2 id="class-textlogger"><a class="header" href="#class-textlogger">class TextLogger</a></h2>
<pre><code class="language-cangjie">public class TextLogger &lt;: Logger {
    public init(output: OutputStream)
}
</code></pre>
<p>功能：此类实现了输出文本格式的日志打印功能，形如 <code>time=2024-07-27T11:52:40.3226881+08:00 level=&quot;INFO&quot; msg=&quot;foo&quot; name=&quot;bar&quot;</code>。</p>
<p>父类型：</p>
<ul>
<li><a href="logger/logger_package_api/../../log/log_package_api/log_package_classes.html#class-logger">Logger</a></li>
</ul>
<h3 id="initoutputstream-3"><a class="header" href="#initoutputstream-3">init(OutputStream)</a></h3>
<pre><code class="language-cangjie">public init(output: OutputStream)
</code></pre>
<p>功能：创建 <a href="logger/logger_package_api/logger_package_classes.html#class-textlogger">TextLogger</a> 对象。</p>
<p>参数：</p>
<ul>
<li>output: OutputStream - 绑定的输出流，日志格式化后将写入该输出流。</li>
</ul>
<h3 id="prop-level-5"><a class="header" href="#prop-level-5">prop level</a></h3>
<pre><code class="language-cangjie">public mut prop level: LogLevel
</code></pre>
<p>功能：获取和修改日志打印级别。</p>
<p>类型：<a href="logger/logger_package_api/../../log/log_package_api/log_package_structs.html#struct-loglevel">LogLevel</a></p>
<h3 id="func-close-7"><a class="header" href="#func-close-7">func close()</a></h3>
<pre><code class="language-cangjie">public func close(): Unit
</code></pre>
<p>功能：关闭 Logger。</p>
<h3 id="func-isclosed-3"><a class="header" href="#func-isclosed-3">func isClosed()</a></h3>
<pre><code class="language-cangjie">public func isClosed(): Bool
</code></pre>
<p>功能：判断当前 Logger 是否关闭。</p>
<p>返回值：</p>
<ul>
<li>Bool - 是否关闭。</li>
</ul>
<h3 id="func-loglogrecord-4"><a class="header" href="#func-loglogrecord-4">func log(LogRecord)</a></h3>
<pre><code class="language-cangjie">public func log(record: LogRecord): Unit
</code></pre>
<p>功能：打印日志的通用函数。</p>
<p>参数：</p>
<ul>
<li>record: <a href="logger/logger_package_api/../../log/log_package_api/log_package_classes.html#class-logrecord">LogRecord</a> - 日志级别。</li>
</ul>
<h3 id="func-withattrsarrayattr-4"><a class="header" href="#func-withattrsarrayattr-4">func withAttrs(Array&lt;Attr&gt;)</a></h3>
<pre><code class="language-cangjie">public func withAttrs(attrs: Array&lt;Attr&gt;): Logger
</code></pre>
<p>功能：创建当前对象的副本，新的副本会包含指定的属性。</p>
<p>参数：</p>
<ul>
<li>attrs: Array&lt;<a href="logger/logger_package_api/../../log/log_package_api/log_package_types.html#type-attr">Attr</a>&gt; - 日志数据键值对属性。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="logger/logger_package_api/../../log/log_package_api/#class-logger">Logger</a> - <a href="logger/logger_package_api/../../log/log_package_api/#class-logger">Logger</a> 类的对象实例。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="日志打印示例-1"><a class="header" href="#日志打印示例-1">日志打印示例</a></h1>
<p>下面是使用 <a href="logger/logger_samples/../logger_package_api/logger_package_classes.html#class-jsonlogger">JsonLogger</a> 日志打印示例代码：</p>
<!-- compile -->
<pre><code class="language-cangjie">import std.time.*
import std.io.{OutputStream, ByteBuffer, BufferedOutputStream}
import std.env.*
import std.fs.*
import std.collection.{HashMap, ArrayList}
import stdx.encoding.json.stream.*
import stdx.log.*
import stdx.logger.*

main() {
    let o = ByteBuffer()
    let bo = BufferedOutputStream&lt;OutputStream&gt;(getStdOut())
    let tl = JsonLogger(bo)
    tl.level = LogLevel.TRACE
    setGlobalLogger(tl)
    let logger = getGlobalLogger([(&quot;name&quot;, &quot;main&quot;)])
    let futs = ArrayList&lt;Future&lt;Unit&gt;&gt;()

    for (_ in 0..1) {
        let f = spawn {
            =&gt;
            logger.info(&quot;abc&quot;, (&quot;age&quot;, 2))
            let user = User()
            // 记录诊断日志，如果 DEBUG 级别未开启，直接返回，几乎无cost
            logger.debug(&quot;Logging in user ${user.name} with birthday ${user.birthdayCalendar}&quot;)
            // 普通记录信息日志
            logger.info(&quot;Hello, World!&quot;, (&quot;k1&quot;, [[1, 4], [2, 5], [3]]), (&quot;password&quot;, &quot;v22222&quot;))

            // lazy 方式记录耗时日志数据
            logger.log(LogLevel.ERROR, &quot;long-running operation msg&quot;, (&quot;k1&quot;, 100), (&quot;k2&quot;, user.birthdayCalendar),
                (&quot;oper&quot;, ToStringWrapper({=&gt; &quot;Some long-running operation returned&quot;})))

            logger.log(LogLevel.ERROR, &quot;long-running operation msg&quot;, (&quot;sourcePackage&quot;, @sourcePackage()),
                (&quot;sourceFile&quot;, @sourceFile()), (&quot;sourceLine&quot;, @sourceLine()), (&quot;birthdayCalendar&quot;, user.birthdayCalendar),
                (&quot;oper&quot;, ToStringWrapper({=&gt; &quot;Some long-running operation returned&quot;})))

            let m = HashMap&lt;String, String&gt;()
            m.add(&quot;k1&quot;, &quot;1\n&quot;)
            m.add(&quot;k2&quot;, &quot;2&quot;)
            m.add(&quot;k3&quot;, &quot;3&quot;)
            logger.trace({=&gt; &quot;Some long-running operation returned&quot;}, (&quot;m1&quot;, m))
            let m2 = HashMap&lt;String, LogValue&gt;()
            m2.add(&quot;g1&quot;, m)
            m2.add(&quot;k1&quot;, [[&quot;1&quot;, &quot;4 s&quot;], [&quot;2&quot;, &quot;5&quot;], [&quot;3&quot;]])

            // 如果TRACE 级别没有开启，那么lambda表达式不会被执行
            logger.trace({=&gt; &quot;Some long-running operation returned&quot;}, (&quot;m2&quot;, m2))
        }
        futs.add(f)
    }

    for (f in futs) {
        f.get()
    }

    logger.close()
}

public class User {
    public prop name: String {
        get() {
            &quot;foo&quot;
        }
    }
    public prop birthdayCalendar: DateTime {
        get() {
            DateTime.now()
        }
    }
}

public class ToStringWrapper &lt;: ToString &amp; LogValue {
    let _fn: () -&gt; String
    public init(fn: () -&gt; String) {
        _fn = fn
    }
    public func toString(): String {
        return _fn()
    }
    public func writeTo(w: LogWriter): Unit {
        w.writeValue(_fn())
    }
}

func expensiveOperation(): String {
    for (_ in 0..1000000) {
        unsafe {
            let b = LibC.malloc&lt;Byte&gt;(count: 1000)
            LibC.free(b)
        }
    }
    &quot;Some long-running operation returned&quot;
}

</code></pre>
<p>运行结果如下：</p>
<pre><code class="language-text">{&quot;time&quot;:&quot;2024-07-18T07:57:45Z&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;msg&quot;:&quot;abc&quot;,&quot;name&quot;:&quot;main&quot;,&quot;age&quot;:2}
{&quot;time&quot;:&quot;2024-07-18T07:57:45Z&quot;,&quot;level&quot;:&quot;DEBUG&quot;,&quot;msg&quot;:&quot;Logging in user foo with birthday 2024-07-18T07:57:45.9912185Z&quot;,&quot;name&quot;:&quot;main&quot;}
{&quot;time&quot;:&quot;2024-07-18T07:57:45Z&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;msg&quot;:&quot;Hello, World!&quot;,&quot;name&quot;:&quot;main&quot;,&quot;k1&quot;:[[1,4],[2,5],[3]],&quot;password&quot;:&quot;v22222&quot;}
{&quot;time&quot;:&quot;2024-07-18T07:57:45Z&quot;,&quot;level&quot;:&quot;ERROR&quot;,&quot;msg&quot;:&quot;long-running operation msg&quot;,&quot;name&quot;:&quot;main&quot;,&quot;k1&quot;:100,&quot;k2&quot;:&quot;2024-07-18T07:57:45Z&quot;,&quot;oper&quot;:&quot;Some long-running operation returned&quot;}
{&quot;time&quot;:&quot;2024-07-18T07:57:45Z&quot;,&quot;level&quot;:&quot;ERROR&quot;,&quot;msg&quot;:&quot;long-running operation msg&quot;,&quot;name&quot;:&quot;main&quot;,&quot;sourcePackage&quot;:&quot;mylog&quot;,&quot;sourceFile&quot;:&quot;main.cj&quot;,&quot;sourceLine&quot;:52,&quot;birthdayCalendar&quot;:&quot;2024-07-18T07:57:45Z&quot;,&quot;oper&quot;:&quot;Some long-running operation returned&quot;}
{&quot;time&quot;:&quot;2024-07-18T07:57:45Z&quot;,&quot;level&quot;:&quot;TRACE&quot;,&quot;msg&quot;:&quot;Some long-running operation returned&quot;,&quot;name&quot;:&quot;main&quot;,&quot;m1&quot;:{&quot;k1&quot;:&quot;1\n&quot;,&quot;k2&quot;:&quot;2&quot;,&quot;k3&quot;:&quot;3&quot;}}
{&quot;time&quot;:&quot;2024-07-18T07:57:45Z&quot;,&quot;level&quot;:&quot;TRACE&quot;,&quot;msg&quot;:&quot;Some long-running operation returned&quot;,&quot;name&quot;:&quot;main&quot;,&quot;m2&quot;:{&quot;g1&quot;:{&quot;k1&quot;:&quot;1\n&quot;,&quot;k2&quot;:&quot;2&quot;,&quot;k3&quot;:&quot;3&quot;},&quot;k1&quot;:[[&quot;1&quot;,&quot;4 s&quot;],[&quot;2&quot;,&quot;5&quot;],[&quot;3&quot;]]}}
</code></pre>
<p>下面是使用 <a href="logger/logger_samples/../logger_package_api/logger_package_classes.html#class-simplelogger">SimpleLogger</a> 日志打印示例代码：</p>
<!-- run -->
<pre><code class="language-cangjie">import std.time.*
import std.io.{OutputStream, ByteBuffer, BufferedOutputStream}
import std.env.*
import std.fs.*
import std.collection.{HashMap, ArrayList}
import stdx.log.*
import stdx.logger.*

main() {
    let o = ByteBuffer()
    let bo = BufferedOutputStream&lt;OutputStream&gt;(getStdOut())
    let tl = SimpleLogger(bo)
    tl.level = LogLevel.TRACE
    setGlobalLogger(tl)
    let logger = getGlobalLogger([(&quot;name&quot;, &quot;main&quot;)])
    let futs = ArrayList&lt;Future&lt;Unit&gt;&gt;()

    // let f = File(&quot;log/a.log&quot;, Append)
    // let h = TextHandler(f)
    for (_ in 0..1) {
        let f = spawn {
            =&gt;
            logger.info(&quot;abc&quot;, (&quot;age&quot;, 2))
            let user = User()
            // 记录诊断日志，如果 DEBUG 级别未开启，直接返回，几乎无cost
            logger.debug(&quot;Logging in user ${user.name} with birthday ${user.birthdayCalendar}&quot;)
            // 普通记录信息日志
            logger.info(&quot;Hello, World!&quot;, (&quot;k1&quot;, [[1, 4], [2, 5], [3]]), (&quot;password&quot;, &quot;v22222&quot;))

            // lazy 方式记录耗时日志数据
            logger.log(LogLevel.ERROR, &quot;long-running operation msg&quot;, (&quot;k1&quot;, 100), (&quot;k2&quot;, user.birthdayCalendar),
                (&quot;oper&quot;, ToStringWrapper({=&gt; &quot;Some long-running operation returned&quot;})))

            logger.log(LogLevel.ERROR, &quot;long-running operation msg&quot;, (&quot;sourcePackage&quot;, @sourcePackage()),
                (&quot;sourceFile&quot;, @sourceFile()), (&quot;sourceLine&quot;, @sourceLine()), (&quot;birthdayCalendar&quot;, user.birthdayCalendar),
                (&quot;oper&quot;, ToStringWrapper({=&gt; &quot;Some long-running operation returned&quot;})))

            let m = HashMap&lt;String, String&gt;()
            m.add(&quot;k1&quot;, &quot;1\n&quot;)
            m.add(&quot;k2&quot;, &quot;2&quot;)
            m.add(&quot;k3&quot;, &quot;3&quot;)
            logger.trace({=&gt; &quot;Some long-running operation returned&quot;}, (&quot;m1&quot;, m))
            let m2 = HashMap&lt;String, LogValue&gt;()
            m2.add(&quot;g1&quot;, m)
            m2.add(&quot;k1&quot;, [[&quot;1&quot;, &quot;4 s&quot;], [&quot;2&quot;, &quot;5&quot;], [&quot;3&quot;]])

            // 如果TRACE 级别没有开启，那么lambda表达式不会被执行
            logger.trace({=&gt; &quot;Some long-running operation returned&quot;}, (&quot;m2&quot;, m2))
        }
        futs.add(f)
    }

    for (f in futs) {
        f.get()
    }

    logger.close()
}

public class User {
    public prop name: String {
        get() {
            &quot;foo&quot;
        }
    }
    public prop birthdayCalendar: DateTime {
        get() {
            DateTime.now()
        }
    }
}

public class ToStringWrapper &lt;: ToString &amp; LogValue {
    let _fn: () -&gt; String
    public init(fn: () -&gt; String) {
        _fn = fn
    }
    public func toString(): String {
        return _fn()
    }
    public func writeTo(w: LogWriter): Unit {
        w.writeValue(_fn())
    }
}

func expensiveOperation(): String {
    for (_ in 0..1000000) {
        unsafe {
            let b = LibC.malloc&lt;Byte&gt;(count: 1000)
            LibC.free(b)
        }
    }
    &quot;Some long-running operation returned&quot;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code class="language-text">2025-04-15T15:06:54.7371418+08:00 INFO abc name=&quot;main&quot; age=2
2025-04-15T15:06:54.737251+08:00 DEBUG Logging in user foo with birthday 2025-04-15T15:06:54.7372416+08:00 name=&quot;main&quot;
2025-04-15T15:06:54.7376041+08:00 INFO Hello, World! name=&quot;main&quot; k1=[[1,4],[2,5],[3]] password=&quot;v22222&quot;
2025-04-15T15:06:54.7379054+08:00 ERROR long-running operation msg name=&quot;main&quot; k1=100 k2=2025-04-15T15:06:54.7379047+08:00 oper=&quot;Some long-running operation returned&quot;
2025-04-15T15:06:54.7381296+08:00 ERROR long-running operation msg name=&quot;main&quot; sourcePackage=&quot;mylog&quot; sourceFile=&quot;main.cj&quot; sourceLine=37 birthdayCalendar=2025-04-15T15:06:54.7381291+08:00 oper=&quot;Some long-running operation returned&quot;
2025-04-15T15:06:54.7385818+08:00 TRACE Some long-running operation returned name=&quot;main&quot; m1={k1:&quot;1\n&quot;,k2:&quot;2&quot;,k3:&quot;3&quot;}
2025-04-15T15:06:54.7387716+08:00 TRACE Some long-running operation returned name=&quot;main&quot; m2={g1:{k1:&quot;1\n&quot;,k2:&quot;2&quot;,k3:&quot;3&quot;},k1:[[&quot;1&quot;,&quot;4 s&quot;],[&quot;2&quot;,&quot;5&quot;],[&quot;3&quot;]]}
</code></pre>
<p>下面是使用 <a href="logger/logger_samples/../logger_package_api/logger_package_classes.html#class-textlogger">TextLogger</a> 日志打印示例代码：</p>
<!-- compile -->
<pre><code class="language-cangjie">import std.time.*
import std.io.{OutputStream, ByteBuffer, BufferedOutputStream}
import std.env.*
import std.fs.*
import std.collection.{HashMap, ArrayList}
import stdx.log.*
import stdx.logger.*

main() {
    let o = ByteBuffer()
    let bo = BufferedOutputStream&lt;OutputStream&gt;(getStdOut())
    let tl = TextLogger(bo)
    tl.level = LogLevel.TRACE
    setGlobalLogger(tl)
    let logger = getGlobalLogger([(&quot;name&quot;, &quot;main&quot;)])
    let futs = ArrayList&lt;Future&lt;Unit&gt;&gt;()

    // let f = File(&quot;log/a.log&quot;, Append)
    // let h = TextHandler(f)
    for (_ in 0..1) {
        let f = spawn {
            =&gt;
            logger.info(&quot;abc&quot;, (&quot;age&quot;, 2))
            let user = User()
            // 记录诊断日志，如果 DEBUG 级别未开启，直接返回，几乎无cost
            logger.debug(&quot;Logging in user ${user.name} with birthday ${user.birthdayCalendar}&quot;)
            // 普通记录信息日志
            logger.info(&quot;Hello, World!&quot;, (&quot;k1&quot;, [[1, 4], [2, 5], [3]]), (&quot;password&quot;, &quot;v22222&quot;))

            // lazy 方式记录耗时日志数据
            logger.log(LogLevel.ERROR, &quot;long-running operation msg&quot;, (&quot;k1&quot;, 100), (&quot;k2&quot;, user.birthdayCalendar),
                (&quot;oper&quot;, ToStringWrapper({=&gt; &quot;Some long-running operation returned&quot;})))

            logger.log(LogLevel.ERROR, &quot;long-running operation msg&quot;, (&quot;sourcePackage&quot;, @sourcePackage()),
                (&quot;sourceFile&quot;, @sourceFile()), (&quot;sourceLine&quot;, @sourceLine()), (&quot;birthdayCalendar&quot;, user.birthdayCalendar),
                (&quot;oper&quot;, ToStringWrapper({=&gt; &quot;Some long-running operation returned&quot;})))

            let m = HashMap&lt;String, String&gt;()
            m.add(&quot;k1&quot;, &quot;1\n&quot;)
            m.add(&quot;k2&quot;, &quot;2&quot;)
            m.add(&quot;k3&quot;, &quot;3&quot;)
            logger.trace({=&gt; &quot;Some long-running operation returned&quot;}, (&quot;m1&quot;, m))
            let m2 = HashMap&lt;String, LogValue&gt;()
            m2.add(&quot;g1&quot;, m)
            m2.add(&quot;k1&quot;, [[&quot;1&quot;, &quot;4 s&quot;], [&quot;2&quot;, &quot;5&quot;], [&quot;3&quot;]])

            // 如果TRACE 级别没有开启，那么lambda表达式不会被执行
            logger.trace({=&gt; &quot;Some long-running operation returned&quot;}, (&quot;m2&quot;, m2))
        }
        futs.add(f)
    }

    for (f in futs) {
        f.get()
    }

    logger.close()
}

public class User {
    public prop name: String {
        get() {
            &quot;foo&quot;
        }
    }
    public prop birthdayCalendar: DateTime {
        get() {
            DateTime.now()
        }
    }
}

public class ToStringWrapper &lt;: ToString &amp; LogValue {
    let _fn: () -&gt; String
    public init(fn: () -&gt; String) {
        _fn = fn
    }
    public func toString(): String {
        return _fn()
    }
    public func writeTo(w: LogWriter): Unit {
        w.writeValue(_fn())
    }
}

func expensiveOperation(): String {
    for (_ in 0..1000000) {
        unsafe {
            let b = LibC.malloc&lt;Byte&gt;(count: 1000)
            LibC.free(b)
        }
    }
    &quot;Some long-running operation returned&quot;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code class="language-text">time=2025-04-15T15:18:09.2186361+08:00 level=&quot;INFO&quot; msg=&quot;abc&quot; name=&quot;main&quot; age=2
time=2025-04-15T15:18:09.2187444+08:00 level=&quot;DEBUG&quot; msg=&quot;Logging in user foo with birthday 2025-04-15T15:18:09.2187408+08:00&quot; name=&quot;main&quot;
time=2025-04-15T15:18:09.2191009+08:00 level=&quot;INFO&quot; msg=&quot;Hello, World!&quot; name=&quot;main&quot; k1=[[1,4],[2,5],[3]] password=&quot;v22222&quot;
time=2025-04-15T15:18:09.2193242+08:00 level=&quot;ERROR&quot; msg=&quot;long-running operation msg&quot; name=&quot;main&quot; k1=100 k2=2025-04-15T15:18:09.2193236+08:00 oper=&quot;Some long-running operation returned&quot;    
time=2025-04-15T15:18:09.2194668+08:00 level=&quot;ERROR&quot; msg=&quot;long-running operation msg&quot; name=&quot;main&quot; sourcePackage=&quot;mylog&quot; sourceFile=&quot;main.cj&quot; sourceLine=37 birthdayCalendar=2025-04-15T15:18:09.2194663+08:00 oper=&quot;Some long-running operation returned&quot;
time=2025-04-15T15:18:09.2197682+08:00 level=&quot;TRACE&quot; msg=&quot;Some long-running operation returned&quot; name=&quot;main&quot; m1={k1:&quot;1\n&quot;,k2:&quot;2&quot;,k3:&quot;3&quot;}
time=2025-04-15T15:18:09.2200024+08:00 level=&quot;TRACE&quot; msg=&quot;Some long-running operation returned&quot; name=&quot;main&quot; m2={g1:{k1:&quot;1\n&quot;,k2:&quot;2&quot;,k3:&quot;3&quot;},k1:[[&quot;1&quot;,&quot;4 s&quot;],[&quot;2&quot;,&quot;5&quot;],[&quot;3&quot;]]}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdxnethttp"><a class="header" href="#stdxnethttp">stdx.net.http</a></h1>
<h2 id="功能介绍-13"><a class="header" href="#功能介绍-13">功能介绍</a></h2>
<p>http 包提供 HTTP/1.1、HTTP/2 和 WebSocket 协议的 server、client 端实现。</p>
<p>关于协议的详细内容可参考 <a href="https://httpwg.org/specs/rfc9110.html">RFC 9110</a>、<a href="https://httpwg.org/specs/rfc9112.html">9112</a>、<a href="https://httpwg.org/specs/rfc9113.html">9113</a>、<a href="https://httpwg.org/specs/rfc9218.html">9218</a>、<a href="https://httpwg.org/specs/rfc7541.html">7541</a> 等。</p>
<p>使用本包需要外部依赖 <code>OpenSSL 3</code> 的 <code>ssl</code> 和 <code>crypto</code> 动态库文件，故使用前需安装相关工具：</p>
<ul>
<li>对于 <code>Linux</code> 操作系统，可参考以下方式：
<ul>
<li>如果系统的包管理工具支持安装 <code>OpenSSL 3</code> 开发工具包，可通过这个方式安装，并确保系统安装目录下含有 <code>libssl.so</code>、<code>libssl.so.3</code>、<code>libcrypto.so</code> 和 <code>libcrypto.so.3</code> 这些动态库文件，例如 <code>Ubuntu 22.04</code> 系统上可使用 <code>sudo apt install libssl-dev</code> 命令安装 <code>libssl-dev</code> 工具包；</li>
<li>如果无法通过上面的方式安装，可自行下载 <code>OpenSSL 3.x.x</code> 源码编译安装软件包，并确保安装目录下含有 <code>libssl.so</code>、<code>libssl.so.3</code>、<code>libcrypto.so</code> 和 <code>libcrypto.so.3</code> 这些动态库文件，然后可选择下面任意一种方式来保证系统链接器可以找到这些文件:
<ul>
<li>在系统未安装 OpenSSL 的场景，安装时选择直接安装到系统路径下；</li>
<li>安装在自定义目录的场景，将这些文件所在目录设置到环境变量 <code>LD_LIBRARY_PATH</code> 以及 <code>LIBRARY_PATH</code> 中。</li>
</ul>
</li>
</ul>
</li>
<li>对于 <code>Windows</code> 操作系统，可按照以下步骤：
<ul>
<li>自行下载 <code>OpenSSL 3.x.x</code> 源码编译安装 x64 架构软件包或者自行下载安装第三方预编译的供开发人员使用的 <code>OpenSSL 3.x.x</code> 软件包；</li>
<li>确保安装目录下含有 <code>libssl.dll.a</code>（或 <code>libssl.lib</code>）、<code>libssl-3-x64.dll</code>、<code>libcrypto.dll.a</code>（或 <code>libcrypto.lib</code>）、<code>libcrypto-3-x64.dll</code> 这些库文件；</li>
<li>将 <code>libssl.dll.a</code>（或 <code>libssl.lib</code>）、<code>libcrypto.dll.a</code>（或 <code>libcrypto.lib</code>）所在的目录路径设置到环境变量 <code>LIBRARY_PATH</code> 中，将 <code>libssl-3-x64.dll</code>、<code>libcrypto-3-x64.dll</code> 所在的目录路径设置到环境变量 <code>PATH</code> 中。</li>
</ul>
</li>
<li>对于 <code>macOS</code> 操作系统，可参考以下方式：
<ul>
<li>使用 <code>brew install openssl@3</code> 安装，并确保系统安装目录下含有 <code>libcrypto.dylib</code> 和 <code>libcrypto.3.dylib</code> 这两个动态库文件；</li>
<li>如果无法通过上面的方式安装，可自行下载 <code>OpenSSL 3.x.x</code> 源码编译安装软件包，并确保安装目录下含有 <code>libcrypto.dylib</code> 和 <code>libcrypto.3.dylib</code> 这两个动态库文件，然后可选择下面任意一种方式来保证系统链接器可以找到这些文件:
<ul>
<li>在系统未安装 OpenSSL 的场景，安装时选择直接安装到系统路径下；</li>
<li>安装在自定义目录的场景，将这些文件所在目录设置到环境变量 <code>DYLD_LIBRARY_PATH</code> 以及 <code>LIBRARY_PATH</code> 中。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>如果未安装 <code>OpenSSL 3</code>软件包或者安装低版本的软件包，程序可能无法使用并抛出 TLS 相关异常。</p>
<h3 id="http"><a class="header" href="#http">http</a></h3>
<p>用户可以选择 http 协议的版本，如 HTTP/1.1、HTTP/2。http 包的多数 API 并不区分这两种协议版本，只有当用户用到某个版本的特有功能时，才需要做这种区分，如 HTTP/1.1 中的 chunked 的 transfer-encoding，HTTP/2 中的 server push。</p>
<p>http 库默认使用 HTTP/1.1 版本。当开发者需要使用 HTTP/2 协议时，需要为 Client/Server 配置 tls，并且设置 alpn 的值为 <code>h2</code>；不支持 HTTP/1.1 通过 <code>Upgrade: h2c</code> 协议升级的方式升级到 HTTP/2。</p>
<p>如果创建 HTTP/2 连接握手失败，Client/Server 会自动将协议退回 HTTP/1.1。</p>
<ul>
<li>
<p>用户通过 <a href="net/http/./http_package_api/http_package_classes.html#class-clientbuilder">ClientBuilder</a> 构建一个 Client 实例，构建过程可以指定多个参数，如 httpProxy、logger、cookieJar、是否自动 redirect、连接池大小等。</p>
</li>
<li>
<p>用户通过 <a href="net/http/./http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> 构建一个 Server 实例，构建过程可以指定多个参数，如 addr、port、logger、distributor 等。</p>
</li>
</ul>
<p>用户如果需要自己设置 Logger，需要保证它是线程安全的。</p>
<p>Client、Server 的大多数参数在构建后便不允许修改，如果想要更改，用户需要重新构建一个新的 Client 或 Server 实例；如果该参数支持动态修改，本实现会提供显式的功能，如 Server 端 cert、CA 的热更新。</p>
<ul>
<li>
<p>通过 Client 实例，用户可以发送 http request、接收 http response。</p>
</li>
<li>
<p>通过 Server 实例，用户可以配置 request 转发处理器，启动 http server。在 server handler 中，用户可以通过 HttpContext 获取 client 发来的 request 的详细信息，构造发送给 client 的 response。
Server 端根据 Client 端请求，创建对应的 ProtocolService 实例，同一个 Server 实例可同时支持两种协议：HTTP/1.1、HTTP/2。</p>
</li>
<li>
<p>在 client 端，用户通过 HttpRequestBuilder 构造 request，构建过程可以指定多个参数，如 method、url、version、headers、body、trailers 等等；构建之后的request 不允许再进行修改。</p>
</li>
<li>
<p>在 server 端，用户通过 HttpResponseBuilder 构造 response，构建过程可以指定多个参数，如 status、headers、body、trailers 等等；构建之后的 response 不允许再进行修改。</p>
</li>
</ul>
<p>另外，本实现提供一些工具类，方便用户构造一些常用 response，如 RedirectHandler 构造 redirect response，NotFoundHandler 构造 404 response。</p>
<h3 id="websocket"><a class="header" href="#websocket">WebSocket</a></h3>
<p>本实现为 WebSocket 提供 sub-protocol 协商，包括基础的 frame 解码、读取、消息发送、frame 编码、ping、pong、关闭等功能。</p>
<p>用户通过 WebSocket.upgradeFromClient 从一个 HTTP/1.1 或 HTTP/2 Client 实例升级到 WebSocket 协议，之后通过返回的 WebSocket 实例进行 WebSocket 通讯。</p>
<p>用户在一个 server 端的 handler 中，通过 WebSocket.upgradeFromServer 从 HTTP/1.1 或 HTTP/2 协议升级到 WebSocket 协议，之后通过返回的 WebSocket 实例进行 WebSocket 通讯。</p>
<p>按照协议，HTTP/1.1 中，升级后的 WebSocket 连接是建立在 tcp/tls 连接之上；HTTP/2 中，升级后的 WebSocket 连接是建立在 HTTP/2 connection 的一个 stream 之上。HTTP/1.1 中，close 最终会直接关闭 tcp/tls 连接；HTTP/2 中，close 只会关闭 connection 上的一个 stream。</p>
<h2 id="api-列表-13"><a class="header" href="#api-列表-13">API 列表</a></h2>
<h3 id="函数-6"><a class="header" href="#函数-6">函数</a></h3>
<div class="table-wrapper"><table><thead><tr><th>函数名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="net/http/./http_package_api/http_package_funcs.html#func-handleerrorhttpcontext-uint16">handleError(HttpContext, UInt16)</a></td><td>便捷的 Http 请求处理函数，用于回复错误请求。</td></tr>
<tr><td><a href="net/http/./http_package_api/http_package_funcs.html#func-notfoundhttpcontext">notFound(HttpContext)</a></td><td>便捷的 Http 请求处理函数，用于回复 404 响应。</td></tr>
<tr><td><a href="net/http/./http_package_api/http_package_funcs.html#func-upgradehttpcontext">upgrade(HttpContext)</a></td><td>在 handler 内获取 StreamingSocket，可用于支持协议升级和处理 CONNECT 请求。</td></tr>
</tbody></table>
</div>
<h3 id="接口-8"><a class="header" href="#接口-8">接口</a></h3>
<div class="table-wrapper"><table><thead><tr><th>接口名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="net/http/./http_package_api/http_package_interfaces.html#interface-cookiejar">CookieJar</a></td><td>Client 用来管理 Cookie 的工具。</td></tr>
<tr><td><a href="net/http/./http_package_api/http_package_interfaces.html#interface-httprequestdistributor">HttpRequestDistributor</a></td><td>Http request 分发器接口，将一个 request 按照 url 中的 path 分发给对应的 HttpRequestHandler 处理。</td></tr>
<tr><td><a href="net/http/./http_package_api/http_package_interfaces.html#interface-httprequesthandler">HttpRequestHandler</a></td><td>Http request 处理器。</td></tr>
<tr><td><a href="net/http/./http_package_api/http_package_interfaces.html#interface-protocolservicefactory">ProtocolServiceFactory</a></td><td>Http 服务实例工厂，用于生成 <code>ProtocolService</code> 实例。</td></tr>
</tbody></table>
</div>
<h3 id="类-21"><a class="header" href="#类-21">类</a></h3>
<div class="table-wrapper"><table><thead><tr><th>类名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="net/http/./http_package_api/http_package_classes.html#class-client">Client</a></td><td>Client 类，用户可以通过 Client 实例发送 HTTP/1.1 或 HTTP/2 请求。</td></tr>
<tr><td><a href="net/http/./http_package_api/http_package_classes.html#class-clientbuilder">ClientBuilder</a></td><td>用于 Client 实例的构建，Client 没有公开的构造函数，用户只能通过 ClientBuilder 得到 Client 实例。ClientBuilder 文档中未明确说明支持版本的配置，在 HTTP/1.1 与 HTTP/2 都会生效。</td></tr>
<tr><td><a href="net/http/./http_package_api/http_package_classes.html#class-cookie">Cookie</a></td><td>HTTP 本身是无状态的，server 为了知道 client 的状态，提供个性化的服务，便可以通过 Cookie 来维护一个有状态的会话。</td></tr>
<tr><td><a href="net/http/./http_package_api/http_package_classes.html#class-filehandler">FileHandler</a></td><td>用于处理文件下载或者文件上传。</td></tr>
<tr><td><a href="net/http/./http_package_api/http_package_classes.html#class-funchandler">FuncHandler</a></td><td>HttpRequestHandler 接口包装类，把单个函数包装成 HttpRequestHandler。</td></tr>
<tr><td><a href="net/http/./http_package_api/http_package_classes.html#class-httpcontext">HttpContext</a></td><td>Http 请求上下文，作为 HttpRequestHandler.handle 函数的参数在服务端使用。</td></tr>
<tr><td><a href="net/http/./http_package_api/http_package_classes.html#class-httpheaders">HttpHeaders</a></td><td>用于表示 Http 报文中的 header 和 trailer，定义了相关增、删、改、查操作。</td></tr>
<tr><td><a href="net/http/./http_package_api/http_package_classes.html#class-httprequest">HttpRequest</a></td><td>Http 请求类。</td></tr>
<tr><td><a href="net/http/./http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a></td><td>HttpRequestBuilder 类用于构造 HttpRequest 实例。</td></tr>
<tr><td><a href="net/http/./http_package_api/http_package_classes.html#class-httpresponse">HttpResponse</a></td><td>Http 响应类。</td></tr>
<tr><td><a href="net/http/./http_package_api/http_package_classes.html#class-httpresponsebuilder">HttpResponseBuilder</a></td><td>用于构造 HttpResponse 实例。</td></tr>
<tr><td><a href="net/http/./http_package_api/http_package_classes.html#class-httpresponsepusher">HttpResponsePusher</a></td><td>HTTP/2 服务器推送。</td></tr>
<tr><td><a href="net/http/./http_package_api/http_package_classes.html#class-httpresponsewriter">HttpResponseWriter</a></td><td>HTTP response消息体 Writer，支持用户控制消息体的发送过程。</td></tr>
<tr><td><a href="net/http/./http_package_api/http_package_classes.html#class-notfoundhandler">NotFoundHandler</a></td><td>便捷的 Http 请求处理器，<code>404 Not Found</code> 处理器。</td></tr>
<tr><td><a href="net/http/./http_package_api/http_package_classes.html#class-optionshandler">OptionsHandler</a></td><td>便捷的 Http 处理器，用于处理 OPTIONS 请求。固定返回 &quot;Allow: OPTIONS，GET，HEAD，POST，PUT，DELETE&quot; 响应头。</td></tr>
<tr><td><a href="net/http/./http_package_api/http_package_classes.html#class-protocolservice">ProtocolService</a></td><td>Http协议服务实例，为单个客户端连接提供 Http 服务，包括对客户端 request 报文的解析、 request 的分发处理、 response 的发送等。</td></tr>
<tr><td><a href="net/http/./http_package_api/http_package_classes.html#class-redirecthandler">RedirectHandler</a></td><td>便捷的 Http 处理器，用于回复重定向响应。</td></tr>
<tr><td><a href="net/http/./http_package_api/http_package_classes.html#class-server">Server</a></td><td>提供 HTTP 服务的 Server 类。</td></tr>
<tr><td><a href="net/http/./http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a></td><td>提供 Server 实例构建器。</td></tr>
<tr><td><a href="net/http/./http_package_api/http_package_classes.html#class-websocket">WebSocket</a></td><td>提供 WebSocket 服务的相关类，提供 WebSocket 连接的读、写、关闭等函数。用户通过 upgradeFrom 函数以获取 WebSocket 连接。</td></tr>
<tr><td><a href="net/http/./http_package_api/http_package_classes.html#class-websocketframe">WebSocketFrame</a></td><td>WebSocket 用于读的基本单元。</td></tr>
</tbody></table>
</div>
<h3 id="枚举-10"><a class="header" href="#枚举-10">枚举</a></h3>
<div class="table-wrapper"><table><thead><tr><th>枚举名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="net/http/./http_package_api/http_package_enums.html#enum-filehandlertype">FileHandlerType</a></td><td>用于设置 <code>FileHandler</code> 是上传还是下载模式。</td></tr>
<tr><td><a href="net/http/./http_package_api/http_package_enums.html#enum-protocol">Protocol</a></td><td>定义 HTTP 协议类型枚举。</td></tr>
<tr><td><a href="net/http/./http_package_api/http_package_enums.html#enum-websocketframetype">WebSocketFrameType</a></td><td>定义 <code>WebSocketFrame</code> 的枚举类型。</td></tr>
</tbody></table>
</div>
<h3 id="结构体-12"><a class="header" href="#结构体-12">结构体</a></h3>
<div class="table-wrapper"><table><thead><tr><th>结构体名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="net/http/./http_package_api/http_package_structs.html#struct-httpstatuscode">HttpStatusCode</a></td><td>用来表示网页服务器超文本传输协议响应状态的 3 位数字代码。</td></tr>
<tr><td><a href="net/http/./http_package_api/http_package_structs.html#struct-servicepoolconfig">ServicePoolConfig</a></td><td>Http Server 协程池配置。</td></tr>
<tr><td><a href="net/http/./http_package_api/http_package_structs.html#struct-transportconfig">TransportConfig</a></td><td>传输层配置类，服务器建立连接使用的传输层配置。</td></tr>
</tbody></table>
</div>
<h3 id="异常类-15"><a class="header" href="#异常类-15">异常类</a></h3>
<div class="table-wrapper"><table><thead><tr><th>异常类名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="net/http/./http_package_api/http_package_exceptions.html#class-connectionexception">ConnectionException</a></td><td>Http 的tcp连接异常类。</td></tr>
<tr><td><a href="net/http/./http_package_api/http_package_exceptions.html#class-coroutinepoolrejectexception">CoroutinePoolRejectException</a></td><td>Http 的协程池拒绝请求处理异常类。</td></tr>
<tr><td><a href="net/http/./http_package_api/http_package_exceptions.html#class-httpexception">HttpException</a></td><td>Http 的通用异常类。</td></tr>
<tr><td><a href="net/http/./http_package_api/http_package_exceptions.html#class-httpstatusexception">HttpStatusException</a></td><td>Http 的响应状态异常类。</td></tr>
<tr><td><a href="net/http/./http_package_api/http_package_exceptions.html#class-httptimeoutexception">HttpTimeoutException</a></td><td>Http 的超时异常类。</td></tr>
<tr><td><a href="net/http/./http_package_api/http_package_exceptions.html#class-websocketexception">WebSocketException</a></td><td>WebSocket 的通用异常类。</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="函数-7"><a class="header" href="#函数-7">函数</a></h1>
<h2 id="func-handleerrorhttpcontext-uint16"><a class="header" href="#func-handleerrorhttpcontext-uint16">func handleError(HttpContext, UInt16)</a></h2>
<pre><code class="language-cangjie">public func handleError(ctx: HttpContext, code: UInt16): Unit
</code></pre>
<p>功能：便捷的 Http 请求处理函数，用于回复错误请求。</p>
<p>参数：</p>
<ul>
<li>ctx: <a href="net/http/http_package_api/http_package_classes.html#class-httpcontext">HttpContext</a> - Http 请求上下文。</li>
<li>code: UInt16 - Http 响应码。</li>
</ul>
<h2 id="func-notfoundhttpcontext"><a class="header" href="#func-notfoundhttpcontext">func notFound(HttpContext)</a></h2>
<pre><code class="language-cangjie">public func notFound(ctx: HttpContext): Unit
</code></pre>
<p>功能：便捷的 Http 请求处理函数，用于回复 404 响应。</p>
<p>参数：</p>
<ul>
<li>ctx: <a href="net/http/http_package_api/http_package_classes.html#class-httpcontext">HttpContext</a> - Http 请求上下文。</li>
</ul>
<h2 id="func-upgradehttpcontext"><a class="header" href="#func-upgradehttpcontext">func upgrade(HttpContext)</a></h2>
<pre><code class="language-cangjie">public func upgrade(ctx: HttpContext): StreamingSocket
</code></pre>
<p>功能：在 handler 内获取 StreamingSocket，可用于支持协议升级和处理 CONNECT 请求。</p>
<blockquote>
<ul>
<li>调用该函数时，将首先根据 ctx.responseBuilder 发送响应，仅发送状态码和响应头。</li>
<li>调用该函数时，将把 ctx.request.body 置空，后续无法通过 body.read(...) 读数据，未读完的 body 数据将留存在返回的 StreamingSocket 中。</li>
</ul>
</blockquote>
<p>参数：</p>
<ul>
<li>ctx: <a href="net/http/http_package_api/http_package_classes.html#class-httpcontext">HttpContext</a> - 请求上下文。</li>
</ul>
<p>返回值：</p>
<ul>
<li>StreamingSocket - 底层连接（对于 HTTP/2 是一个 stream），可用于后续读写。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_exceptions.html#class-httpexception">HttpException</a> - 获取底层连接（对于 HTTP/2 是一个 stream）失败。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="接口-9"><a class="header" href="#接口-9">接口</a></h1>
<h2 id="interface-cookiejar"><a class="header" href="#interface-cookiejar">interface CookieJar</a></h2>
<pre><code class="language-cangjie">public interface CookieJar {
    prop isHttp: Bool
    prop rejectPublicSuffixes: ArrayList&lt;String&gt;
    static func createDefaultCookieJar(rejectPublicSuffixes: ArrayList&lt;String&gt;, isHttp: Bool): CookieJar
    static func parseSetCookieHeader(response: HttpResponse): ArrayList&lt;Cookie&gt;
    static func toCookieString(cookies: ArrayList&lt;Cookie&gt;): String
    func clear(): Unit
    func getCookies(url: URL): ArrayList&lt;Cookie&gt;
    func removeCookies(domain: String): Unit
    func storeCookies(url: URL, cookies: ArrayList&lt;Cookie&gt;): Unit
}
</code></pre>
<p>功能：<a href="net/http/http_package_api/http_package_interfaces.html#interface-cookiejar">CookieJar</a> 是 <a href="net/http/http_package_api/http_package_classes.html#class-client">Client</a> 用来管理 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 的工具。</p>
<p>其有两个静态函数：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_interfaces.html#static-func-tocookiestringarraylistcookie">toCookieString</a> 用于将 ArrayList&lt;<a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a>&gt; 转成字符串以便设置请求的 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> header。</li>
<li><a href="net/http/http_package_api/http_package_interfaces.html#static-func-parsesetcookieheaderhttpresponse">parseSetCookieHeader</a> 用于解析收到 response 中的 <code>Set-Cookie</code> header。</li>
</ul>
<p>如果 <a href="net/http/http_package_api/http_package_classes.html#class-client">Client</a> 配置了 <a href="net/http/http_package_api/http_package_interfaces.html#interface-cookiejar">CookieJar</a>，那么 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 的解析收发都是自动的。</p>
<blockquote>
<p><strong>说明</strong></p>
<ul>
<li>用户可以实现自己的 <a href="net/http/http_package_api/http_package_interfaces.html#interface-cookiejar">CookieJar</a>，实现自己的管理逻辑。</li>
<li><a href="net/http/http_package_api/http_package_interfaces.html#interface-cookiejar">CookieJar</a> 的管理要求见 <a href="https://httpwg.org/specs/rfc6265.html">RFC 6265</a>。</li>
</ul>
</blockquote>
<h3 id="prop-ishttp"><a class="header" href="#prop-ishttp">prop isHttp</a></h3>
<pre><code class="language-cangjie">prop isHttp: Bool
</code></pre>
<p>功能：该 <a href="net/http/http_package_api/http_package_interfaces.html#interface-cookiejar">CookieJar</a> 是否用于 HTTP 协议。</p>
<ul>
<li>若 isHttp 为 true， 则只会存储来自于 HTTP 协议的 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a>。</li>
<li>若 isHttp 为 false， 则只会存储来自非 HTTP 协议的 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a>，且不会存储发送设置了 httpOnly 的 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a>。</li>
</ul>
<p>类型：Bool</p>
<h3 id="prop-rejectpublicsuffixes"><a class="header" href="#prop-rejectpublicsuffixes">prop rejectPublicSuffixes</a></h3>
<pre><code class="language-cangjie">prop rejectPublicSuffixes: ArrayList&lt;String&gt;
</code></pre>
<p>功能：获取 <a href="https://publicsuffix.org/">public suffixes</a> 配置，该配置是一个 domain 黑名单，会拒绝 domain 值为 public suffixes 的 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a>。</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>如果该 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 来自于与 domain 相同的 host，黑名单就不会生效。</p>
</blockquote>
<p>类型：ArrayList&lt;String&gt;</p>
<h3 id="static-func-createdefaultcookiejararrayliststring-bool"><a class="header" href="#static-func-createdefaultcookiejararrayliststring-bool">static func createDefaultCookieJar(ArrayList&lt;String&gt;, Bool)</a></h3>
<pre><code class="language-cangjie">static func createDefaultCookieJar(rejectPublicSuffixes: ArrayList&lt;String&gt;, isHttp: Bool): CookieJar
</code></pre>
<p>功能：构建默认的管理 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 的 <a href="net/http/http_package_api/http_package_interfaces.html#interface-cookiejar">CookieJar</a> 实例。</p>
<p>默认的 <a href="net/http/http_package_api/http_package_interfaces.html#interface-cookiejar">CookieJar</a> 的管理要求参考 <a href="https://httpwg.org/specs/rfc6265.html#storage-model">RFC 6265 5.3.</a>。</p>
<p>参数：</p>
<ul>
<li>rejectPublicSuffixes: ArrayList&lt;String&gt; - 用户配置的 public suffixes，<a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 管理为了安全会拒绝 domain 值为 public suffixes 的 cookie（除非该 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 来自于与 domain 相同的 host），public suffixes 见 <a href="https://publicsuffix.org/">PUBLIC SUFFIX LIST</a>。</li>
<li>isHttp: Bool - 该 <a href="net/http/http_package_api/http_package_interfaces.html#interface-cookiejar">CookieJar</a> 是否用于 HTTP 协议，isHttp 为 true 则只会存储来自于 HTTP 协议的 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a>。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_interfaces.html#interface-cookiejar">CookieJar</a> - 默认的 <a href="net/http/http_package_api/http_package_interfaces.html#interface-cookiejar">CookieJar</a> 实例。</li>
</ul>
<h3 id="static-func-parsesetcookieheaderhttpresponse"><a class="header" href="#static-func-parsesetcookieheaderhttpresponse">static func parseSetCookieHeader(HttpResponse)</a></h3>
<pre><code class="language-cangjie">static func parseSetCookieHeader(response: HttpResponse): ArrayList&lt;Cookie&gt;
</code></pre>
<p>功能：解析 response 中的 <code>Set-Cookie</code> header。</p>
<p>该函数解析 response 中的 <code>Set-Cookie</code> header，并返回解析出的 ArrayList&lt;<a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a>&gt;，解析 <code>Set-Cookie</code> header 的具体规则见 <a href="https://httpwg.org/specs/rfc6265.html#set-cookie">RFC 6265 5.2.</a>。</p>
<p>参数：</p>
<ul>
<li>response: <a href="net/http/http_package_api/http_package_classes.html#class-httpresponse">HttpResponse</a> - 所需要解析的 response。</li>
</ul>
<p>返回值：</p>
<ul>
<li>ArrayList&lt;<a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a>&gt; - 从 response 中解析出的 ArrayList&lt;<a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a>&gt; 数组。</li>
</ul>
<h3 id="static-func-tocookiestringarraylistcookie"><a class="header" href="#static-func-tocookiestringarraylistcookie">static func toCookieString(ArrayList&lt;Cookie&gt;)</a></h3>
<pre><code class="language-cangjie">static func toCookieString(cookies: ArrayList&lt;Cookie&gt;): String
</code></pre>
<p>功能：将 ArrayList&lt;<a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a>&gt; 转成字符串，用于 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> header。</p>
<p>该函数会将传入的 ArrayList&lt;<a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a>&gt; 数组转成协议规定的 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> header 的字符串形式，见 <a href="https://httpwg.org/specs/rfc6265.html#cookie">RFC 6265 5.4.4.</a>。</p>
<p>参数：</p>
<ul>
<li>cookies: ArrayList&lt;<a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a>&gt; - 所需转成 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> header 字符串的 ArrayList&lt;<a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a>&gt;。</li>
</ul>
<p>返回值：</p>
<ul>
<li>String - 用于 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> header 的字符串。</li>
</ul>
<h3 id="func-clear"><a class="header" href="#func-clear">func clear()</a></h3>
<pre><code class="language-cangjie">func clear(): Unit
</code></pre>
<p>功能：清除全部 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a>。</p>
<p>默认实现 CookieJarImpl 会清除 <a href="net/http/http_package_api/http_package_interfaces.html#interface-cookiejar">CookieJar</a> 中的所有 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a>。</p>
<h3 id="func-getcookiesurl"><a class="header" href="#func-getcookiesurl">func getCookies(URL)</a></h3>
<pre><code class="language-cangjie">func getCookies(url: URL): ArrayList&lt;Cookie&gt;
</code></pre>
<p>功能：从 <a href="net/http/http_package_api/http_package_interfaces.html#interface-cookiejar">CookieJar</a> 中取出 ArrayList&lt;<a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a>&gt;。</p>
<blockquote>
<p>默认实现 cookieJarImpl 的取 ArrayList&lt;<a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a>&gt; 函数的具体要求见 <a href="https://httpwg.org/specs/rfc6265.html#cookie">RFC 6265 5.4.</a>，对取出的 ArrayList&lt;<a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a>&gt; 调用 toCookieString 可以将取出的 ArrayList&lt;<a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a>&gt; 转成 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> header 的 value 字符串。</p>
</blockquote>
<p>参数：</p>
<ul>
<li>url: <a href="net/http/http_package_api/../../../encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> - 所要取出 ArrayList&lt;<a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a>&gt; 的 url。</li>
</ul>
<p>返回值：</p>
<ul>
<li>ArrayList&lt;<a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a>&gt; - <a href="net/http/http_package_api/http_package_interfaces.html#interface-cookiejar">CookieJar</a> 中存储的对应此 url 的 ArrayList&lt;<a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a>&gt;。</li>
</ul>
<h3 id="func-removecookiesstring"><a class="header" href="#func-removecookiesstring">func removeCookies(String)</a></h3>
<pre><code class="language-cangjie">func removeCookies(domain: String): Unit
</code></pre>
<p>功能：从 <a href="net/http/http_package_api/http_package_interfaces.html#interface-cookiejar">CookieJar</a> 中移除某个 domain 的 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a>。</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>默认实现 CookieJarImpl 的移除某个 domain 的 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 只会移除特定 domain 的 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a>，domain 的 subdomain 的 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 并不会移除。</p>
</blockquote>
<p>参数：</p>
<ul>
<li>domain: String - 所要移除 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 的域名。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 如果传入的 domain 为空字符串或者非法，则抛出该异常，合法的 domain 规则见 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 的参数文档。</li>
</ul>
<h3 id="func-storecookiesurl-arraylistcookie"><a class="header" href="#func-storecookiesurl-arraylistcookie">func storeCookies(URL, ArrayList&lt;Cookie&gt;)</a></h3>
<pre><code class="language-cangjie">func storeCookies(url: URL, cookies: ArrayList&lt;Cookie&gt;): Unit
</code></pre>
<p>功能：将 ArrayList&lt;<a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a>&gt; 存进 <a href="net/http/http_package_api/http_package_interfaces.html#interface-cookiejar">CookieJar</a>。</p>
<p>如果往 <a href="net/http/http_package_api/http_package_interfaces.html#interface-cookiejar">CookieJar</a> 中存 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 时超过了上限（3000 条），那么至少清除 <a href="net/http/http_package_api/http_package_interfaces.html#interface-cookiejar">CookieJar</a> 中 1000 条 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 再往里存储。清除 <a href="net/http/http_package_api/http_package_interfaces.html#interface-cookiejar">CookieJar</a> 中 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 的优先级见 <a href="https://httpwg.org/specs/rfc6265.html#storage-model">RFC 6265 5.3.12.</a>。</p>
<p><a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a>按如下顺序清除：</p>
<ul>
<li>过期的 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a>；</li>
<li>相同 domain 中超过 50 条以上的部分；</li>
<li>所有 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a>具有相同优先级的 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 则优先删除 <code>last-access</code> 属性更早的。</li>
</ul>
<p>参数：</p>
<ul>
<li>url: <a href="net/http/http_package_api/../../../encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> - 产生该 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 的 url。</li>
<li>cookies: ArrayList&lt;<a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a>&gt; - 需要存储的 ArrayList&lt;<a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a>&gt;。</li>
</ul>
<h2 id="interface-httprequestdistributor"><a class="header" href="#interface-httprequestdistributor">interface HttpRequestDistributor</a></h2>
<pre><code class="language-cangjie">public interface HttpRequestDistributor {
    func register(path: String, handler: HttpRequestHandler): Unit
    func register(path: String, handler: (HttpContext) -&gt; Unit): Unit
    func distribute(path: String): HttpRequestHandler
}
</code></pre>
<p>功能：Http request 分发器接口，将一个 request 按照 url 中的 path 分发给对应的 <a href="net/http/http_package_api/http_package_interfaces.html#interface-httprequesthandler">HttpRequestHandler</a> 处理。</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>本实现提供一个默认的 <a href="net/http/http_package_api/http_package_interfaces.html#interface-httprequestdistributor">HttpRequestDistributor</a>，该 distributor 非线程安全。
默认实现提供仓颉标准库中 HTTP/1.1、HTTP/2 的 <code>ProtocolService</code> 实例。
且只能在启动 server 前 register，启动后再次 register，结果未定义。
如果用户希望在启动 server 后还能够 register，需要自己提供一个线程安全的 <a href="net/http/http_package_api/http_package_interfaces.html#interface-httprequestdistributor">HttpRequestDistributor</a> 实现。</p>
</blockquote>
<h3 id="func-distributestring"><a class="header" href="#func-distributestring">func distribute(String)</a></h3>
<pre><code class="language-cangjie">func distribute(path: String): HttpRequestHandler
</code></pre>
<p>功能：分发请求处理器，未找到对应请求处理器时，将返回 <a href="net/http/http_package_api/http_package_classes.html#class-notfoundhandler">NotFoundHandler</a> 以返回 404 状态码。</p>
<p>参数：</p>
<ul>
<li>path: String - 请求路径。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_interfaces.html#interface-httprequesthandler">HttpRequestHandler</a> - 返回请求处理器。</li>
</ul>
<h3 id="func-registerstring-httpcontext---unit"><a class="header" href="#func-registerstring-httpcontext---unit">func register(String, (HttpContext) -&gt; Unit)</a></h3>
<pre><code class="language-cangjie">func register(path: String, handler: (HttpContext) -&gt; Unit): Unit
</code></pre>
<p>功能：注册请求处理器。</p>
<p>参数：</p>
<ul>
<li>path: String - 请求路径。</li>
<li>handler: (<a href="net/http/http_package_api/http_package_classes.html#class-httpcontext">HttpContext</a>) -&gt;Unit - 请求处理函数。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_exceptions.html#class-httpexception">HttpException</a> - 请求路径已注册请求处理器。</li>
</ul>
<h3 id="func-registerstring-httprequesthandler"><a class="header" href="#func-registerstring-httprequesthandler">func register(String, HttpRequestHandler)</a></h3>
<pre><code class="language-cangjie">func register(path: String, handler: HttpRequestHandler): Unit
</code></pre>
<p>功能：注册请求处理器。</p>
<p>参数：</p>
<ul>
<li>path: String - 请求路径。</li>
<li>handler: <a href="net/http/http_package_api/http_package_interfaces.html#interface-httprequesthandler">HttpRequestHandler</a> - 请求处理器。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_exceptions.html#class-httpexception">HttpException</a> - 请求路径已注册请求处理器。</li>
</ul>
<h2 id="interface-httprequesthandler"><a class="header" href="#interface-httprequesthandler">interface HttpRequestHandler</a></h2>
<pre><code class="language-cangjie">public interface HttpRequestHandler {
    func handle(ctx: HttpContext): Unit
}
</code></pre>
<p>功能：Http request 处理器。</p>
<p>http server 端通过 handler 处理来自客户端的 http request；在 handler 中用户可以获取 http request 的详细信息，包括 header、body；在 handler 中，用户可以构造 http response，包括 header、body，并且可以直接发送 response 给客户端，也可交由 server 发送。</p>
<p>用户在构建 http server 时，需手动通过 server 的 <a href="net/http/http_package_api/http_package_interfaces.html#interface-httprequestdistributor">HttpRequestDistributor</a> 注册一个或多个 handler，当一个客户端 http request 被接收，distributor 按照 request 中 url 的 path 分发给对应的 handler 处理。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>应用程序应注意 DNS 重绑定攻击，即在 handler 的处理逻辑中对 request 中的 Host 请求头的值进行合法性校验，校验该值是否为此应用程序所认可的权威主机名。</p>
</blockquote>
<h3 id="func-handlehttpcontext"><a class="header" href="#func-handlehttpcontext">func handle(HttpContext)</a></h3>
<pre><code class="language-cangjie">func handle(ctx: HttpContext): Unit
</code></pre>
<p>功能：处理 Http 请求。</p>
<p>参数：</p>
<ul>
<li>ctx: <a href="net/http/http_package_api/http_package_classes.html#class-httpcontext">HttpContext</a> - Http 请求上下文。</li>
</ul>
<h2 id="interface-protocolservicefactory"><a class="header" href="#interface-protocolservicefactory">interface ProtocolServiceFactory</a></h2>
<pre><code class="language-cangjie">public interface ProtocolServiceFactory {
    func create(protocol: Protocol, socket: StreamingSocket): ProtocolService
}
</code></pre>
<p>功能：Http 服务实例工厂，用于生成 <code>ProtocolService</code> 实例。</p>
<p><a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> 提供默认的实现。默认实现提供仓颉标准库中 HTTP/1.1、HTTP/2 的 <code>ProtocolService</code> 实例。</p>
<h3 id="func-createprotocol-streamingsocket"><a class="header" href="#func-createprotocol-streamingsocket">func create(Protocol, StreamingSocket)</a></h3>
<pre><code class="language-cangjie">func create(protocol: Protocol, socket: StreamingSocket): ProtocolService
</code></pre>
<p>功能：根据协议创建协议服务实例。</p>
<p>参数：</p>
<ul>
<li>protocol: <a href="net/http/http_package_api/http_package_enums.html#enum-protocol">Protocol</a> - 协议版本，如  <a href="net/http/http_package_api/./http_package_enums.html#enum-Protocol">HTTP1_0</a>、 <a href="net/http/http_package_api/./http_package_enums.html#enum-Protocol">HTTP1_1</a>、 <a href="net/http/http_package_api/./http_package_enums.html#enum-Protocol">HTTP2_0</a>。</li>
<li>socket: StreamingSocket - 来自客户端的套接字。</li>
</ul>
<p>返回值：</p>
<ul>
<li>ProtocolService - 协议服务实例。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类-22"><a class="header" href="#类-22">类</a></h1>
<h2 id="class-client"><a class="header" href="#class-client">class Client</a></h2>
<pre><code class="language-cangjie">public class Client
</code></pre>
<p>功能：发送 Http request、随时关闭等。用户可以通过 Client 实例发送 HTTP/1.1 或 HTTP/2 请求。</p>
<blockquote>
<p><strong>说明：</strong></p>
<p><a href="net/http/http_package_api/http_package_classes.html#class-client">Client</a> 文档中未明确说明支持版本的配置，在 HTTP/1.1 与 HTTP/2 都会生效。</p>
</blockquote>
<h3 id="prop-autoredirect"><a class="header" href="#prop-autoredirect">prop autoRedirect</a></h3>
<pre><code class="language-cangjie">public prop autoRedirect: Bool
</code></pre>
<p>功能：客户端是否会自动进行重定向，304 状态码默认不重定向。</p>
<p>类型：Bool</p>
<h3 id="prop-connector"><a class="header" href="#prop-connector">prop connector</a></h3>
<pre><code class="language-cangjie">public prop connector: (SocketAddress) -&gt; StreamingSocket
</code></pre>
<p>功能：客户端调用此函数获取到服务器的连接。</p>
<p>类型：(SocketAddress) -&gt; StreamingSocket</p>
<h3 id="prop-cookiejar"><a class="header" href="#prop-cookiejar">prop cookieJar</a></h3>
<pre><code class="language-cangjie">public prop cookieJar: ?CookieJar
</code></pre>
<p>功能：用于存储客户端所有 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a>，如果配置为 None，则不会启用 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a>。</p>
<p>类型：?<a href="net/http/http_package_api/http_package_interfaces.html#interface-cookiejar">CookieJar</a></p>
<h3 id="prop-enablepush"><a class="header" href="#prop-enablepush">prop enablePush</a></h3>
<pre><code class="language-cangjie">public prop enablePush: Bool
</code></pre>
<p>功能：客户端 HTTP/2 是否支持服务器推送，默认值为 true。</p>
<p>类型：Bool</p>
<h3 id="prop-headertablesize"><a class="header" href="#prop-headertablesize">prop headerTableSize</a></h3>
<pre><code class="language-cangjie">public prop headerTableSize: UInt32
</code></pre>
<p>功能：获取客户端 HTTP/2 Hpack 动态表的初始值，默认值为 4096。</p>
<p>类型：UInt32</p>
<h3 id="prop-httpproxy"><a class="header" href="#prop-httpproxy">prop httpProxy</a></h3>
<pre><code class="language-cangjie">public prop httpProxy: String
</code></pre>
<p>功能：获取客户端 http 代理，默认使用系统环境变量 http_proxy 的值，用字符串表示，格式为：<code>&quot;http://host:port&quot;</code>，例如：<code>&quot;http://192.168.1.1:80&quot;</code>。</p>
<p>类型：String</p>
<h3 id="prop-httpsproxy"><a class="header" href="#prop-httpsproxy">prop httpsProxy</a></h3>
<pre><code class="language-cangjie">public prop httpsProxy: String
</code></pre>
<p>功能：获取客户端 https 代理，默认使用系统环境变量 https_proxy 的值，用字符串表示，格式为：<code>&quot;http://host:port&quot;</code>，例如：<code>&quot;http://192.168.1.1:443&quot;</code>。</p>
<p>类型：String</p>
<h3 id="prop-initialwindowsize"><a class="header" href="#prop-initialwindowsize">prop initialWindowSize</a></h3>
<pre><code class="language-cangjie">public prop initialWindowSize: UInt32
</code></pre>
<p>功能：获取客户端 HTTP/2 流控窗口初始值，默认值为 65535 ，取值范围为 0 至 2^31 - 1。</p>
<p>类型：UInt32</p>
<h3 id="prop-logger"><a class="header" href="#prop-logger">prop logger</a></h3>
<pre><code class="language-cangjie">public prop logger: Logger
</code></pre>
<p>功能：获取客户端日志记录器，设置 logger.level 将立即生效，记录器应该是线程安全的。</p>
<p>类型：<a href="net/http/http_package_api/../../../log/log_package_api/log_package_classes.html#class-logger">Logger</a></p>
<h3 id="prop-maxconcurrentstreams"><a class="header" href="#prop-maxconcurrentstreams">prop maxConcurrentStreams</a></h3>
<pre><code class="language-cangjie">public prop maxConcurrentStreams: UInt32
</code></pre>
<p>功能：获取客户端 HTTP/2 初始最大并发流数量，默认值为 2^31 - 1。</p>
<p>类型：UInt32</p>
<h3 id="prop-maxframesize"><a class="header" href="#prop-maxframesize">prop maxFrameSize</a></h3>
<pre><code class="language-cangjie">public prop maxFrameSize: UInt32
</code></pre>
<p>功能：获取客户端 HTTP/2 初始最大帧大小。默认值为 16384. 取值范围为 2^14 至 2^24 - 1。</p>
<p>类型：UInt32</p>
<h3 id="prop-maxheaderlistsize"><a class="header" href="#prop-maxheaderlistsize">prop maxHeaderListSize</a></h3>
<pre><code class="language-cangjie">public prop maxHeaderListSize: UInt32
</code></pre>
<p>功能：获取客户端支持的 HTTP/2 最大头部（Header）大小。这个大小指的是响应头部中所有头部字段（Header Field）的最大允许长度之和，其中包括所有字段名称（name）的长度、字段值（value）的长度以及每个字段自动添加的伪头开销（通常每个字段会有32字节的开销，这包括了 HTTP/2 协议本身为头部字段添加的伪头部信息）。默认情况下，这个最大长度被设置为 UInt32.Max。</p>
<p>类型：UInt32</p>
<h3 id="prop-poolsize"><a class="header" href="#prop-poolsize">prop poolSize</a></h3>
<pre><code class="language-cangjie">public prop poolSize: Int64
</code></pre>
<p>功能：配置 HTTP/1.1 客户端使用的连接池的大小，亦可表示对同一个主机（host:port）同时存在的连接数的最大值。</p>
<p>类型：Int64</p>
<h3 id="prop-readtimeout"><a class="header" href="#prop-readtimeout">prop readTimeout</a></h3>
<pre><code class="language-cangjie">public prop readTimeout: Duration
</code></pre>
<p>功能：获取客户端设定的读取整个响应的超时时间，默认值为 15 秒。</p>
<p>类型：Duration</p>
<h3 id="prop-writetimeout"><a class="header" href="#prop-writetimeout">prop writeTimeout</a></h3>
<pre><code class="language-cangjie">public prop writeTimeout: Duration
</code></pre>
<p>功能：获取客户端设定的写请求的超时时间，默认值为 15 秒。</p>
<p>类型：Duration</p>
<h3 id="func-close-8"><a class="header" href="#func-close-8">func close()</a></h3>
<pre><code class="language-cangjie">public func close(): Unit
</code></pre>
<p>功能：关闭客户端建立的所有连接，调用后不能继续发送请求。</p>
<h3 id="func-connectstring-httpheaders-protocol"><a class="header" href="#func-connectstring-httpheaders-protocol">func connect(String, HttpHeaders, Protocol)</a></h3>
<pre><code class="language-cangjie">public func connect(url: String, header!: HttpHeaders = HttpHeaders(), version!: Protocol = HTTP1_1): (HttpResponse, ?StreamingSocket)
</code></pre>
<p>功能：发送 CONNECT 请求与服务器建立隧道，返回建连成功后的连接，连接由用户负责关闭。服务器返回 2xx 表示建连成功，否则建连失败（不支持自动重定向，3xx 也视为失败）。</p>
<p>参数：</p>
<ul>
<li>url: String - 请求的 url。</li>
<li>header!: <a href="net/http/http_package_api/http_package_classes.html#class-httpheaders">HttpHeaders</a> - 请求头，默认为空请求头。</li>
<li>version!: <a href="net/http/http_package_api/http_package_enums.html#enum-protocol">Protocol</a> - 请求的协议，默认为 <a href="net/http/http_package_api/./http_package_enums.html#enum-Protocol">HTTP1_1</a>。</li>
</ul>
<p>返回值：</p>
<ul>
<li>(<a href="net/http/http_package_api/http_package_classes.html#class-httpresponse">HttpResponse</a>, ?StreamingSocket) - 返回元组类型，其中 <a href="net/http/http_package_api/http_package_classes.html#class-httpresponse">HttpResponse</a> 实例表示服务器返回的响应体，Option&lt;StreamingSocket&gt; 实例表示请求成功时返回 headers 之后连接。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="net/http/http_package_api/../../../encoding/url/url_package_api/url_package_exceptions.html#class-urlsyntaxexception">UrlSyntaxException</a> - 当参数 url 不符合 <a href="net/http/http_package_api/../../../encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 解析规范时，抛出异常。</li>
<li>IllegalArgumentException - 当被编码的字符不符合 UTF-8 的字节序列规则时，抛出异常。</li>
<li>其余同 func send。</li>
</ul>
<h3 id="func-deletestring"><a class="header" href="#func-deletestring">func delete(String)</a></h3>
<pre><code class="language-cangjie">public func delete(url: String): HttpResponse
</code></pre>
<p>功能：请求方法为 DELETE 的便捷请求函数。</p>
<p>参数：</p>
<ul>
<li>url: String - 请求的 url。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httpresponse">HttpResponse</a> - 服务端返回的响应。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="net/http/http_package_api/../../../encoding/url/url_package_api/url_package_exceptions.html#class-urlsyntaxexception">UrlSyntaxException</a> - 当参数 url 不符合 <a href="net/http/http_package_api/../../../encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 解析规范时，抛出异常。</li>
<li>IllegalArgumentException - 当被编码的字符不符合 UTF-8 的字节序列规则时，抛出异常。</li>
<li>其余同 func send。</li>
</ul>
<h3 id="func-getstring-2"><a class="header" href="#func-getstring-2">func get(String)</a></h3>
<pre><code class="language-cangjie">public func get(url: String): HttpResponse
</code></pre>
<p>功能：请求方法为 GET 的便捷请求函数。</p>
<p>参数：</p>
<ul>
<li>url: String - 请求的 url。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httpresponse">HttpResponse</a> - 服务端返回的响应。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="net/http/http_package_api/../../../encoding/url/url_package_api/url_package_exceptions.html#class-urlsyntaxexception">UrlSyntaxException</a> - 当参数 url 不符合 <a href="net/http/http_package_api/../../../encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 解析规范时，抛出异常。</li>
<li>IllegalArgumentException - 当被编码的字符不符合 UTF-8 的字节序列规则时，抛出异常。</li>
<li>其余同 func send。</li>
</ul>
<h3 id="func-gettlsconfig"><a class="header" href="#func-gettlsconfig">func getTlsConfig()</a></h3>
<pre><code class="language-cangjie">public func getTlsConfig(): ?TlsClientConfig
</code></pre>
<p>功能：获取客户端设定的 TLS 层配置。</p>
<p>返回值：</p>
<ul>
<li>?<a href="net/http/http_package_api/../../tls/tls_package_api/tls_package_structs.html#struct-tlsclientconfig">TlsClientConfig</a> - 客户端设定的 TLS 层配置，如果没有设置则返回 None。</li>
</ul>
<h3 id="func-headstring"><a class="header" href="#func-headstring">func head(String)</a></h3>
<pre><code class="language-cangjie">public func head(url: String): HttpResponse
</code></pre>
<p>功能：请求方法为 HEAD 的便捷请求函数。</p>
<p>参数：</p>
<ul>
<li>url: String - 请求的 url。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httpresponse">HttpResponse</a> - 服务端返回的响应。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="net/http/http_package_api/../../../encoding/url/url_package_api/url_package_exceptions.html#class-urlsyntaxexception">UrlSyntaxException</a> - 当参数 url 不符合 <a href="net/http/http_package_api/../../../encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 解析规范时，抛出异常。</li>
<li>IllegalArgumentException - 当被编码的字符不符合 UTF-8 的字节序列规则时，抛出异常。</li>
<li>其余同 func send。</li>
</ul>
<h3 id="func-optionsstring"><a class="header" href="#func-optionsstring">func options(String)</a></h3>
<pre><code class="language-cangjie">public func options(url: String): HttpResponse
</code></pre>
<p>功能：请求方法为 OPTIONS 的便捷请求函数。</p>
<p>参数：</p>
<ul>
<li>url: String - 请求的 url。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httpresponse">HttpResponse</a> - 服务端返回的响应。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="net/http/http_package_api/../../../encoding/url/url_package_api/url_package_exceptions.html#class-urlsyntaxexception">UrlSyntaxException</a> - 当参数 url 不符合 <a href="net/http/http_package_api/../../../encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 解析规范时，抛出异常。</li>
<li>IllegalArgumentException - 当被编码的字符不符合 UTF-8 的字节序列规则时，抛出异常。</li>
<li>其余同 func send。</li>
</ul>
<h3 id="func-poststring-arrayuint8"><a class="header" href="#func-poststring-arrayuint8">func post(String, Array&lt;UInt8&gt;)</a></h3>
<pre><code class="language-cangjie">public func post(url: String, body: Array&lt;UInt8&gt;): HttpResponse
</code></pre>
<p>功能：请求方法为 POST 的便捷请求函数。</p>
<p>参数：</p>
<ul>
<li>url: String - 请求的 url。</li>
<li>body: Array&lt;UInt8&gt; - 请求体。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httpresponse">HttpResponse</a> - 服务端返回的响应。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="net/http/http_package_api/../../../encoding/url/url_package_api/url_package_exceptions.html#class-urlsyntaxexception">UrlSyntaxException</a> - 当参数 url 不符合 <a href="net/http/http_package_api/../../../encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 解析规范时，抛出异常。</li>
<li>IllegalArgumentException - 当被编码的字符不符合 UTF-8 的字节序列规则时，抛出异常。</li>
<li>其余同 func send。</li>
</ul>
<h3 id="func-poststring-inputstream"><a class="header" href="#func-poststring-inputstream">func post(String, InputStream)</a></h3>
<pre><code class="language-cangjie">public func post(url: String, body: InputStream): HttpResponse
</code></pre>
<p>功能：请求方法为 POST 的便捷请求函数。</p>
<p>参数：</p>
<ul>
<li>url: String - 请求的 url。</li>
<li>body: InputStream - 请求体。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httpresponse">HttpResponse</a> - 服务端返回的响应。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="net/http/http_package_api/../../../encoding/url/url_package_api/url_package_exceptions.html#class-urlsyntaxexception">UrlSyntaxException</a> - 当参数 url 不符合 <a href="net/http/http_package_api/../../../encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 解析规范时，抛出异常。</li>
<li>IllegalArgumentException - 当被编码的字符不符合 UTF-8 的字节序列规则时，抛出异常。</li>
<li>其余同 func send。</li>
</ul>
<h3 id="func-poststring-string"><a class="header" href="#func-poststring-string">func post(String, String)</a></h3>
<pre><code class="language-cangjie">public func post(url: String, body: String): HttpResponse
</code></pre>
<p>功能：请求方法为 POST 的便捷请求函数。</p>
<p>参数：</p>
<ul>
<li>url: String - 请求的 url。</li>
<li>body: String - 请求体。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httpresponse">HttpResponse</a> - 服务端返回的响应。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="net/http/http_package_api/../../../encoding/url/url_package_api/url_package_exceptions.html#class-urlsyntaxexception">UrlSyntaxException</a> - 当参数 url 不符合 <a href="net/http/http_package_api/../../../encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 解析规范时，抛出异常。</li>
<li>IllegalArgumentException - 当被编码的字符不符合 UTF-8 的字节序列规则时，抛出异常。</li>
<li>其余同 func send。</li>
</ul>
<h3 id="func-putstring-arrayuint8"><a class="header" href="#func-putstring-arrayuint8">func put(String, Array&lt;UInt8&gt;)</a></h3>
<pre><code class="language-cangjie">public func put(url: String, body: Array&lt;UInt8&gt;): HttpResponse
</code></pre>
<p>功能：请求方法为 PUT 的便捷请求函数。</p>
<p>参数：</p>
<ul>
<li>url: String - 请求的 url。</li>
<li>body: Array&lt;UInt8&gt; - 请求体。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httpresponse">HttpResponse</a> - 服务端返回的响应。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="net/http/http_package_api/../../../encoding/url/url_package_api/url_package_exceptions.html#class-urlsyntaxexception">UrlSyntaxException</a> - 当参数 url 不符合 <a href="net/http/http_package_api/../../../encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 解析规范时，抛出异常。</li>
<li>IllegalArgumentException - 当被编码的字符不符合 UTF-8 的字节序列规则时，抛出异常。</li>
<li>其余同 func send。</li>
</ul>
<h3 id="func-putstring-inputstream"><a class="header" href="#func-putstring-inputstream">func put(String, InputStream)</a></h3>
<pre><code class="language-cangjie">public func put(url: String, body: InputStream): HttpResponse
</code></pre>
<p>功能：请求方法为 PUT 的便捷请求函数。</p>
<p>参数：</p>
<ul>
<li>url: String - 请求的 url。</li>
<li>body: InputStream - 请求体。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httpresponse">HttpResponse</a> - 服务端返回的响应。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="net/http/http_package_api/../../../encoding/url/url_package_api/url_package_exceptions.html#class-urlsyntaxexception">UrlSyntaxException</a> - 当参数 url 不符合 <a href="net/http/http_package_api/../../../encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 解析规范时，抛出异常。</li>
<li>IllegalArgumentException - 当被编码的字符不符合 UTF-8 的字节序列规则时，抛出异常。</li>
<li>其余同 func send。</li>
</ul>
<h3 id="func-putstring-string"><a class="header" href="#func-putstring-string">func put(String, String)</a></h3>
<pre><code class="language-cangjie">public func put(url: String, body: String): HttpResponse
</code></pre>
<p>功能：请求方法为 PUT 的便捷请求函数。</p>
<p>参数：</p>
<ul>
<li>url: String - 请求的 url。</li>
<li>body: String - 请求体。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httpresponse">HttpResponse</a> - 服务端返回的响应。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="net/http/http_package_api/../../../encoding/url/url_package_api/url_package_exceptions.html#class-urlsyntaxexception">UrlSyntaxException</a> - 当参数 url 不符合 <a href="net/http/http_package_api/../../../encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 解析规范时，抛出异常。</li>
<li>IllegalArgumentException - 当被编码的字符不符合 UTF-8 的字节序列规则时，抛出异常。</li>
<li>其余同 func send。</li>
</ul>
<h3 id="func-sendhttprequest"><a class="header" href="#func-sendhttprequest">func send(HttpRequest)</a></h3>
<pre><code class="language-cangjie">public func send(req: HttpRequest): HttpResponse
</code></pre>
<p>功能：通用请求函数，发送 <a href="net/http/http_package_api/http_package_classes.html#class-httprequest">HttpRequest</a> 到 url 中的服务器，接收 <a href="net/http/http_package_api/http_package_classes.html#class-httpresponse">HttpResponse</a>。</p>
<blockquote>
<p><strong>注意:</strong></p>
<ul>
<li>对于 HTTP/1.1，如果请求中有 body 要发，那么需要保证 Content-Length 和 Transfer-Encoding: chunked 必有且只有一个，以 chunked 形式发时，每段 chunk 最大为 8192 字节；如果用户发送的 body 为自己实现的 InputStream 类，则需要自己保证 Content-Length和 Transfer-Encoding: chunked 设置且只设置了一个；如果用户采用默认的 body 发送，Content-Length 和 Transfer-Encoding: chunked 都缺失时，我们会为其补上 Content-Length header，值为 body.size；</li>
<li>用户如果设置了 Content-Length，则需要保证其正确性：如果所发 body 的内容大于等于 Content-Length 的值，我们会发送长度为 Content-Length 值的数据；如果所发 body 的内容小于 Content-Length 的值，此时如果 body 是默认的 body，则会抛出 <a href="net/http/http_package_api/http_package_exceptions.html#class-httpexception">HttpException</a>，如果 body是用户自己实现的 InputStream 类，其行为便无法保证（可能会造成服务器端的读 request 超时或者客户端的收 response 超时）；</li>
<li>升级函数通过 <a href="net/http/http_package_api/http_package_classes.html#class-websocket">WebSocket</a> 的 upgradeFromClient 或 <a href="net/http/http_package_api/http_package_classes.html#class-client">Client</a> 的 <a href="net/http/http_package_api/http_package_funcs.html#func-upgradehttpcontext">upgrade</a> 接口发出，调用 client 的其他函数发送 <a href="net/http/http_package_api/http_package_funcs.html#func-upgradehttpcontext">upgrade</a> 请求会抛出异常；</li>
<li>协议规定 TRACE 请求无法携带内容，故用户发送带有 body 的 TRACE 请求时会抛出异常；</li>
<li>HTTP/1.1 默认对同一个服务器的连接数不超过 10 个。response 的 body 需要用户调用 <code>body.read(buf: Array&lt;Byte&gt;)</code> 函数去读。body 被读完后，连接才能被客户端对象复用，否则请求相同的服务器也会新建连接。新建连接时如果连接数超出限制则会抛出 <a href="net/http/http_package_api/http_package_exceptions.html#class-httpexception">HttpException</a>；</li>
<li>body.read 函数将 body 读完之后返回 0，如果读的时候连接断开会抛出 <a href="net/http/http_package_api/http_package_exceptions.html#class-connectionexception">ConnectionException</a>；</li>
<li>HTTP/1.1 的升级请求如果收到 101 响应，则表示切换协议，此连接便不归 client 管理；</li>
<li>下文的快捷请求函数的注意点与 send 相同。</li>
</ul>
</blockquote>
<p>参数：</p>
<ul>
<li>req: <a href="net/http/http_package_api/http_package_classes.html#class-httprequest">HttpRequest</a> - 发送的请求。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httpresponse">HttpResponse</a> - 服务端返回处理该请求的响应。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="net/http/http_package_api/../../../encoding/url/url_package_api/url_package_exceptions.html#class-urlsyntaxexception">UrlSyntaxException</a> - 请求中 <a href="net/http/http_package_api/../../../encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 错误时抛此异常。</li>
<li>SocketException - Socket 连接出现错误时抛此异常。</li>
<li><a href="net/http/http_package_api/http_package_exceptions.html#class-connectionexception">ConnectionException</a> - 从连接中读数据时对端已关闭连接抛此异常。</li>
<li>SocketTimeoutException - Socket 连接超时抛此异常。</li>
<li><a href="net/http/http_package_api/../../tls/tls_package_api/tls_package_exceptions.html#class-tlsexception">TlsException</a> - Tls 连接建立失败或通信异常抛此异常。</li>
<li><a href="net/http/http_package_api/http_package_exceptions.html#class-httpexception">HttpException</a> - 当用户未使用 http 库提供的 API 升级 <a href="net/http/http_package_api/http_package_classes.html#class-websocket">WebSocket</a> 时抛此异常。</li>
<li><a href="net/http/http_package_api/http_package_exceptions.html#class-httptimeoutexception">HttpTimeoutException</a> - 请求超时或读 <a href="net/http/http_package_api/http_package_classes.html#class-httpresponse">HttpResponse</a>.body 超时抛此异常。</li>
</ul>
<h3 id="func-upgradehttprequest"><a class="header" href="#func-upgradehttprequest">func upgrade(HttpRequest)</a></h3>
<pre><code class="language-cangjie">public func upgrade(req: HttpRequest): (HttpResponse, ?StreamingSocket)
</code></pre>
<p>功能：发送请求并升级协议，用户设置请求头，返回升级后的连接（如果升级成功），连接由用户负责关闭。</p>
<blockquote>
<p><strong>说明：</strong></p>
<ul>
<li>服务器返回 101 表示升级成功，获取到了 StreamingSocket；</li>
<li>必选请求头:
<ul>
<li>Upgrade:  protocol-name [&quot;/&quot; protocol-version]；</li>
<li>Connection: Upgrade (在请求头包含 Upgrade 字段时会自动添加)；</li>
</ul>
</li>
<li>不支持 HTTP/1.0、HTTP/2；</li>
<li>不支持 HTTP/1.1 CONNECT 方法的 <a href="net/http/http_package_api/http_package_classes.html#class-httprequest">HttpRequest</a>。</li>
</ul>
</blockquote>
<p>参数：</p>
<ul>
<li>req: <a href="net/http/http_package_api/http_package_classes.html#class-httprequest">HttpRequest</a> - 升级时发送的请求。</li>
</ul>
<p>返回值：</p>
<ul>
<li>(<a href="net/http/http_package_api/http_package_classes.html#class-httpresponse">HttpResponse</a>,?StreamingSocket) - 返回一个元组，<a href="net/http/http_package_api/http_package_classes.html#class-httpresponse">HttpResponse</a> 实例表示服务器返回的响应，?StreamingSocket 实例表示获取的底层连接，升级失败时为 None。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_exceptions.html#class-httpexception">HttpException</a> -
<ul>
<li>请求报文或响应报文不符合协议；</li>
<li>请求报文不含 Upgrade 头；</li>
<li>发送 CONNECT 请求；</li>
<li>发送带 body 的 TRACE 请求；</li>
</ul>
</li>
<li>SocketException，<a href="net/http/http_package_api/http_package_exceptions.html#class-connectionexception">ConnectionException</a> - Socket 连接出现异常或被关闭；</li>
<li>SocketTimeoutException - Socket 连接超时；</li>
<li><a href="net/http/http_package_api/../../tls/tls_package_api/tls_package_exceptions.html#class-tlsexception">TlsException</a> - Tls 连接建立失败或通信异常。</li>
</ul>
<h2 id="class-clientbuilder"><a class="header" href="#class-clientbuilder">class ClientBuilder</a></h2>
<pre><code class="language-cangjie">public class ClientBuilder {
    public init()
}
</code></pre>
<p>功能：用于 <a href="net/http/http_package_api/http_package_classes.html#class-client">Client</a> 实例的构建，<a href="net/http/http_package_api/http_package_classes.html#class-client">Client</a> 没有公开的构造函数，用户只能通过 <a href="net/http/http_package_api/http_package_classes.html#class-clientbuilder">ClientBuilder</a> 得到 <a href="net/http/http_package_api/http_package_classes.html#class-client">Client</a> 实例。<a href="net/http/http_package_api/http_package_classes.html#class-clientbuilder">ClientBuilder</a> 文档中未明确说明支持版本的配置，在 HTTP/1.1 与 HTTP/2 都会生效。</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>该类提供了一系列配置参数的函数，配置完成后调用 <a href="net/http/http_package_api/./http_package_classes.html#func-build">build</a> 函数构造出 <a href="net/http/http_package_api/./http_package_classes.html#class-client">Client</a> 实例。配置函数中说明了参数的取值范围，但配置函数本身不做参数合法性校验，<a href="net/http/http_package_api/./http_package_classes.html#func-build">build</a> 时统一进行校验。</p>
</blockquote>
<h3 id="init-19"><a class="header" href="#init-19">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：创建新的 <a href="net/http/http_package_api/http_package_classes.html#class-clientbuilder">ClientBuilder</a> 实例。</p>
<h3 id="func-autoredirectbool"><a class="header" href="#func-autoredirectbool">func autoRedirect(Bool)</a></h3>
<pre><code class="language-cangjie">public func autoRedirect(auto: Bool): ClientBuilder
</code></pre>
<p>功能：配置客户端是否会自动进行重定向。重定向会请求 Location 头的资源，协议规定，Location 只能包含一个 URI 引用Location = URI-reference，详见 <a href="https://httpwg.org/specs/rfc9110.html#rfc.section.10.2.2">RFC 9110 10.2.2.</a>。304 状态码默认不重定向。</p>
<p>参数：</p>
<ul>
<li>auto: Bool - 默认值为 true，即开启自动重定向。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-clientbuilder">ClientBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-clientbuilder">ClientBuilder</a> 实例的引用。</li>
</ul>
<h3 id="func-build-1"><a class="header" href="#func-build-1">func build()</a></h3>
<pre><code class="language-cangjie">public func build(): Client
</code></pre>
<p>功能：构造 <a href="net/http/http_package_api/http_package_classes.html#class-client">Client</a> 实例。</p>
<p>此处会对各参数的值进行检查，如果取值非法，将抛出异常。各参数的取值范围详见设置参数相关的函数。</p>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-client">Client</a> - 用当前 <a href="net/http/http_package_api/http_package_classes.html#class-clientbuilder">ClientBuilder</a> 实例中的配置构建的 <a href="net/http/http_package_api/http_package_classes.html#class-client">Client</a> 实例。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 配置项有非法参数时抛出此异常。</li>
</ul>
<h3 id="func-connectorsocketaddress-streamingsocket"><a class="header" href="#func-connectorsocketaddress-streamingsocket">func connector((SocketAddress)-&gt;StreamingSocket)</a></h3>
<pre><code class="language-cangjie">public func connector(c: (SocketAddress) -&gt; StreamingSocket): ClientBuilder
</code></pre>
<p>功能：客户端调用此函数获取到服务器的连接。</p>
<p>参数：</p>
<ul>
<li>c: (SocketAddress) -&gt;StreamingSocket - 入参为 SocketAddress 实例，返回值类型为 StreamingSocket 的函数类型。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-clientbuilder">ClientBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-clientbuilder">ClientBuilder</a> 实例的引用。</li>
</ul>
<h3 id="func-cookiejarcookiejar"><a class="header" href="#func-cookiejarcookiejar">func cookieJar(?CookieJar)</a></h3>
<pre><code class="language-cangjie">public func cookieJar(cookieJar: ?CookieJar): ClientBuilder
</code></pre>
<p>功能：用于存储客户端所有 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a>。</p>
<p>参数：</p>
<ul>
<li>cookieJar: ?<a href="net/http/http_package_api/http_package_interfaces.html#interface-cookiejar">CookieJar</a> - 默认使用一个空的 <a href="net/http/http_package_api/http_package_interfaces.html#interface-cookiejar">CookieJar</a>，如果配置为 None 则不会启用 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a>。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-clientbuilder">ClientBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-clientbuilder">ClientBuilder</a> 实例的引用。</li>
</ul>
<h3 id="func-enablepushbool"><a class="header" href="#func-enablepushbool">func enablePush(Bool)</a></h3>
<pre><code class="language-cangjie">public func enablePush(enable: Bool): ClientBuilder
</code></pre>
<p>功能：配置客户端 HTTP/2 是否支持服务器推送。</p>
<p>参数：</p>
<ul>
<li>enable: Bool - 默认值 true。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-clientbuilder">ClientBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-clientbuilder">ClientBuilder</a> 实例的引用。</li>
</ul>
<h3 id="func-headertablesizeuint32"><a class="header" href="#func-headertablesizeuint32">func headerTableSize(UInt32)</a></h3>
<pre><code class="language-cangjie">public func headerTableSize(size: UInt32): ClientBuilder
</code></pre>
<p>功能：配置客户端 HTTP/2 Hpack 动态表初始值。</p>
<p>参数：</p>
<ul>
<li>size: UInt32 - 默认值 4096。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-clientbuilder">ClientBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-clientbuilder">ClientBuilder</a> 实例的引用。</li>
</ul>
<h3 id="func-httpproxystring"><a class="header" href="#func-httpproxystring">func httpProxy(String)</a></h3>
<pre><code class="language-cangjie">public func httpProxy(addr: String): ClientBuilder
</code></pre>
<p>功能：设置客户端 http 代理，默认使用系统环境变量 http_proxy 的值。</p>
<p>参数：</p>
<ul>
<li>addr: String - 格式为：<code>&quot;http://host:port&quot;</code>，例如：<code>&quot;http://192.168.1.1:80&quot;</code>。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-clientbuilder">ClientBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-clientbuilder">ClientBuilder</a> 实例的引用。</li>
</ul>
<h3 id="func-httpsproxystring"><a class="header" href="#func-httpsproxystring">func httpsProxy(String)</a></h3>
<pre><code class="language-cangjie">public func httpsProxy(addr: String): ClientBuilder
</code></pre>
<p>功能：设置客户端 https 代理，默认使用系统环境变量 https_proxy 的值。</p>
<p>参数：</p>
<ul>
<li>addr: String - 格式为：<code>&quot;http://host:port&quot;</code>，例如：<code>&quot;http://192.168.1.1:443&quot;</code>。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-clientbuilder">ClientBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-clientbuilder">ClientBuilder</a> 实例的引用。</li>
</ul>
<h3 id="func-initialwindowsizeuint32"><a class="header" href="#func-initialwindowsizeuint32">func initialWindowSize(UInt32)</a></h3>
<pre><code class="language-cangjie">public func initialWindowSize(size: UInt32): ClientBuilder
</code></pre>
<p>功能：配置客户端 HTTP/2 流控窗口初始值。</p>
<p>参数：</p>
<ul>
<li>size: UInt32 - 默认值 65535 ， 取值范围为 0 至 2^31 - 1。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-clientbuilder">ClientBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-clientbuilder">ClientBuilder</a> 实例的引用。</li>
</ul>
<h3 id="func-loggerlogger"><a class="header" href="#func-loggerlogger">func logger(Logger)</a></h3>
<pre><code class="language-cangjie">public func logger(logger: Logger): ClientBuilder
</code></pre>
<p>功能：设定客户端的 logger，默认 logger 级别为 INFO，logger 内容将写入 Console.stdout。</p>
<p>参数：</p>
<ul>
<li>logger: <a href="net/http/http_package_api/../../../log/log_package_api/log_package_classes.html#class-logger">Logger</a> - 需要是线程安全的，默认使用内置线程安全 logger。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-clientbuilder">ClientBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-clientbuilder">ClientBuilder</a> 实例的引用。</li>
</ul>
<h3 id="func-maxconcurrentstreamsuint32"><a class="header" href="#func-maxconcurrentstreamsuint32">func maxConcurrentStreams(UInt32)</a></h3>
<pre><code class="language-cangjie">public func maxConcurrentStreams(size: UInt32): ClientBuilder
</code></pre>
<p>功能：配置客户端 HTTP/2 初始最大并发流数量。</p>
<p>参数：</p>
<ul>
<li>size: UInt32 - 默认值为 2^31 - 1。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-clientbuilder">ClientBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-clientbuilder">ClientBuilder</a> 实例的引用。</li>
</ul>
<h3 id="func-maxframesizeuint32"><a class="header" href="#func-maxframesizeuint32">func maxFrameSize(UInt32)</a></h3>
<pre><code class="language-cangjie">public func maxFrameSize(size: UInt32): ClientBuilder
</code></pre>
<p>功能：配置客户端 HTTP/2 初始最大帧大小。</p>
<p>参数：</p>
<ul>
<li>size: UInt32 - 默认值为 16384。取值范围为 2^14 至 2^24 - 1。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-clientbuilder">ClientBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-clientbuilder">ClientBuilder</a> 实例的引用。</li>
</ul>
<h3 id="func-maxheaderlistsizeuint32"><a class="header" href="#func-maxheaderlistsizeuint32">func maxHeaderListSize(UInt32)</a></h3>
<pre><code class="language-cangjie">public func maxHeaderListSize(size: UInt32): ClientBuilder
</code></pre>
<p>功能：获取客户端支持的 HTTP/2 最大头部（Header）大小。这个大小指的是响应头部中所有头部字段（Header Field）的最大允许长度之和，其中包括所有字段名称（name）的长度、字段值（value）的长度以及每个字段自动添加的伪头开销（通常每个字段会有 32 字节的开销，这包括了 HTTP/2 协议本身为头部字段添加的伪头部信息）。默认情况下，这个最大长度被设置为 UInt32.Max。</p>
<p>参数：</p>
<ul>
<li>size: UInt32 - 客户端接收的 HTTP/2 响应 headers 最大长度。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-clientbuilder">ClientBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-clientbuilder">ClientBuilder</a> 实例的引用。</li>
</ul>
<h3 id="func-noproxy"><a class="header" href="#func-noproxy">func noProxy()</a></h3>
<pre><code class="language-cangjie">public func noProxy(): ClientBuilder
</code></pre>
<p>功能：调用此函数后，客户端不使用任何代理。</p>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-clientbuilder">ClientBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-clientbuilder">ClientBuilder</a> 实例的引用。</li>
</ul>
<h3 id="func-poolsizeint64"><a class="header" href="#func-poolsizeint64">func poolSize(Int64)</a></h3>
<pre><code class="language-cangjie">public func poolSize(size: Int64): ClientBuilder
</code></pre>
<p>功能：配置 HTTP/1.1 客户端使用的连接池的大小，亦可表示对同一个主机（host:port）同时存在的连接数的最大值。</p>
<p>参数：</p>
<ul>
<li>size: Int64 - 默认 10，poolSize 需要大于 0。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-clientbuilder">ClientBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-clientbuilder">ClientBuilder</a> 实例的引用。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_exceptions.html#class-httpexception">HttpException</a> - 如果传参小于等于 0，则会抛出该异常。</li>
</ul>
<h3 id="func-readtimeoutduration"><a class="header" href="#func-readtimeoutduration">func readTimeout(Duration)</a></h3>
<pre><code class="language-cangjie">public func readTimeout(timeout: Duration): ClientBuilder
</code></pre>
<p>功能：设定客户端读取一个响应的最大时长。</p>
<p>参数：</p>
<ul>
<li>timeout: Duration - 默认 15s，Duration.Max 代表不限制，如果传入负的 Duration 将被替换为 Duration.Zero。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-clientbuilder">ClientBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-clientbuilder">ClientBuilder</a> 实例的引用。</li>
</ul>
<h3 id="func-tlsconfigtlsclientconfig"><a class="header" href="#func-tlsconfigtlsclientconfig">func tlsConfig(TlsClientConfig)</a></h3>
<pre><code class="language-cangjie">public func tlsConfig(config: TlsClientConfig): ClientBuilder
</code></pre>
<p>功能：设置 TLS 层配置，默认不对其进行设置。</p>
<p>参数：</p>
<ul>
<li>config: <a href="net/http/http_package_api/../../tls/tls_package_api/tls_package_structs.html#struct-tlsclientconfig">TlsClientConfig</a> - 设定支持 tls 客户端需要的配置信息。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-clientbuilder">ClientBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-clientbuilder">ClientBuilder</a> 实例的引用。</li>
</ul>
<h3 id="func-writetimeoutduration"><a class="header" href="#func-writetimeoutduration">func writeTimeout(Duration)</a></h3>
<pre><code class="language-cangjie">public func writeTimeout(timeout: Duration): ClientBuilder
</code></pre>
<p>功能：设定客户端发送一个请求的最大时长。</p>
<p>参数：</p>
<ul>
<li>timeout: Duration - 默认 15 秒，Duration.Max 代表不限制，如果传入负的 Duration 将被替换为 Duration.Zero。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-clientbuilder">ClientBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-clientbuilder">ClientBuilder</a> 实例的引用。</li>
</ul>
<h2 id="class-cookie"><a class="header" href="#class-cookie">class Cookie</a></h2>
<pre><code class="language-cangjie">public class Cookie {
    public init(name: String, value: String, expires!: ?DateTime = None, maxAge!: ?Int64 = None,
        domain!: String = &quot;&quot;, path!: String = &quot;&quot;, secure!: Bool = false, httpOnly!: Bool = false)
}
</code></pre>
<p>功能：HTTP 本身是无状态的，server 为了知道 client 的状态，提供个性化的服务，便可以通过 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 来维护一个有状态的会话。</p>
<blockquote>
<p><strong>说明：</strong></p>
<ul>
<li>用户首次访问某站点时，server 通过 <code>Set-Cookie</code> header 将 name/value 对，以及 attribute-value 传给用户代理；用户代理随后对该站点的请求中便可以将 name/value 加入到 Cookie header 中；</li>
<li><a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 类提供了构建 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 对象，并将 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 对象转成 <code>Set-Cookie</code> header 值的函数，提供了获取 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 对象各属性值的函数；</li>
<li><a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 的各个属性的要求和作用见 <a href="https://httpwg.org/specs/rfc6265.html">RFC 6265</a>；</li>
<li>下文中 cookie-name，cookie-value，expires-av 等名字采用 <a href="https://httpwg.org/specs/rfc6265.html">RFC 6265</a> 中的术语，详情请见协议。</li>
</ul>
</blockquote>
<h3 id="prop-cookiename"><a class="header" href="#prop-cookiename">prop cookieName</a></h3>
<pre><code class="language-cangjie">public prop cookieName: String
</code></pre>
<p>功能：获取 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 对象的 cookie-name 值。</p>
<p>类型：String</p>
<h3 id="prop-cookievalue"><a class="header" href="#prop-cookievalue">prop cookieValue</a></h3>
<pre><code class="language-cangjie">public prop cookieValue: String
</code></pre>
<p>功能：获取 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 对象的 cookie-value 值。</p>
<p>类型：String</p>
<h3 id="prop-domain"><a class="header" href="#prop-domain">prop domain</a></h3>
<pre><code class="language-cangjie">public prop domain: String
</code></pre>
<p>功能：获取 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 对象的 domain-av 值。</p>
<p>类型：String</p>
<h3 id="prop-expires"><a class="header" href="#prop-expires">prop expires</a></h3>
<pre><code class="language-cangjie">public prop expires: ?DateTime
</code></pre>
<p>功能：获取 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 对象的 expires-av 值。</p>
<p>类型：?DateTime</p>
<h3 id="prop-httponly"><a class="header" href="#prop-httponly">prop httpOnly</a></h3>
<pre><code class="language-cangjie">public prop httpOnly: Bool
</code></pre>
<p>功能：获取 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 对象的 httpOnly-av 值。</p>
<p>类型：Bool</p>
<h3 id="prop-maxage"><a class="header" href="#prop-maxage">prop maxAge</a></h3>
<pre><code class="language-cangjie">public prop maxAge: ?Int64
</code></pre>
<p>功能：获取 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 对象的 max-age-av 值。</p>
<p>类型：?Int64</p>
<h3 id="prop-others"><a class="header" href="#prop-others">prop others</a></h3>
<pre><code class="language-cangjie">public prop others: ArrayList&lt;String&gt;
</code></pre>
<p>功能：获取未被解析的属性。</p>
<p>类型：ArrayList&lt;String&gt;</p>
<h3 id="prop-path-1"><a class="header" href="#prop-path-1">prop path</a></h3>
<pre><code class="language-cangjie">public prop path: String
</code></pre>
<p>功能：获取 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 对象的 path-av 值。</p>
<p>类型：String</p>
<h3 id="prop-secure"><a class="header" href="#prop-secure">prop secure</a></h3>
<pre><code class="language-cangjie">public prop secure: Bool
</code></pre>
<p>功能：获取 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 对象的 secure-av 值。</p>
<p>类型：Bool</p>
<h3 id="initstring-string-datetime-int64-string-string-bool-bool"><a class="header" href="#initstring-string-datetime-int64-string-string-bool-bool">init(String, String, ?DateTime, ?Int64, String, String, Bool, Bool)</a></h3>
<pre><code class="language-cangjie">public init(name: String, value: String, expires!: ?DateTime = None, maxAge!: ?Int64 = None,
    domain!: String = &quot;&quot;, path!: String = &quot;&quot;, secure!: Bool = false, httpOnly!: Bool = false)
</code></pre>
<p>功能：提供 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 对象的公开构造器说明：该构造器会检查传入的各项属性是否满足协议要求，如果不满足则会产生 IllegalArgumentException。具体要求见 <a href="https://httpwg.org/specs/rfc6265.html#sane-set-cookie-syntax">RFC 6265 4.1.1.</a>。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p><a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 各属性中只有 cookie-name，cookie-value 是必需的，必须传入 name，value 参数，但 value 参数可以传入空字符串。</p>
</blockquote>
<p>参数：</p>
<ul>
<li>
<p>name: String - cookie-name 属性。</p>
<pre><code class="language-cangjie">name         = token 
token        = 1*tchar
tchar        = &quot;!&quot; / &quot;#&quot; / &quot;$&quot; / &quot;%&quot; / &quot;&amp;&quot; / &quot;'&quot; / &quot;*&quot;
               / &quot;+&quot; / &quot;-&quot; / &quot;.&quot; / &quot;^&quot; / &quot;_&quot; / &quot;`&quot; / &quot;|&quot; / &quot;~&quot;
               / DIGIT / ALPHA
</code></pre>
</li>
<li>
<p>value: String - cookie-value 属性。</p>
<pre><code class="language-cangjie">value        = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
cookie-octet = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
            ; US-ASCII characters excluding CTLs,
            ; whitespace DQUOTE, comma, semicolon,
            ; and backslash
</code></pre>
</li>
<li>
<p>expires!: ?DateTime - 设置 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 的过期时间，默认为 None，时间必须在 1601 年之后。</p>
</li>
<li>
<p>maxAge!: ?Int64 - <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 的最大生命周期，默认为 None，如果 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 既有 expires 属性，也有 maxAge，则表示该 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 只维护到会话结束（维护到 <a href="net/http/http_package_api/http_package_classes.html#class-client">Client</a> 关闭之前，<a href="net/http/http_package_api/http_package_classes.html#class-client">Client</a> 关闭之后设置了过期的 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 也不再维护）。</p>
<pre><code class="language-cangjie">max-age-av     = &quot;Max-Age=&quot; non-zero-digit *DIGIT
non-zero-digit = %x31-39
                ; digits 1 through 9
DIGIT          = %x30-39
                ; digits 0 through 9
</code></pre>
</li>
<li>
<p>domain!: String - 默认为空字符串，表示该收到该 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 的客户端只会发送该 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 给原始服务器。如果设置了合法的 domain，则收到该 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 的客户端只会发送该 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 给所有该 domain 的子域（且满足其他属性条件要求才会发）。</p>
<pre><code class="language-cangjie">domain          = &lt;subdomain&gt; | &quot; &quot;
&lt;subdomain&gt;   ::= &lt;label&gt; | &lt;subdomain&gt; &quot;.&quot; &lt;label&gt;
&lt;label&gt;       ::= &lt;letter&gt; [ [ &lt;ldh-str&gt; ] &lt;let-dig&gt; ]
&lt;ldh-str&gt;     ::= &lt;let-dig-hyp&gt; | &lt;let-dig-hyp&gt; &lt;ldh-str&gt;
&lt;let-dig-hyp&gt; ::= &lt;let-dig&gt; | &quot;-&quot;
&lt;let-dig&gt;     ::= &lt;letter&gt; | &lt;digit&gt;
&lt;letter&gt;      ::= any one of the 52 alphabetic characters A through Z in upper case and a through z in lower case
&lt;digit&gt;       ::= any one of the ten digits 0 through 9
RFC 1035 2.3.1.
而 RFC 1123 2.1. 放松了对 label 首字符必须是 letter 的限制
因此，对 domain 的要求为：
1、总长度小于等于 255，由若干个 label 组成
2、label 与 label 之间通过 &quot;.&quot; 分隔，每个 label 长度小于等于 63
3、label 的开头和结尾必须是数字或者字母，label 的中间字符必须是数字、字母或者 &quot;-&quot;
</code></pre>
</li>
<li>
<p>path!: String - 默认为空字符串，客户端会根据 url 计算出默认的 path 属性，见 RFC 6265 5.1.4.。 收到该 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 的客户端只会发送该 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 给所有该 path 的子目录（且满足其他属性条件要求才会发）。</p>
<pre><code class="language-cangjie">path            = &lt;any RUNE except CTLs or &quot;;&quot;&gt;
RUNE            = &lt;any [USASCII] character&gt;
CTLs            = &lt;controls&gt;
</code></pre>
</li>
<li>
<p>secure!: Bool - 默认为 false，如果设置为 true，该 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 只会在安全协议请求中发送。</p>
</li>
<li>
<p>httpOnly!: Bool - 默认为 false，如果设置为 true，该 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 只会在 HTTP 协议请求中发送。</p>
</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 传入的参数不符合协议要求时抛出异常。</li>
</ul>
<h3 id="func-tosetcookiestring"><a class="header" href="#func-tosetcookiestring">func toSetCookieString()</a></h3>
<pre><code class="language-cangjie">public func toSetCookieString(): String
</code></pre>
<p>功能：提供将 <a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 转成字符串形式的函数，方便 server 设置 <code>Set-Cookie</code> header。</p>
<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 各属性（包含 name，value）在对象创建时就被检查了，因此 toSetCookieString() 函数不会产生异常；</li>
<li><a href="net/http/http_package_api/http_package_classes.html#class-cookie">Cookie</a> 必需的属性是 cookie-pair 即 cookie-name &quot;=&quot; cookie-value，cookie-value 可以为空字符串，toSetCookieString() 函数只会将设置过的属性写入字符串，即只有 &quot;cookie-name=&quot; 是必有的，其余部分是否存在取决于是否设置。</li>
</ul>
</blockquote>
<p>返回值：</p>
<ul>
<li>String - 字符串对象，用于设置 <code>Set-Cookie</code> header。</li>
</ul>
<h2 id="class-filehandler"><a class="header" href="#class-filehandler">class FileHandler</a></h2>
<pre><code class="language-cangjie">public class FileHandler &lt;: HttpRequestHandler {
    public init(path: String, handlerType!: FileHandlerType = DownLoad, bufferSize!: Int64 = 64 * 1024)
}
</code></pre>
<p>功能：用于处理文件下载或者文件上传。</p>
<p>文件下载：</p>
<ul>
<li>构造 <a href="net/http/http_package_api/http_package_classes.html#class-filehandler">FileHandler</a> 时需要传入待下载文件的路径，目前一个 <a href="net/http/http_package_api/http_package_classes.html#class-filehandler">FileHandler</a> 只能处理一个文件的下载；</li>
<li>下载文件只能使用 GET 请求，其他请求返回 400 状态码；</li>
<li>文件如果不存在，将返回 404 状态码。</li>
</ul>
<p>文件上传：</p>
<ul>
<li>构造 <a href="net/http/http_package_api/http_package_classes.html#class-filehandler">FileHandler</a> 时需要传入一个存在的目录路径，上传到服务端的文件将保存在这个目录中；</li>
<li>上传文件时只能使用 POST 请求，其他请求返回 400 状态码；</li>
<li>上传数据的 http 报文必须是 <code>multipart/form-data</code> 格式的，<code>Content-Type</code> 头字段的值为 <code>multipart/form-data; boundary=----XXXXX</code>；</li>
<li>上传文件的文件名存放在 <code>form-data</code> 数据报文中，报文数据格式为 <code>Content-Disposition: form-data; name=&quot;xxx&quot;; filename=&quot;xxxx&quot;</code>，文件名是 <code>filename</code> 字段的值；</li>
<li>目前 form-data 中必须包含 filename 字段；</li>
<li>如果请求报文不正确，将返回 400 状态码；</li>
<li>如果出现其他异常，例如文件处理异常，将返回 500 状态码。</li>
</ul>
<p>父类型：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_interfaces.html#interface-httprequesthandler">HttpRequestHandler</a></li>
</ul>
<h3 id="initstring-filehandlertype-int64"><a class="header" href="#initstring-filehandlertype-int64">init(String, FileHandlerType, Int64)</a></h3>
<pre><code class="language-cangjie">public init(path: String, handlerType!: FileHandlerType = DownLoad, bufferSize!: Int64 = 64 * 1024)
</code></pre>
<p>功能：<a href="net/http/http_package_api/http_package_classes.html#class-filehandler">FileHandler</a> 的构造函数。</p>
<p>参数：</p>
<ul>
<li>path: String - <a href="net/http/http_package_api/http_package_classes.html#class-filehandler">FileHandler</a> 构造时需要传入的文件或者目录路径字符串，上传模式中只能传入存在的目录路径；路径中存在../时，用户需要确认标准化后的绝对路径是期望传入的路径。</li>
<li>handlerType!: <a href="net/http/http_package_api/http_package_enums.html#enum-filehandlertype">FileHandlerType</a> - 构造 <a href="net/http/http_package_api/http_package_classes.html#class-filehandler">FileHandler</a> 时指定当前 <a href="net/http/http_package_api/http_package_classes.html#class-filehandler">FileHandler</a> 的工作模式，默认为 DownLoad 下载模式。</li>
<li>bufferSize!: Int64 - 内部从网络读取或者写入的缓冲区大小，默认值为 64*1024（64k），若小于 4096，则使用 4096 作为缓冲区大小。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_exceptions.html#class-httpexception">HttpException</a> - 当 path 不存在时，抛出异常。</li>
<li>IllegalArgumentException - 参数错误时抛出异常，如 path 为空或者包含空字符串等。</li>
</ul>
<h3 id="func-handlehttpcontext-1"><a class="header" href="#func-handlehttpcontext-1">func handle(HttpContext)</a></h3>
<pre><code class="language-cangjie">public func handle(ctx: HttpContext): Unit
</code></pre>
<p>功能：根据请求对响应数据进行处理。</p>
<p>参数：</p>
<ul>
<li>ctx: <a href="net/http/http_package_api/http_package_classes.html#class-httpcontext">HttpContext</a> - Http 请求上下文。</li>
</ul>
<h2 id="class-funchandler"><a class="header" href="#class-funchandler">class FuncHandler</a></h2>
<pre><code class="language-cangjie">public class FuncHandler &lt;: HttpRequestHandler {
    public FuncHandler(let handler: (HttpContext) -&gt; Unit)
}
</code></pre>
<p>功能：<a href="net/http/http_package_api/http_package_interfaces.html#interface-httprequesthandler">HttpRequestHandler</a> 接口包装类，把单个函数包装成 <a href="net/http/http_package_api/http_package_interfaces.html#interface-httprequesthandler">HttpRequestHandler</a>。</p>
<p>父类型：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_interfaces.html#interface-httprequesthandler">HttpRequestHandler</a></li>
</ul>
<h3 id="funchandlerhttpcontext---unit"><a class="header" href="#funchandlerhttpcontext---unit">FuncHandler((HttpContext) -&gt; Unit)</a></h3>
<pre><code class="language-cangjie">public FuncHandler(let handler: (HttpContext) -&gt; Unit)
</code></pre>
<p>功能：<a href="net/http/http_package_api/http_package_classes.html#class-funchandler">FuncHandler</a> 的构造函数。</p>
<p>参数：</p>
<ul>
<li>handler: (<a href="net/http/http_package_api/http_package_classes.html#class-httpcontext">HttpContext</a>) -&gt; Unit - 是调用 handle 的处理函数。</li>
</ul>
<h3 id="func-handlehttpcontext-2"><a class="header" href="#func-handlehttpcontext-2">func handle(HttpContext)</a></h3>
<pre><code class="language-cangjie">public func handle(ctx: HttpContext): Unit
</code></pre>
<p>功能：处理 Http 请求。</p>
<p>参数：</p>
<ul>
<li>ctx: <a href="net/http/http_package_api/http_package_classes.html#class-httpcontext">HttpContext</a> - Http 请求上下文。</li>
</ul>
<h2 id="class-httpcontext"><a class="header" href="#class-httpcontext">class HttpContext</a></h2>
<pre><code class="language-cangjie">public class HttpContext
</code></pre>
<p>功能：Http 请求上下文，作为 <a href="net/http/http_package_api/http_package_interfaces.html#interface-httprequesthandler">HttpRequestHandler</a>.handle 函数的参数在服务端使用。</p>
<h3 id="prop-clientcertificate"><a class="header" href="#prop-clientcertificate">prop clientCertificate</a></h3>
<pre><code class="language-cangjie">public prop clientCertificate: ?Array&lt;X509Certificate&gt;
</code></pre>
<p>功能：获取 Http 客户端证书。</p>
<p>类型：?Array&lt;<a href="net/http/http_package_api/../../../crypto/x509/x509_package_api/x509_package_classes.html#class-x509certificate">X509Certificate</a>&gt;</p>
<h3 id="prop-request"><a class="header" href="#prop-request">prop request</a></h3>
<pre><code class="language-cangjie">public prop request: HttpRequest
</code></pre>
<p>功能：获取 Http 请求。</p>
<p>类型：<a href="net/http/http_package_api/http_package_classes.html#class-httprequest">HttpRequest</a></p>
<h3 id="prop-responsebuilder"><a class="header" href="#prop-responsebuilder">prop responseBuilder</a></h3>
<pre><code class="language-cangjie">public prop responseBuilder: HttpResponseBuilder
</code></pre>
<p>功能：获取 Http 响应构建器。</p>
<p>类型：<a href="net/http/http_package_api/http_package_classes.html#class-httpresponsebuilder">HttpResponseBuilder</a></p>
<h2 id="class-httpheaders"><a class="header" href="#class-httpheaders">class HttpHeaders</a></h2>
<pre><code class="language-cangjie">public class HttpHeaders &lt;: Iterable&lt;(String, Collection&lt;String&gt;)&gt;
</code></pre>
<p>功能：此类用于表示 Http 报文中的 header 和 trailer，定义了相关增、删、改、查操作。</p>
<blockquote>
<p><strong>说明：</strong></p>
<ul>
<li>header 和 trailer 为键值映射集，由若干 field-line 组成，每一个 field-line 包含一个键 (field -name) 和若干值 (field-value)。</li>
<li>field-name 由 token 字符组成，不区分大小写，在该类中将转为小写保存。</li>
<li>field-value 由 vchar，SP 和 HTAB 组成，vchar 表示可见的 US-ASCII 字符，不得包含前后空格，不得为空值。</li>
<li>详见 <a href="https://www.rfc-editor.org/rfc/rfc9110.html#name-fields">rfc 9110</a>。</li>
</ul>
</blockquote>
<p>示例:</p>
<pre><code class="language-text">Example-Field: Foo, Bar
key: Example-Field, value: Foo, Bar
field-name = token
token = 1*tchar
tchar = &quot;!&quot; / &quot;#&quot; / &quot;$&quot; / &quot;%&quot; / &quot;&amp;&quot; / &quot;'&quot; / &quot;*&quot;
/ &quot;+&quot; / &quot;-&quot; / &quot;.&quot; / &quot;^&quot; / &quot;_&quot; / &quot;`&quot; / &quot;|&quot; / &quot;~&quot;
/ DIGIT / ALPHA
; any VCHAR, except delimiters
</code></pre>
<p>父类型：</p>
<ul>
<li>Iterable&lt;(String, Collection&lt;String&gt;)&gt;</li>
</ul>
<h3 id="func-addstring-string-1"><a class="header" href="#func-addstring-string-1">func add(String, String)</a></h3>
<pre><code class="language-cangjie">public func add(name: String, value: String): Unit
</code></pre>
<p>功能：添加指定键值对。如果 name 已经存在，将在其对应的值列表中添加 value；如果 name 不存在，则添加 name 字段及其值 value。</p>
<p>参数：</p>
<ul>
<li>name: String - <a href="net/http/http_package_api/http_package_classes.html#class-httpheaders">HttpHeaders</a> 的字段名称。</li>
<li>value: String - <a href="net/http/http_package_api/http_package_classes.html#class-httpheaders">HttpHeaders</a> 的字段值。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_exceptions.html#class-httpexception">HttpException</a> - 如果传入的 name/value 包含不合法元素，将抛出此异常。</li>
</ul>
<h3 id="func-delstring"><a class="header" href="#func-delstring">func del(String)</a></h3>
<pre><code class="language-cangjie">public func del(name: String): Unit
</code></pre>
<p>功能：删除指定 name 对应的键值对。</p>
<p>参数：</p>
<ul>
<li>name: String - 删除的字段名称。</li>
</ul>
<h3 id="func-getstring-3"><a class="header" href="#func-getstring-3">func get(String)</a></h3>
<pre><code class="language-cangjie">public func get(name: String): Collection&lt;String&gt;
</code></pre>
<p>功能：获取指定 name 对应的 value 值。</p>
<p>参数：</p>
<ul>
<li>name: String - 字段名称，不区分大小写。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Collection&lt;String&gt; - name 对应的 value 集合，如果指定 name 不存在，返回空集合。</li>
</ul>
<h3 id="func-getfirststring"><a class="header" href="#func-getfirststring">func getFirst(String)</a></h3>
<pre><code class="language-cangjie">public func getFirst(name: String): ?String
</code></pre>
<p>功能：获取指定 name 对应的第一个 value 值。</p>
<p>参数：</p>
<ul>
<li>name: String - 字段名称，不区分大小写。</li>
</ul>
<p>返回值：</p>
<ul>
<li>?String - name 对应的第一个 value 值，如果指定 name 不存在，返回 None。</li>
</ul>
<h3 id="func-isempty-2"><a class="header" href="#func-isempty-2">func isEmpty()</a></h3>
<pre><code class="language-cangjie">public func isEmpty(): Bool
</code></pre>
<p>功能：判断当前实例是否为空，即没有任何键值对。</p>
<p>返回值：</p>
<ul>
<li>Bool - 如果当前实例为空，返回 true，否则返回 false。</li>
</ul>
<h3 id="func-iterator-1"><a class="header" href="#func-iterator-1">func iterator()</a></h3>
<pre><code class="language-cangjie">public func iterator(): Iterator&lt;(String, Collection&lt;String&gt;)&gt;
</code></pre>
<p>功能：获取迭代器，可用于遍历所有键值对。</p>
<p>返回值：</p>
<ul>
<li>Iterator&lt;(String, Collection&lt;String&gt;)&gt; - 该键值集的迭代器。</li>
</ul>
<h3 id="func-setstring-string-1"><a class="header" href="#func-setstring-string-1">func set(String, String)</a></h3>
<pre><code class="language-cangjie">public func set(name: String, value: String): Unit
</code></pre>
<p>功能：设置指定键值对。如果 name 已经存在，传入的 value 将会覆盖之前的值。</p>
<p>参数：</p>
<ul>
<li>name: String - <a href="net/http/http_package_api/http_package_classes.html#class-httpheaders">HttpHeaders</a> 的字段名称。</li>
<li>value: String - <a href="net/http/http_package_api/http_package_classes.html#class-httpheaders">HttpHeaders</a> 的字段值。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_exceptions.html#class-httpexception">HttpException</a> - 如果传入的 name/values 包含不合法元素，将抛出此异常。</li>
</ul>
<h2 id="class-httprequest"><a class="header" href="#class-httprequest">class HttpRequest</a></h2>
<pre><code class="language-cangjie">public class HttpRequest &lt;: ToString
</code></pre>
<p>功能：此类为 Http 请求类。</p>
<p>客户端发送请求时，需要构造一个 <a href="net/http/http_package_api/http_package_classes.html#class-httprequest">HttpRequest</a> 实例，再编码成字节报文发出。</p>
<p>服务端处理请求时，需要把收到的请求解析成 <a href="net/http/http_package_api/http_package_classes.html#class-httprequest">HttpRequest</a> 实例，并传给 handler 处理函数。</p>
<p>父类型：</p>
<ul>
<li>ToString</li>
</ul>
<h3 id="prop-body-1"><a class="header" href="#prop-body-1">prop body</a></h3>
<pre><code class="language-cangjie">public prop body: InputStream
</code></pre>
<p>功能：获取 body。</p>
<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>body 不支持并发读取；</li>
<li>默认 InputStream 实现类的 read 函数不支持多次读取。</li>
</ul>
</blockquote>
<p>类型：InputStream</p>
<h3 id="prop-bodysize"><a class="header" href="#prop-bodysize">prop bodySize</a></h3>
<pre><code class="language-cangjie">public prop bodySize: Option&lt;Int64&gt;
</code></pre>
<p>功能：获取请求 body 长度。</p>
<ul>
<li>如果未设置 body，则 bodySize 为 Some(0)；</li>
<li>如果 body 长度已知，即通过 Array&lt;UInt8&gt; 或 String 传入 body，或传入的 InputStream 有确定的 length (length &gt;= 0)，则 bodySize 为 Some(Int64)；</li>
<li>如果 body 长度未知，即通过用户自定义的 InputStream 实例传入 body 且 InputStream 实例没有确定的 length (length &lt; 0)，则 bodySize 为 None。</li>
</ul>
<p>类型：Option&lt;Int64&gt;</p>
<h3 id="prop-close"><a class="header" href="#prop-close">prop close</a></h3>
<pre><code class="language-cangjie">public prop close: Bool
</code></pre>
<p>功能：表示该请求 header 是否包含 <code>Connection: close</code>。</p>
<ul>
<li>对于服务端，close 为 true 表示处理完该请求应该关闭连接。</li>
<li>对于客户端，close 为 true 表示如果收到响应后服务端未关闭连接，客户端应主动关闭连接。</li>
</ul>
<p>类型：Bool</p>
<h3 id="prop-form"><a class="header" href="#prop-form">prop form</a></h3>
<pre><code class="language-cangjie">public prop form: Form
</code></pre>
<p>功能：获取请求中的表单信息。</p>
<ul>
<li>如果请求方法为 POST，PUT，PATCH，且 content-type 包含 application/x-www-form-urlencoded，获取请求 body 部分，用 form 格式解析；</li>
<li>如果请求方法不为 POST，PUT，PATCH，获取请求 url 中 query 部分。</li>
</ul>
<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>如果用该接口读取了 body，body 已被消费完，后续将无法通过 body.read 读取 body；</li>
<li>如果 form 不符合 <a href="net/http/http_package_api/../../../encoding/url/url_package_api/url_package_classes.html#class-form">Form</a> 格式，抛 <a href="net/http/http_package_api/../../../encoding/url/url_package_api/url_package_exceptions.html#class-urlsyntaxexception">UrlSyntaxException</a> 异常。</li>
</ul>
</blockquote>
<p>类型：<a href="net/http/http_package_api/../../../encoding/url/url_package_api/url_package_classes.html#class-form">Form</a></p>
<h3 id="prop-headers"><a class="header" href="#prop-headers">prop headers</a></h3>
<pre><code class="language-cangjie">public prop headers: HttpHeaders
</code></pre>
<p>功能：获取 headers，headers 详述见 <a href="net/http/http_package_api/http_package_classes.html#class-httpheaders">HttpHeaders</a> 类，获取后，可通过调用 <a href="net/http/http_package_api/http_package_classes.html#class-httpheaders">HttpHeaders</a> 实例成员函数，修改该请求的 headers。</p>
<p>类型：<a href="net/http/http_package_api/http_package_classes.html#class-httpheaders">HttpHeaders</a></p>
<h3 id="prop-method"><a class="header" href="#prop-method">prop method</a></h3>
<pre><code class="language-cangjie">public prop method: String
</code></pre>
<p>功能：获取 method，如 &quot;GET&quot;, &quot;POST&quot;，request 实例的 method 无法修改。</p>
<p>类型：String</p>
<h3 id="prop-readtimeout-1"><a class="header" href="#prop-readtimeout-1">prop readTimeout</a></h3>
<pre><code class="language-cangjie">public prop readTimeout: ?Duration
</code></pre>
<p>功能：表示该请求的请求级读超时时间。None 表示没有设置；Some(Duration) 表示设置了读超时时间。</p>
<p>类型：?Duration</p>
<h3 id="prop-remoteaddr"><a class="header" href="#prop-remoteaddr">prop remoteAddr</a></h3>
<pre><code class="language-cangjie">public prop remoteAddr: String
</code></pre>
<p>功能：用于服务端，获取对端地址，即客户端地址，格式为 ip: port，用户无法设置，自定义的 request 对象调用该属性返回 &quot;&quot;，服务端 handler 中调用该属性返回客户端地址。</p>
<p>类型：String</p>
<h3 id="prop-trailers"><a class="header" href="#prop-trailers">prop trailers</a></h3>
<pre><code class="language-cangjie">public prop trailers: HttpHeaders
</code></pre>
<p>功能：获取 trailers，trailers 详述见 <a href="net/http/http_package_api/http_package_classes.html#class-httpheaders">HttpHeaders</a> 类，获取后，可通过调用 <a href="net/http/http_package_api/http_package_classes.html#class-httpheaders">HttpHeaders</a> 实例成员函数，修改该请求的 trailers。</p>
<p>类型：<a href="net/http/http_package_api/http_package_classes.html#class-httpheaders">HttpHeaders</a></p>
<h3 id="prop-url"><a class="header" href="#prop-url">prop url</a></h3>
<pre><code class="language-cangjie">public prop url: URL
</code></pre>
<p>功能：获取 url，表示客户端访问的 url。</p>
<p>类型：<a href="net/http/http_package_api/../../../encoding/url/url_package_api/url_package_classes.html#class-url">URL</a></p>
<h3 id="prop-version"><a class="header" href="#prop-version">prop version</a></h3>
<pre><code class="language-cangjie">public prop version: Protocol
</code></pre>
<p>功能：获取 http 版本，如 HTTP1_1 和 HTTP2_0，request 实例的 version 无法修改。</p>
<p>类型：<a href="net/http/http_package_api/http_package_enums.html#enum-protocol">Protocol</a></p>
<h3 id="prop-writetimeout-1"><a class="header" href="#prop-writetimeout-1">prop writeTimeout</a></h3>
<pre><code class="language-cangjie">public prop writeTimeout: ?Duration
</code></pre>
<p>功能：表示该请求的请求级写超时时间，None 表示没有设置；Some(Duration) 表示设置了写超时时间。</p>
<p>类型：?Duration</p>
<h3 id="func-tostring-29"><a class="header" href="#func-tostring-29">func toString()</a></h3>
<pre><code class="language-cangjie">public override func toString(): String
</code></pre>
<p>功能：把请求转换为字符串，包括 start line，headers，body size，trailers。
例如：<code>&quot;GET /path HTTP/1.1\r\nhost: www.example.com\r\n\r\nbody size: 5\r\nbar: foo\r\n&quot;</code>。</p>
<p>返回值：</p>
<ul>
<li>String - 请求的字符串表示。</li>
</ul>
<h2 id="class-httprequestbuilder"><a class="header" href="#class-httprequestbuilder">class HttpRequestBuilder</a></h2>
<pre><code class="language-cangjie">public class HttpRequestBuilder {
    public init()
    public init(request: HttpRequest)
}
</code></pre>
<p>功能：<a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> 类用于构造 <a href="net/http/http_package_api/http_package_classes.html#class-httprequest">HttpRequest</a> 实例。</p>
<h3 id="init-20"><a class="header" href="#init-20">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个新 <a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a>。</p>
<h3 id="inithttprequest"><a class="header" href="#inithttprequest">init(HttpRequest)</a></h3>
<pre><code class="language-cangjie">public init(request: HttpRequest)
</code></pre>
<p>功能： 通过 request 构造一个具有 request 属性的 <a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a>。由于 body 成员是一个 InputStream，对原始的 request 的 body 的操作会影响到复制得到的 <a href="net/http/http_package_api/http_package_classes.html#class-httprequest">HttpRequest</a> 的 body。<a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> 的 headers 和 trailers 是入参 request 的深拷贝。其余元素都是入参 request 的浅拷贝（因为是不可变对象，无需深拷贝）。</p>
<p>参数：</p>
<ul>
<li>request: <a href="net/http/http_package_api/http_package_classes.html#class-httprequest">HttpRequest</a> - 传入的 <a href="net/http/http_package_api/http_package_classes.html#class-httprequest">HttpRequest</a> 对象。</li>
</ul>
<h3 id="func-addheadershttpheaders"><a class="header" href="#func-addheadershttpheaders">func addHeaders(HttpHeaders)</a></h3>
<pre><code class="language-cangjie">public func addHeaders(headers: HttpHeaders): HttpRequestBuilder
</code></pre>
<p>功能：向请求 header 添加参数 <a href="net/http/http_package_api/http_package_classes.html#class-httpheaders">HttpHeaders</a> 中的键值对。</p>
<p>参数：</p>
<ul>
<li>headers: <a href="net/http/http_package_api/http_package_classes.html#class-httpheaders">HttpHeaders</a> - 传入的 header 对象。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> 实例的引用。</li>
</ul>
<h3 id="func-addtrailershttpheaders"><a class="header" href="#func-addtrailershttpheaders">func addTrailers(HttpHeaders)</a></h3>
<pre><code class="language-cangjie">public func addTrailers(trailers: HttpHeaders): HttpRequestBuilder
</code></pre>
<p>功能：向请求 trailer 添加参数 <a href="net/http/http_package_api/http_package_classes.html#class-httpheaders">HttpHeaders</a> 中的键值对。</p>
<p>参数：</p>
<ul>
<li>trailers: <a href="net/http/http_package_api/http_package_classes.html#class-httpheaders">HttpHeaders</a> - 传入的 trailer 对象。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> 实例的引用。</li>
</ul>
<h3 id="func-bodyarrayuint8"><a class="header" href="#func-bodyarrayuint8">func body(Array&lt;UInt8&gt;)</a></h3>
<pre><code class="language-cangjie">public func body(body: Array&lt;UInt8&gt;): HttpRequestBuilder
</code></pre>
<p>功能：设置请求 body。如果已经设置过，调用该函数将替换原 body。</p>
<p>参数：</p>
<ul>
<li>body: Array&lt;UInt8&gt; - 字节数组形式的请求体。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> 实例的引用。</li>
</ul>
<h3 id="func-bodyinputstream"><a class="header" href="#func-bodyinputstream">func body(InputStream)</a></h3>
<pre><code class="language-cangjie">public func body(body: InputStream): HttpRequestBuilder
</code></pre>
<p>功能：设置请求 body。如果已经设置过，调用该函数将替换原 body。</p>
<p>参数：</p>
<ul>
<li>body: InputStream - 流形式的请求体。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> 实例的引用。</li>
</ul>
<h3 id="func-bodystring"><a class="header" href="#func-bodystring">func body(String)</a></h3>
<pre><code class="language-cangjie">public func body(body: String): HttpRequestBuilder
</code></pre>
<p>功能：设置请求 body，如果已经设置过，调用该函数将替换原 body调用该函数设置请求 body，则 body 将以内置的 InputStream 实现类表示，其大小已知。</p>
<p>参数：</p>
<ul>
<li>body: String - 字符串形式的请求体。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> 实例的引用。</li>
</ul>
<h3 id="func-build-2"><a class="header" href="#func-build-2">func build()</a></h3>
<pre><code class="language-cangjie">public func build(): HttpRequest
</code></pre>
<p>功能：根据 <a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> 实例生成一个 <a href="net/http/http_package_api/http_package_classes.html#class-httprequest">HttpRequest</a> 实例。</p>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httprequest">HttpRequest</a> - 根据当前 <a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> 实例构造出来的 <a href="net/http/http_package_api/http_package_classes.html#class-httprequest">HttpRequest</a> 实例。</li>
</ul>
<h3 id="func-connect"><a class="header" href="#func-connect">func connect()</a></h3>
<pre><code class="language-cangjie">public func connect(): HttpRequestBuilder
</code></pre>
<p>功能：构造 method 为 &quot;CONNECT&quot; 的请求的便捷函数。</p>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> 实例的引用。</li>
</ul>
<h3 id="func-delete"><a class="header" href="#func-delete">func delete()</a></h3>
<pre><code class="language-cangjie">public func delete(): HttpRequestBuilder
</code></pre>
<p>功能：构造 method 为 &quot;DELETE&quot; 的请求的便捷函数。</p>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> 实例的引用。</li>
</ul>
<h3 id="func-get"><a class="header" href="#func-get">func get()</a></h3>
<pre><code class="language-cangjie">public func get(): HttpRequestBuilder
</code></pre>
<p>功能：构造 method 为 &quot;GET&quot; 的请求的便捷函数。</p>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> 实例的引用。</li>
</ul>
<h3 id="func-head"><a class="header" href="#func-head">func head()</a></h3>
<pre><code class="language-cangjie">public func head(): HttpRequestBuilder
</code></pre>
<p>功能：构造 method 为 &quot;HEAD&quot; 的请求的便捷函数。</p>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> 实例的引用。</li>
</ul>
<h3 id="func-headerstring-string"><a class="header" href="#func-headerstring-string">func header(String, String)</a></h3>
<pre><code class="language-cangjie">public func header(name: String, value: String): HttpRequestBuilder
</code></pre>
<p>功能：向请求 header 添加指定键值对，规则同 <a href="net/http/http_package_api/http_package_classes.html#class-httpheaders">HttpHeaders</a> 类的 add 函数。</p>
<p>参数：</p>
<ul>
<li>name: String - 请求头的 key。</li>
<li>value: String - 请求头的 value。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> 实例的引用。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_exceptions.html#class-httpexception">HttpException</a> - 如果传入的 name 或 value 包含不合法元素，将抛出此异常。</li>
</ul>
<h3 id="func-methodstring"><a class="header" href="#func-methodstring">func method(String)</a></h3>
<pre><code class="language-cangjie">public func method(method: String): HttpRequestBuilder
</code></pre>
<p>功能：设置请求 method，默认请求 method 为 &quot;GET&quot;。</p>
<p>参数：</p>
<ul>
<li>method: String - 请求方法，必须由 token 字符组成，如果传入空字符串，method 值将自动设置为 &quot;GET&quot;。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> 实例的引用。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_exceptions.html#class-httpexception">HttpException</a> - 参数 method 非法时抛出此异常。</li>
</ul>
<h3 id="func-options"><a class="header" href="#func-options">func options()</a></h3>
<pre><code class="language-cangjie">public func options(): HttpRequestBuilder
</code></pre>
<p>功能：构造 method 为 &quot;OPTIONS&quot; 的请求的便捷函数。</p>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> 实例的引用。</li>
</ul>
<h3 id="func-post"><a class="header" href="#func-post">func post()</a></h3>
<pre><code class="language-cangjie">public func post(): HttpRequestBuilder
</code></pre>
<p>功能：构造 method 为 &quot;POST&quot; 的请求的便捷函数。</p>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> 实例的引用。</li>
</ul>
<h3 id="func-priorityint64-bool"><a class="header" href="#func-priorityint64-bool">func priority(Int64, Bool)</a></h3>
<pre><code class="language-cangjie">public func priority(urg: Int64, inc: Bool): HttpRequestBuilder
</code></pre>
<p>功能：设置 priority 头的便捷函数，调用此函数后，将生成 priority 头，形如：&quot;priority: urgency=x, i&quot;。如果通过设置请求头的函数设置了 priority 字段，调用此函数无效。如果多次调用此函数，以最后一次为准。</p>
<p>参数：</p>
<ul>
<li>urg: Int64 - 表示请求优先级，取值范围为 [0, 7]，0 表示最高优先级。</li>
<li>inc: Bool - 表示请求是否需要增量处理，为 true 表示希望服务器并发处理与之同 urg 同 inc 的请求，为 false 表示不希望服务器并发处理。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> 实例的引用。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="net/http/http_package_api/./http_package_exceptions.html#class-httpexception">HttpException</a> - 当参数 urg 取值非法，即不在 [0, 7] 范围内时，抛出异常。</li>
</ul>
<h3 id="func-put"><a class="header" href="#func-put">func put()</a></h3>
<pre><code class="language-cangjie">public func put(): HttpRequestBuilder
</code></pre>
<p>功能：构造 method 为 &quot;PUT&quot; 的请求的便捷函数。</p>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> 实例的引用。</li>
</ul>
<h3 id="func-readtimeoutduration-1"><a class="header" href="#func-readtimeoutduration-1">func readTimeout(Duration)</a></h3>
<pre><code class="language-cangjie">public func readTimeout(timeout: Duration): HttpRequestBuilder
</code></pre>
<p>功能：设置此请求的读超时时间。如果传入的 Duration 为负，则会自动转为 0。如果用户设置了此读超时时间，那么该请求的读超时以此为准；如果用户没有设置，那么该请求的读超时以 <a href="net/http/http_package_api/http_package_classes.html#class-client">Client</a> 为准。</p>
<p>参数：</p>
<ul>
<li>timeout: Duration - 用户设置的此请求的读超时时间。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> 实例的引用。</li>
</ul>
<h3 id="func-setheadershttpheaders"><a class="header" href="#func-setheadershttpheaders">func setHeaders(HttpHeaders)</a></h3>
<pre><code class="language-cangjie">public func setHeaders(headers: HttpHeaders): HttpRequestBuilder
</code></pre>
<p>功能：设置请求 header，如果已经设置过，调用该函数将替换原 header。</p>
<p>参数：</p>
<ul>
<li>headers: <a href="net/http/http_package_api/http_package_classes.html#class-httpheaders">HttpHeaders</a> - 传入的 header 对象。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> 实例的引用。</li>
</ul>
<h3 id="func-settrailershttpheaders"><a class="header" href="#func-settrailershttpheaders">func setTrailers(HttpHeaders)</a></h3>
<pre><code class="language-cangjie">public func setTrailers(trailers: HttpHeaders): HttpRequestBuilder
</code></pre>
<p>功能：设置请求 trailer，如果已经设置过，调用该函数将替换原 trailer。</p>
<p>参数：</p>
<ul>
<li>trailers: <a href="net/http/http_package_api/http_package_classes.html#class-httpheaders">HttpHeaders</a> - 传入的 trailer 对象。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> 实例的引用。</li>
</ul>
<h3 id="func-trace"><a class="header" href="#func-trace">func trace()</a></h3>
<pre><code class="language-cangjie">public func trace(): HttpRequestBuilder
</code></pre>
<p>功能：构造 method 为 &quot;TRACE&quot; 的请求的便捷函数。</p>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> 实例的引用。</li>
</ul>
<h3 id="func-trailerstring-string"><a class="header" href="#func-trailerstring-string">func trailer(String, String)</a></h3>
<pre><code class="language-cangjie">public func trailer(name: String, value: String): HttpRequestBuilder
</code></pre>
<p>功能：向请求 trailer 添加指定键值对，规则同 <a href="net/http/http_package_api/http_package_classes.html#class-httpheaders">HttpHeaders</a> 类的 add 函数。</p>
<p>参数：</p>
<ul>
<li>name: String - 请求头的 key。</li>
<li>value: String - 请求头的 value。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> 实例的引用。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_exceptions.html#class-httpexception">HttpException</a> - 如果传入的 name 或 value 包含不合法元素，将抛出此异常。</li>
</ul>
<h3 id="func-urlstring"><a class="header" href="#func-urlstring">func url(String)</a></h3>
<pre><code class="language-cangjie">public func url(rawUrl: String): HttpRequestBuilder
</code></pre>
<p>功能：设置请求 url，默认 url 为空的 <a href="net/http/http_package_api/../../../encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 对象。</p>
<p>参数：</p>
<ul>
<li>rawUrl: String - 待解析成 url 对象的字符串，该字符串格式详见 <a href="net/http/http_package_api/../../../encoding/url/url_package_api/url_package_classes.html#static-func-parsestring">URL.parse</a> 函数。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> 实例的引用。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 当被编码的字符不符合 UTF8 的字节序列规则时，抛出异常。</li>
<li><a href="net/http/http_package_api/../../../encoding/url/url_package_api/url_package_exceptions.html#class-urlsyntaxexception">UrlSyntaxException</a> - 当传入字符串不符合 <a href="net/http/http_package_api/../../../encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 格式时，抛出异常。</li>
</ul>
<h3 id="func-urlurl"><a class="header" href="#func-urlurl">func url(URL)</a></h3>
<pre><code class="language-cangjie">public func url(url: URL): HttpRequestBuilder
</code></pre>
<p>功能：设置请求 url，默认 url 为空的 <a href="net/http/http_package_api/../../../encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 对象，即 <a href="net/http/http_package_api/../../../encoding/url/url_package_api/url_package_classes.html#class-url">URL</a>.parse(&quot;&quot;)。</p>
<p>参数：</p>
<ul>
<li>url: <a href="net/http/http_package_api/../../../encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> - URL 对象。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> 实例的引用。</li>
</ul>
<h3 id="func-versionprotocol"><a class="header" href="#func-versionprotocol">func version(Protocol)</a></h3>
<pre><code class="language-cangjie">public func version(version: Protocol): HttpRequestBuilder
</code></pre>
<p>功能：设置请求的 http 协议版本，默认为 UnknownProtocol(&quot;&quot;)，客户端会根据 tls 配置自动选择协议。</p>
<p>参数：</p>
<ul>
<li>version: <a href="net/http/http_package_api/http_package_enums.html#enum-protocol">Protocol</a> - 协议版本。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> 实例的引用。</li>
</ul>
<h3 id="func-writetimeoutduration-1"><a class="header" href="#func-writetimeoutduration-1">func writeTimeout(Duration)</a></h3>
<pre><code class="language-cangjie">public func writeTimeout(timeout: Duration): HttpRequestBuilder
</code></pre>
<p>功能：设置此请求的写超时时间。如果传入的 Duration 为负，则会自动转为 0。如果用户设置了此写超时时间，那么该请求的写超时以此为准；如果用户没有设置，那么该请求的写超时以 <a href="net/http/http_package_api/http_package_classes.html#class-client">Client</a> 为准。</p>
<p>参数：</p>
<ul>
<li>timeout: Duration - 用户设置的此请求的写超时时间。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-httprequestbuilder">HttpRequestBuilder</a> 实例的引用。</li>
</ul>
<h2 id="class-httpresponse"><a class="header" href="#class-httpresponse">class HttpResponse</a></h2>
<pre><code class="language-cangjie">public class HttpResponse &lt;: ToString
</code></pre>
<p>功能：Http 响应类。</p>
<p>此类定义了 http 中响应 Response 的相关接口，客户端用该类读取服务端返回的响应。</p>
<p>父类型：</p>
<ul>
<li>ToString</li>
</ul>
<h3 id="prop-body-2"><a class="header" href="#prop-body-2">prop body</a></h3>
<pre><code class="language-cangjie">public prop body: InputStream
</code></pre>
<p>功能：获取 body。</p>
<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>body 不支持并发读取；</li>
<li>默认 InputStream 实现类的 read 函数不支持多次读取。</li>
</ul>
</blockquote>
<p>类型：InputStream</p>
<h3 id="prop-bodysize-1"><a class="header" href="#prop-bodysize-1">prop bodySize</a></h3>
<pre><code class="language-cangjie">public prop bodySize: Option&lt;Int64&gt;
</code></pre>
<p>功能：获取响应 body 长度。</p>
<blockquote>
<ul>
<li>如果未设置 body，则 bodySize 为 Some(0)；</li>
<li>如果 body 长度已知，即通过 Array&lt;UInt8&gt; 或 String 传入 body，或传入的 InputStream 有确定的 length (length &gt;= 0)，则 bodySize 为 Some(Int64)；</li>
<li>如果 body 长度未知，即通过用户自定义的 InputStream 实例传入 body 且 InputStream 实例没有确定的 length (length &lt; 0)，则 bodySize 为 None。</li>
</ul>
</blockquote>
<p>类型：Option&lt;Int64&gt;</p>
<h3 id="prop-close-1"><a class="header" href="#prop-close-1">prop close</a></h3>
<pre><code class="language-cangjie">public prop close: Bool
</code></pre>
<p>功能：表示该响应 header 是否包含 Connection: close。</p>
<p>对于服务端，close 为 true 表示处理完该请求应该关闭连接；</p>
<p>对于客户端，close 为 true 表示如果收到响应后服务端未关闭连接，客户端应主动关闭连接。</p>
<p>类型：Bool</p>
<h3 id="prop-headers-1"><a class="header" href="#prop-headers-1">prop headers</a></h3>
<pre><code class="language-cangjie">public prop headers: HttpHeaders
</code></pre>
<p>功能：获取 headers，headers 详述见 <a href="net/http/http_package_api/http_package_classes.html#class-httpheaders">HttpHeaders</a> 类，获取后，可通过调用 <a href="net/http/http_package_api/http_package_classes.html#class-httpheaders">HttpHeaders</a> 实例成员函数，修改该请求的 headers。</p>
<p>类型：<a href="net/http/http_package_api/http_package_classes.html#class-httpheaders">HttpHeaders</a></p>
<h3 id="prop-request-1"><a class="header" href="#prop-request-1">prop request</a></h3>
<pre><code class="language-cangjie">public prop request: Option&lt;HttpRequest&gt;
</code></pre>
<p>功能：获取该响应对应的请求，默认为 None。</p>
<p>类型：Option&lt;<a href="net/http/http_package_api/http_package_classes.html#class-httprequest">HttpRequest</a>&gt;</p>
<h3 id="prop-status"><a class="header" href="#prop-status">prop status</a></h3>
<pre><code class="language-cangjie">public prop status: UInt16
</code></pre>
<p>功能：获取响应的状态码，默认值为 200。状态码由 100~599 的三位数字组成，状态码所反映的具体信息可参考 <a href="https://httpwg.org/specs/rfc9110.html#status.codes">RFC 9110</a>。</p>
<p>类型：UInt16</p>
<h3 id="prop-trailers-1"><a class="header" href="#prop-trailers-1">prop trailers</a></h3>
<pre><code class="language-cangjie">public prop trailers: HttpHeaders
</code></pre>
<p>功能：获取 trailers，trailers 详述见 <a href="net/http/http_package_api/http_package_classes.html#class-httpheaders">HttpHeaders</a> 类，获取后，可通过调用 <a href="net/http/http_package_api/http_package_classes.html#class-httpheaders">HttpHeaders</a> 实例成员函数，修改该请求的 trailers。</p>
<p>类型：<a href="net/http/http_package_api/http_package_classes.html#class-httpheaders">HttpHeaders</a></p>
<h3 id="prop-version-1"><a class="header" href="#prop-version-1">prop version</a></h3>
<pre><code class="language-cangjie">public prop version: Protocol
</code></pre>
<p>功能：获取响应的协议版本，默认值为 <a href="net/http/http_package_api/./http_package_enums.html#enum-Protocol">HTTP1_1</a>。</p>
<p>类型：<a href="net/http/http_package_api/http_package_enums.html#enum-protocol">Protocol</a></p>
<h3 id="func-tostring-30"><a class="header" href="#func-tostring-30">func toString()</a></h3>
<pre><code class="language-cangjie">public override func toString(): String
</code></pre>
<p>功能：把响应转换为字符串，包括 status-line，headers，body size， trailers。</p>
<p>例如：HTTP/1.1 200 OK\r\ncontent-length: 5\r\n\r\nbody size: 5\r\nbar: foo\r\n。</p>
<p>返回值：</p>
<ul>
<li>String - 响应的字符串表示。</li>
</ul>
<h3 id="extend-httpresponse"><a class="header" href="#extend-httpresponse">extend HttpResponse</a></h3>
<pre><code class="language-cangjie">extend HttpResponse
</code></pre>
<p>功能：为 HttpResonse 扩展 HTTP/2.0 特有的方法。</p>
<h4 id="func-getpush"><a class="header" href="#func-getpush">func getPush()</a></h4>
<pre><code class="language-cangjie">public func getPush(): Option&lt;ArrayList&lt;HttpResponse&gt;&gt;
</code></pre>
<p>功能：获取服务器推送的响应，返回 None 代表未开启服务器推送功能，返回空 ArrayList 代表无服务器推送的响应。</p>
<p>返回值：</p>
<ul>
<li>Option&lt;ArrayList&lt;<a href="net/http/http_package_api/http_package_classes.html#class-httpresponse">HttpResponse</a>&gt;&gt; - 服务器推送的响应列表。</li>
</ul>
<h2 id="class-httpresponsebuilder"><a class="header" href="#class-httpresponsebuilder">class HttpResponseBuilder</a></h2>
<pre><code class="language-cangjie">public class HttpResponseBuilder {
    public init()
}
</code></pre>
<p>功能：用于构造 <a href="net/http/http_package_api/http_package_classes.html#class-httpresponse">HttpResponse</a> 实例。</p>
<h3 id="init-21"><a class="header" href="#init-21">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个新 <a href="net/http/http_package_api/http_package_classes.html#class-httpresponsebuilder">HttpResponseBuilder</a>。</p>
<h3 id="func-addheadershttpheaders-1"><a class="header" href="#func-addheadershttpheaders-1">func addHeaders(HttpHeaders)</a></h3>
<pre><code class="language-cangjie">public func addHeaders(headers: HttpHeaders): HttpResponseBuilder
</code></pre>
<p>功能：向响应 header 添加参数 <a href="net/http/http_package_api/http_package_classes.html#class-httpheaders">HttpHeaders</a> 中的键值对。</p>
<p>参数：</p>
<ul>
<li>headers: <a href="net/http/http_package_api/http_package_classes.html#class-httpheaders">HttpHeaders</a> - 传入的 header 对象。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httpresponsebuilder">HttpResponseBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-httpresponsebuilder">HttpResponseBuilder</a> 实例的引用。</li>
</ul>
<h3 id="func-addtrailershttpheaders-1"><a class="header" href="#func-addtrailershttpheaders-1">func addTrailers(HttpHeaders)</a></h3>
<pre><code class="language-cangjie">public func addTrailers(trailers: HttpHeaders): HttpResponseBuilder
</code></pre>
<p>功能：向响应 trailer 添加参数 <a href="net/http/http_package_api/http_package_classes.html#class-httpheaders">HttpHeaders</a> 中的键值对。</p>
<p>参数：</p>
<ul>
<li>trailers: <a href="net/http/http_package_api/http_package_classes.html#class-httpheaders">HttpHeaders</a> - 传入的 trailer 对象。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httpresponsebuilder">HttpResponseBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-httpresponsebuilder">HttpResponseBuilder</a> 实例的引用。</li>
</ul>
<h3 id="func-bodyarrayuint8-1"><a class="header" href="#func-bodyarrayuint8-1">func body(Array&lt;UInt8&gt;)</a></h3>
<pre><code class="language-cangjie">public func body(body: Array&lt;UInt8&gt;): HttpResponseBuilder
</code></pre>
<p>功能：设置响应 body，如果已经设置过，调用该函数将替换原 body。</p>
<p>参数：</p>
<ul>
<li>body: Array&lt;UInt8&gt; - 字节数组形式的响应体。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httpresponsebuilder">HttpResponseBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-httpresponsebuilder">HttpResponseBuilder</a> 实例的引用。</li>
</ul>
<h3 id="func-bodyinputstream-1"><a class="header" href="#func-bodyinputstream-1">func body(InputStream)</a></h3>
<pre><code class="language-cangjie">public func body(body: InputStream): HttpResponseBuilder
</code></pre>
<p>功能：设置响应 body，如果已经设置过，调用该函数将替换原 body调用该函数设置请求 body。</p>
<p>参数：</p>
<ul>
<li>body: InputStream - 流形式的响应体。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httpresponsebuilder">HttpResponseBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-httpresponsebuilder">HttpResponseBuilder</a> 实例的引用。</li>
</ul>
<h3 id="func-bodystring-1"><a class="header" href="#func-bodystring-1">func body(String)</a></h3>
<pre><code class="language-cangjie">public func body(body: String): HttpResponseBuilder
</code></pre>
<p>功能：设置响应 body，如果已经设置过，调用该函数将替换原 body调用该函数设置请求 body。</p>
<p>参数：</p>
<ul>
<li>body: String - 字符串形式的响应体。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httpresponsebuilder">HttpResponseBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-httpresponsebuilder">HttpResponseBuilder</a> 实例的引用。</li>
</ul>
<h3 id="func-build-3"><a class="header" href="#func-build-3">func build()</a></h3>
<pre><code class="language-cangjie">public func build(): HttpResponse
</code></pre>
<p>功能：根据 <a href="net/http/http_package_api/http_package_classes.html#class-httpresponsebuilder">HttpResponseBuilder</a> 实例生成一个 <a href="net/http/http_package_api/http_package_classes.html#class-httpresponse">HttpResponse</a> 实例。</p>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httpresponse">HttpResponse</a> - 根据当前 <a href="net/http/http_package_api/http_package_classes.html#class-httpresponsebuilder">HttpResponseBuilder</a> 实例构造出来的 <a href="net/http/http_package_api/http_package_classes.html#class-httpresponse">HttpResponse</a> 实例。</li>
</ul>
<h3 id="func-headerstring-string-1"><a class="header" href="#func-headerstring-string-1">func header(String, String)</a></h3>
<pre><code class="language-cangjie">public func header(name: String, value: String): HttpResponseBuilder
</code></pre>
<p>功能：向响应 header 添加指定键值对，规则同 <a href="net/http/http_package_api/http_package_classes.html#class-httpheaders">HttpHeaders</a> 类的 add 函数。</p>
<p>参数：</p>
<ul>
<li>name: String - 响应头的 key。</li>
<li>value: String - 响应头的 value。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httpresponsebuilder">HttpResponseBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-httpresponsebuilder">HttpResponseBuilder</a> 实例的引用。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_exceptions.html#class-httpexception">HttpException</a> - 如果传入的 name 或 value 包含不合法元素，将抛出此异常。</li>
</ul>
<h3 id="func-requesthttprequest"><a class="header" href="#func-requesthttprequest">func request(HttpRequest)</a></h3>
<pre><code class="language-cangjie">public func request(request: HttpRequest): HttpResponseBuilder
</code></pre>
<p>功能：设置响应对应的请求。</p>
<p>参数：</p>
<ul>
<li>request: <a href="net/http/http_package_api/http_package_classes.html#class-httprequest">HttpRequest</a> - 响应对应的请求。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httpresponsebuilder">HttpResponseBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-httpresponsebuilder">HttpResponseBuilder</a> 实例的引用。</li>
</ul>
<h3 id="func-setheadershttpheaders-1"><a class="header" href="#func-setheadershttpheaders-1">func setHeaders(HttpHeaders)</a></h3>
<pre><code class="language-cangjie">public func setHeaders(headers: HttpHeaders): HttpResponseBuilder
</code></pre>
<p>功能：设置响应 header，如果已经设置过，调用该函数将替换原 header。</p>
<p>参数：</p>
<ul>
<li>headers: <a href="net/http/http_package_api/http_package_classes.html#class-httpheaders">HttpHeaders</a> - 传入的 header 对象。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httpresponsebuilder">HttpResponseBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-httpresponsebuilder">HttpResponseBuilder</a> 实例的引用。</li>
</ul>
<h3 id="func-settrailershttpheaders-1"><a class="header" href="#func-settrailershttpheaders-1">func setTrailers(HttpHeaders)</a></h3>
<pre><code class="language-cangjie">public func setTrailers(trailers: HttpHeaders): HttpResponseBuilder
</code></pre>
<p>功能：设置响应 trailer，如果已经设置过，调用该函数将替换原 trailer。</p>
<p>参数：</p>
<ul>
<li>trailers: <a href="net/http/http_package_api/http_package_classes.html#class-httpheaders">HttpHeaders</a> - 传入的 trailer 对象。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httpresponsebuilder">HttpResponseBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-httpresponsebuilder">HttpResponseBuilder</a> 实例的引用。</li>
</ul>
<h3 id="func-statusuint16"><a class="header" href="#func-statusuint16">func status(UInt16)</a></h3>
<pre><code class="language-cangjie">public func status(status: UInt16): HttpResponseBuilder
</code></pre>
<p>功能：设置 http 响应状态码。</p>
<p>参数：</p>
<ul>
<li>status: UInt16 - 传入的状态码的值。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httpresponsebuilder">HttpResponseBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-httpresponsebuilder">HttpResponseBuilder</a> 实例的引用。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_exceptions.html#class-httpexception">HttpException</a> - 如果设置响应状态码不在 100~599 这个区间内，则抛出此异常。</li>
</ul>
<h3 id="func-trailerstring-string-1"><a class="header" href="#func-trailerstring-string-1">func trailer(String, String)</a></h3>
<pre><code class="language-cangjie">public func trailer(name: String, value: String): HttpResponseBuilder
</code></pre>
<p>功能：向响应 trailer 添加指定键值对，规则同 <a href="net/http/http_package_api/http_package_classes.html#class-httpheaders">HttpHeaders</a> 类的 add 函数。</p>
<p>参数：</p>
<ul>
<li>name: String - 响应头的 key。</li>
<li>value: String - 响应头的 value。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httpresponsebuilder">HttpResponseBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-httpresponsebuilder">HttpResponseBuilder</a> 实例的引用。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_exceptions.html#class-httpexception">HttpException</a> - 如果传入的 name 或 value 包含不合法元素，将抛出此异常。</li>
</ul>
<h3 id="func-versionprotocol-1"><a class="header" href="#func-versionprotocol-1">func version(Protocol)</a></h3>
<pre><code class="language-cangjie">public func version(version: Protocol): HttpResponseBuilder
</code></pre>
<p>功能：设置 http 响应协议版本。</p>
<p>参数：</p>
<ul>
<li>version: <a href="net/http/http_package_api/http_package_enums.html#enum-protocol">Protocol</a> - 协议版本。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-httpresponsebuilder">HttpResponseBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-httpresponsebuilder">HttpResponseBuilder</a> 实例的引用。</li>
</ul>
<h2 id="class-httpresponsepusher"><a class="header" href="#class-httpresponsepusher">class HttpResponsePusher</a></h2>
<pre><code class="language-cangjie">public class HttpResponsePusher
</code></pre>
<p>功能：HTTP/2 服务器推送。</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>如果服务器收到请求后，认为客户端后续还需要某些关联资源，可以将其提前推送到客户端；
服务端推送包括推送请求和推送响应；
启用服务端推送需要先调用 push 函数发送推送请求，并向服务器注册该请求对应的 handler，用以生成推送响应；
客户端可设置拒绝服务端推送；
不允许嵌套推送，即不允许在推送请求对应的 handler 中再次推送。嵌套推送情况下，服务端将不执行推送，并打印日志进行提示。</p>
</blockquote>
<h3 id="static-func-getpusherhttpcontext"><a class="header" href="#static-func-getpusherhttpcontext">static func getPusher(HttpContext)</a></h3>
<pre><code class="language-cangjie">public static func getPusher(ctx: HttpContext): ?HttpResponsePusher
</code></pre>
<p>功能：获取 <a href="net/http/http_package_api/http_package_classes.html#class-httpresponsepusher">HttpResponsePusher</a> 实例，如果客户端拒绝推送，将返回 None。</p>
<p>参数：</p>
<ul>
<li>ctx: <a href="net/http/http_package_api/http_package_classes.html#class-httpcontext">HttpContext</a> - Http 请求上下文。</li>
</ul>
<p>返回值：</p>
<ul>
<li>?<a href="net/http/http_package_api/http_package_classes.html#class-httpresponsepusher">HttpResponsePusher</a> - 获得的 <a href="net/http/http_package_api/http_package_classes.html#class-httpresponsepusher">HttpResponsePusher</a>。</li>
</ul>
<h3 id="func-pushstring-string-httpheaders"><a class="header" href="#func-pushstring-string-httpheaders">func push(String, String, HttpHeaders)</a></h3>
<pre><code class="language-cangjie">public func push(path: String, method: String, header: HttpHeaders): Unit
</code></pre>
<p>功能：向客户端发送推送请求，path 为请求地址，method 为请求方法，header 为请求头。</p>
<p>参数：</p>
<ul>
<li>path: String - 推送的请求地址。</li>
<li>method: String - 推送的请求方法。</li>
<li>header: <a href="net/http/http_package_api/http_package_classes.html#class-httpheaders">HttpHeaders</a> - 推送的请求头。</li>
</ul>
<h2 id="class-httpresponsewriter"><a class="header" href="#class-httpresponsewriter">class HttpResponseWriter</a></h2>
<pre><code class="language-cangjie">public class HttpResponseWriter {
    public HttpResponseWriter(let ctx: HttpContext)
}
</code></pre>
<p>功能：HTTP response 消息体 Writer，支持用户控制消息体的发送过程。</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>第一次调用 write 函数时，将立即发送 header 和通过参数传入的 body，此后每次调用 write，发送通过参数传入的 body。
对于 HTTP/1.1，如果设置了 transfer-encoding: chunked，用户每调用一次 write，将发送一个 chunk。
对于 HTTP/2，用户每调用一次 write，将把指定数据封装并发出。</p>
</blockquote>
<h3 id="httpresponsewriterhttpcontext"><a class="header" href="#httpresponsewriterhttpcontext">HttpResponseWriter(HttpContext)</a></h3>
<pre><code class="language-cangjie">public HttpResponseWriter(let ctx: HttpContext)
</code></pre>
<p>功能：构造一个 <a href="net/http/http_package_api/http_package_classes.html#class-httpresponsewriter">HttpResponseWriter</a> 实例。</p>
<p>参数：</p>
<ul>
<li>ctx: <a href="net/http/http_package_api/http_package_classes.html#class-httpcontext">HttpContext</a> - Http 请求上下文。</li>
</ul>
<h3 id="func-writearraybyte-10"><a class="header" href="#func-writearraybyte-10">func write(Array&lt;Byte&gt;)</a></h3>
<pre><code class="language-cangjie">public func write(buf: Array&lt;Byte&gt;): Unit
</code></pre>
<p>功能：发送 buf 中数据到客户端。</p>
<p>参数：</p>
<ul>
<li>buf: Array&lt;Byte&gt; - 要发送的数据。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_exceptions.html#class-httpexception">HttpException</a> - 请求方法为 &quot;HEAD&quot; 或响应状态码为 &quot;1XX\204\304&quot;。</li>
<li><a href="net/http/http_package_api/http_package_exceptions.html#class-httpexception">HttpException</a> - 连接关闭。</li>
<li><a href="net/http/http_package_api/http_package_exceptions.html#class-httpexception">HttpException</a> - response 协议版本为 HTTP/1.0。</li>
<li><a href="net/http/http_package_api/http_package_exceptions.html#class-httpexception">HttpException</a> - 响应连接已升级为 <a href="net/http/http_package_api/http_package_classes.html#class-websocket">WebSocket</a>。</li>
</ul>
<h2 id="class-notfoundhandler"><a class="header" href="#class-notfoundhandler">class NotFoundHandler</a></h2>
<pre><code class="language-cangjie">public class NotFoundHandler &lt;: HttpRequestHandler
</code></pre>
<p>功能：便捷的 Http 请求处理器，<code>404 Not Found</code> 处理器。</p>
<p>父类型：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_interfaces.html#interface-httprequesthandler">HttpRequestHandler</a></li>
</ul>
<h3 id="func-handlehttpcontext-3"><a class="header" href="#func-handlehttpcontext-3">func handle(HttpContext)</a></h3>
<pre><code class="language-cangjie">public func handle(ctx: HttpContext): Unit
</code></pre>
<p>功能：处理 Http 请求，回复 404 响应。</p>
<p>参数：</p>
<ul>
<li>ctx: <a href="net/http/http_package_api/http_package_classes.html#class-httpcontext">HttpContext</a> - Http 请求上下文。</li>
</ul>
<h2 id="class-optionshandler"><a class="header" href="#class-optionshandler">class OptionsHandler</a></h2>
<pre><code class="language-cangjie">public class OptionsHandler &lt;: HttpRequestHandler
</code></pre>
<p>功能：便捷的 Http 处理器，用于处理 OPTIONS 请求。固定返回 &quot;Allow: OPTIONS，GET，HEAD，POST，PUT，DELETE&quot; 响应头。</p>
<p>父类型：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_interfaces.html#interface-httprequesthandler">HttpRequestHandler</a></li>
</ul>
<h3 id="func-handlehttpcontext-4"><a class="header" href="#func-handlehttpcontext-4">func handle(HttpContext)</a></h3>
<pre><code class="language-cangjie">public func handle(ctx: HttpContext): Unit
</code></pre>
<p>功能：处理 Http OPTIONS 请求。</p>
<p>参数：</p>
<ul>
<li>ctx: <a href="net/http/http_package_api/http_package_classes.html#class-httpcontext">HttpContext</a> - Http 请求上下文。</li>
</ul>
<h2 id="class-protocolservice"><a class="header" href="#class-protocolservice">class ProtocolService</a></h2>
<pre><code class="language-cangjie">public abstract class ProtocolService
</code></pre>
<p>功能：Http 协议服务实例，为单个客户端连接提供 Http 服务，包括对客户端 request 报文的解析、 request 的分发处理、 response 的发送等。</p>
<h3 id="prop-server"><a class="header" href="#prop-server">prop server</a></h3>
<pre><code class="language-cangjie">open protected mut prop server: Server
</code></pre>
<p>功能：返回 <a href="net/http/http_package_api/http_package_classes.html#class-server">Server</a> 实例，提供默认实现，设置为绑定的 <a href="net/http/http_package_api/http_package_classes.html#class-server">Server</a> 实例</p>
<h3 id="func-serve"><a class="header" href="#func-serve">func serve()</a></h3>
<pre><code class="language-cangjie">protected func serve(): Unit
</code></pre>
<p>功能：处理来自客户端连接的请求，不提供默认实现。</p>
<h3 id="func-closegracefully"><a class="header" href="#func-closegracefully">func closeGracefully()</a></h3>
<pre><code class="language-cangjie">open protected func closeGracefully(): Unit
</code></pre>
<p>功能：优雅关闭连接，提供默认实现，无任何行为。</p>
<h3 id="func-close-9"><a class="header" href="#func-close-9">func close()</a></h3>
<pre><code class="language-cangjie">open protected func close(): Unit
</code></pre>
<p>功能：强制关闭连接，提供默认实现，无任何行为。</p>
<h2 id="class-redirecthandler"><a class="header" href="#class-redirecthandler">class RedirectHandler</a></h2>
<pre><code class="language-cangjie">public class RedirectHandler &lt;: HttpRequestHandler {
    public init(url: String, code: UInt16)
}
</code></pre>
<p>功能：便捷的 Http 处理器，用于回复重定向响应。</p>
<p>父类型：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_interfaces.html#interface-httprequesthandler">HttpRequestHandler</a></li>
</ul>
<h3 id="initstring-uint16"><a class="header" href="#initstring-uint16">init(String, UInt16)</a></h3>
<pre><code class="language-cangjie">public init(url: String, code: UInt16)
</code></pre>
<p>功能：<a href="net/http/http_package_api/http_package_classes.html#class-redirecthandler">RedirectHandler</a> 的构造函数。</p>
<p>参数：</p>
<ul>
<li>url: String - 重定向响应中 Location 头部的 url。</li>
<li>code: UInt16 - 重定向响应的响应码。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_exceptions.html#class-httpexception">HttpException</a> - url 为空或响应码不是除 304 以外的 3XX 状态码时抛出异常。</li>
</ul>
<h3 id="func-handlehttpcontext-5"><a class="header" href="#func-handlehttpcontext-5">func handle(HttpContext)</a></h3>
<pre><code class="language-cangjie">public func handle(ctx: HttpContext): Unit
</code></pre>
<p>功能：处理 Http 请求，回复重定向响应。</p>
<p>参数：</p>
<ul>
<li>ctx: <a href="net/http/http_package_api/http_package_classes.html#class-httpcontext">HttpContext</a> - Http 请求上下文。</li>
</ul>
<h2 id="class-server"><a class="header" href="#class-server">class Server</a></h2>
<pre><code class="language-cangjie">public class Server
</code></pre>
<p>功能：提供 HTTP 服务的 <a href="net/http/http_package_api/http_package_classes.html#class-server">Server</a> 类。</p>
<blockquote>
<p><strong>说明：</strong></p>
<ul>
<li>启动服务，在指定地址及端口等待用户连接、服务用户的 http request；</li>
<li>关闭服务，包括关闭所有已有连接；</li>
<li>提供注册处理 http request 的 handler 的机制，根据注册信息分发 request 到相应的 handler；</li>
<li>提供 tls 证书热机制；</li>
<li>提供 shutdown 回调机制；</li>
<li>通过 <a href="net/http/http_package_api/../../../log/log_package_api/log_package_classes.html#class-logger">Logger</a>.level 开启、关闭日志打印，包括按照用户要求打印相应级别的日志；</li>
<li><a href="net/http/http_package_api/http_package_classes.html#class-server">Server</a> 文档中未明确说明支持版本的配置，在 HTTP/1.1 与 HTTP/2 都会生效。</li>
</ul>
</blockquote>
<h3 id="prop-addr"><a class="header" href="#prop-addr">prop addr</a></h3>
<pre><code class="language-cangjie">public prop addr: String
</code></pre>
<p>功能：获取服务端监听地址。</p>
<p>类型：String</p>
<h3 id="prop-distributor"><a class="header" href="#prop-distributor">prop distributor</a></h3>
<pre><code class="language-cangjie">public prop distributor: HttpRequestDistributor
</code></pre>
<p>功能：获取请求分发器，请求分发器会根据 url 将请求分发给对应的 handler。</p>
<p>类型：<a href="net/http/http_package_api/http_package_interfaces.html#interface-httprequestdistributor">HttpRequestDistributor</a></p>
<h3 id="prop-enableconnectprotocol"><a class="header" href="#prop-enableconnectprotocol">prop enableConnectProtocol</a></h3>
<pre><code class="language-cangjie">public prop enableConnectProtocol: Bool
</code></pre>
<p>功能：HTTP/2 专用，用来限制对端发送的报文是否支持通过 connect 方法升级协议，true 表示支持。</p>
<p>类型：Bool</p>
<h3 id="prop-headertablesize-1"><a class="header" href="#prop-headertablesize-1">prop headerTableSize</a></h3>
<pre><code class="language-cangjie">public prop headerTableSize: UInt32
</code></pre>
<p>功能：获取服务端 HTTP/2 Hpack 动态表的初始值，默认值为 4096。</p>
<p>类型：UInt32</p>
<h3 id="prop-httpkeepalivetimeout"><a class="header" href="#prop-httpkeepalivetimeout">prop httpKeepAliveTimeout</a></h3>
<pre><code class="language-cangjie">public prop httpKeepAliveTimeout: Duration
</code></pre>
<p>功能：HTTP/1.1 专用，获取服务器设定的保持长连接的超时时间。</p>
<p>类型：Duration</p>
<h3 id="prop-initialwindowsize-1"><a class="header" href="#prop-initialwindowsize-1">prop initialWindowSize</a></h3>
<pre><code class="language-cangjie">public prop initialWindowSize: UInt32
</code></pre>
<p>功能：HTTP/2 专用，用来限制对端发送的报文stream 初始流量窗口大小。默认值为 65535 ，取值范围为 0 至 2^31 - 1。</p>
<p>类型：UInt32</p>
<h3 id="prop-listener"><a class="header" href="#prop-listener">prop listener</a></h3>
<pre><code class="language-cangjie">public prop listener: ServerSocket
</code></pre>
<p>功能：获取服务器绑定 socket。</p>
<p>类型：ServerSocket</p>
<h3 id="prop-logger-1"><a class="header" href="#prop-logger-1">prop logger</a></h3>
<pre><code class="language-cangjie">public prop logger: Logger
</code></pre>
<p>功能：获取服务器日志记录器，设置 logger.level 将立即生效，记录器应该是线程安全的。</p>
<p>类型：<a href="net/http/http_package_api/../../../log/log_package_api/log_package_classes.html#class-logger">Logger</a></p>
<h3 id="prop-maxconcurrentstreams-1"><a class="header" href="#prop-maxconcurrentstreams-1">prop maxConcurrentStreams</a></h3>
<pre><code class="language-cangjie">public prop maxConcurrentStreams: UInt32
</code></pre>
<p>功能：HTTP/2 专用，用来限制连接同时处理的最大请求数量。</p>
<p>类型：UInt32</p>
<h3 id="prop-maxframesize-1"><a class="header" href="#prop-maxframesize-1">prop maxFrameSize</a></h3>
<pre><code class="language-cangjie">public prop maxFrameSize: UInt32
</code></pre>
<p>功能：HTTP/2 专用，用来限制对端发送的报文一个帧的最大长度。默认值为 16384. 取值范围为 2^14 至 2^24 - 1。</p>
<p>类型：UInt32</p>
<h3 id="prop-maxheaderlistsize-1"><a class="header" href="#prop-maxheaderlistsize-1">prop maxHeaderListSize</a></h3>
<pre><code class="language-cangjie">public prop maxHeaderListSize: UInt32
</code></pre>
<p>功能：获取客户端支持的 HTTP/2 最大头部（Header）大小。这个大小指的是响应头部中所有头部字段（Header Field）的最大允许长度之和，其中包括所有字段名称（name）的长度、字段值（value）的长度以及每个字段自动添加的伪头开销（通常每个字段会有32字节的开销，这包括了HTTP/2协议本身为头部字段添加的伪头部信息）。默认情况下，这个最大长度被设置为 UInt32.Max。</p>
<p>类型：UInt32</p>
<h3 id="prop-maxrequestbodysize"><a class="header" href="#prop-maxrequestbodysize">prop maxRequestBodySize</a></h3>
<pre><code class="language-cangjie">public prop maxRequestBodySize: Int64
</code></pre>
<p>功能：获取服务器设定的读取请求的请求体最大值，仅对于 HTTP/1.1 且未设置 &quot;Transfer-Encoding: chunked&quot; 的请求生效。</p>
<p>类型：Int64</p>
<h3 id="prop-maxrequestheadersize"><a class="header" href="#prop-maxrequestheadersize">prop maxRequestHeaderSize</a></h3>
<pre><code class="language-cangjie">public prop maxRequestHeaderSize: Int64
</code></pre>
<p>功能：获取服务器设定的读取请求的请求头最大值。仅对 HTTP/1.1 生效，HTTP/2 中有专门的配置 maxHeaderListSize。</p>
<p>类型：Int64</p>
<h3 id="prop-port-1"><a class="header" href="#prop-port-1">prop port</a></h3>
<pre><code class="language-cangjie">public prop port: UInt16
</code></pre>
<p>功能：获取服务端监听端口。</p>
<p>类型：UInt16</p>
<h3 id="prop-protocolservicefactory"><a class="header" href="#prop-protocolservicefactory">prop protocolServiceFactory</a></h3>
<pre><code class="language-cangjie">public prop protocolServiceFactory: ProtocolServiceFactory
</code></pre>
<p>功能：获取协议服务工厂，服务协议工厂会生成每个协议所需的服务实例。</p>
<p>类型：<a href="net/http/http_package_api/http_package_interfaces.html#interface-protocolservicefactory">ProtocolServiceFactory</a></p>
<h3 id="prop-readheadertimeout"><a class="header" href="#prop-readheadertimeout">prop readHeaderTimeout</a></h3>
<pre><code class="language-cangjie">public prop readHeaderTimeout: Duration
</code></pre>
<p>功能：获取服务器设定的读取请求头的超时时间。</p>
<p>类型：Duration</p>
<h3 id="prop-readtimeout-2"><a class="header" href="#prop-readtimeout-2">prop readTimeout</a></h3>
<pre><code class="language-cangjie">public prop readTimeout: Duration
</code></pre>
<p>功能：获取服务器设定的读取整个请求的超时时间。</p>
<p>类型：Duration</p>
<h3 id="prop-servicepoolconfig"><a class="header" href="#prop-servicepoolconfig">prop servicePoolConfig</a></h3>
<pre><code class="language-cangjie">public prop servicePoolConfig: ServicePoolConfig
</code></pre>
<p>功能：获取协程池配置实例。</p>
<p>类型：<a href="net/http/http_package_api/http_package_structs.html#struct-servicepoolconfig">ServicePoolConfig</a></p>
<h3 id="prop-transportconfig"><a class="header" href="#prop-transportconfig">prop transportConfig</a></h3>
<pre><code class="language-cangjie">public prop transportConfig: TransportConfig
</code></pre>
<p>功能：获取服务器设定的传输层配置。</p>
<p>类型：<a href="net/http/http_package_api/http_package_structs.html#struct-transportconfig">TransportConfig</a></p>
<h3 id="prop-writetimeout-2"><a class="header" href="#prop-writetimeout-2">prop writeTimeout</a></h3>
<pre><code class="language-cangjie">public prop writeTimeout: Duration
</code></pre>
<p>功能：获取服务器设定的写响应的超时时间。</p>
<p>类型：Duration</p>
<h3 id="func-afterbind---unit"><a class="header" href="#func-afterbind---unit">func afterBind(() -&gt; Unit)</a></h3>
<pre><code class="language-cangjie">public func afterBind(f: ()-&gt; Unit): Unit
</code></pre>
<p>功能：注册服务器启动时的回调函数，服务内部 ServerSocket 实例 bind 之后，accept 之前将调用该函数。重复调用将覆盖之前注册的函数。</p>
<p>参数：</p>
<ul>
<li>f: () -&gt; Unit - 回调函数，入参为空，返回值为 Unit 类型。</li>
</ul>
<h3 id="func-close-10"><a class="header" href="#func-close-10">func close()</a></h3>
<pre><code class="language-cangjie">public func close(): Unit
</code></pre>
<p>功能：关闭服务器，服务器关闭后将不再对请求进行读取与处理，重复关闭将只有第一次生效（包括 close 和 closeGracefully）。</p>
<h3 id="func-closegracefully-1"><a class="header" href="#func-closegracefully-1">func closeGracefully()</a></h3>
<pre><code class="language-cangjie">public func closeGracefully(): Unit
</code></pre>
<p>功能：关闭服务器，服务器关闭后将不再对请求进行读取，当前正在进行处理的服务器待处理结束后进行关闭。</p>
<h3 id="func-gettlsconfig-1"><a class="header" href="#func-gettlsconfig-1">func getTlsConfig()</a></h3>
<pre><code class="language-cangjie">public func getTlsConfig(): ?TlsServerConfig
</code></pre>
<p>功能：获取服务器设定的 TLS 层配置。</p>
<p>返回值：</p>
<ul>
<li>?<a href="net/http/http_package_api/../../tls/tls_package_api/tls_package_structs.html#struct-tlsclientconfig">TlsServerConfig</a> - 服务端设定的 TLS 层配置，如果没有设置则返回 None。</li>
</ul>
<h3 id="func-onshutdown---unit"><a class="header" href="#func-onshutdown---unit">func onShutdown(() -&gt; Unit)</a></h3>
<pre><code class="language-cangjie">public func onShutdown(f: () -&gt; Unit): Unit
</code></pre>
<p>功能：注册服务器关闭时的回调函数，服务器关闭时将调用该回调函数，重复调用将覆盖之前注册的函数。</p>
<p>参数：</p>
<ul>
<li>f: () -&gt; Unit - 回调函数，入参为空，返回值为 Unit 类型。</li>
</ul>
<h3 id="func-serve-1"><a class="header" href="#func-serve-1">func serve()</a></h3>
<pre><code class="language-cangjie">public func serve(): Unit
</code></pre>
<p>功能：启动服务端进程，不支持重复启动。</p>
<p>h1 request 检查和处理：</p>
<ul>
<li>request-line 不符合 RFC 9112 中 request-line = method SP request-target SP HTTP-version 的规则，将会返回 400 响应；</li>
<li>method 由 tokens 组成，且大小写敏感；request-target 为能够被解析的 url；HTTP-version 为 HTTP/1.0 或 HTTP/1.1 ，否则将会返回 400 响应；</li>
<li>headers name 和 value 需符合特定规则，详见 <a href="net/http/http_package_api/http_package_classes.html#class-httpheaders">HttpHeaders</a> 类说明，否则返回 400 响应；</li>
<li>当 headers 的大小超出 server 设定的 maxRequestHeaderSize 时将自动返回 431 响应；</li>
<li>headers 中必须包含 &quot;host&quot; 请求头，且值唯一，否则返回 400 响应headers 中不允许同时存在 &quot;content-length&quot; 与 &quot;transfer-encoding&quot; 请求头，否则返回 400 响应；</li>
<li>请求头 &quot;transfer-encoding&quot; 的 value 经过 &quot;,&quot; 分割后最后一个 value 必须为 &quot;chunked&quot;，且之前的 value 不允许存在 &quot;chunked&quot;，否则返回 400 响应；</li>
<li>请求头 &quot;content-length&quot; 其 value 必须能解析为 Int64 类型，且不能为负值，否则返回 400 响应，当其 value 值超出 server 设定maxRequestBodySize，将返回 413 响应；</li>
<li>headers 中若不存在 &quot;content-length&quot; 和 &quot;transfer-encoding: chunked&quot; 时默认不存在 body；</li>
<li>请求头 &quot;trailer&quot; 中，value 不允许存在 &quot;transfer-encoding&quot;，&quot;trailer&quot;，&quot;content-length&quot;；</li>
<li>请求头 &quot;expect&quot; 中，value 中存在非 &quot;100-continue&quot; 的值，将会返回 417 响应；</li>
<li>HTTP/1.0 默认短连接，若想保持长连接需要包含请求头 &quot;connection: keep-alive&quot; 与 &quot;keep-alive: timeout = XX, max = XX&quot;，将会自动保持 timeout 时长的连接。HTTP/1.1 默认长连接，当解析 request 失败则关闭连接；</li>
<li>仅允许在 chunked 模式下存在 trailer，且 trailer 中条目的 name 必须被包含在 &quot;trailer&quot; 请求头中，否则将自动删除。</li>
</ul>
<p>h1 response 检查和处理：</p>
<ul>
<li>若用户不对 response 进行配置，将会自动返回 200 响应；</li>
<li>若接收到的 request 包含请求头 &quot;connection: close&quot; 而配置 response 未添加响应头 &quot;connection&quot; 或响应头 &quot;connection&quot; 的 value 不包含 &quot;close&quot;，将自动添加 &quot;connection: close&quot;，若接收到的 request 不包含请求头 &quot;connection: close&quot; 且响应头不存在 &quot;connection: keep-alive&quot;，将会自动添加；</li>
<li>如果 headers 包含逐跳响应头：&quot;proxy-connection&quot;，&quot;keep-alive&quot;，&quot;te&quot;，&quot;transfer-encoding&quot;，&quot;upgrade&quot;，将会在响应头 &quot;connection&quot; 自动添加这些头作为 value；</li>
<li>将自动添加 &quot;date&quot; 响应头，用户提供的 &quot;date&quot; 将被忽略；</li>
<li>若请求方法为 &quot;HEAD&quot; 或响应状态码为 &quot;1XX\204\304&quot;，body将配置为空；</li>
<li>若已知提供 body 的长度时，将会与响应头 &quot;content-length&quot; 进行比较，若不存在响应头 &quot;content-length&quot;，将自动添加此响应头，其 value 值为 body 长度。若响应头 &quot;content-length&quot; 长度大于 body 长度，将会在 handler 中抛出 <a href="net/http/http_package_api/http_package_exceptions.html#class-httpexception">HttpException</a>，若小于 body 长度，将对 body 进行截断处理，发送的 body 长度将为 &quot;content-length&quot; 的值；</li>
<li>response 中 &quot;set-cookie&quot; header 将分条发送，其他 headers 同名条目将合成一条发送；</li>
<li>在处理包含请求头：&quot;expect: 100-continue&quot; 的 request 时，在调用 request 的 body.read() 时将会自动发送状态码为 100 的响应给客户端。不允许用户主动发送状态码为 100 的 response，若进行发送则被认定为服务器异常。</li>
</ul>
<p>启用 h2 服务：tlsConfig 中 supportedAlpnProtocols 需包含 &quot;h2&quot;，此后如果 tls 层 alpn 协商结果为 h2，则启用 h2 服务。</p>
<p>h2 request 检查和处理：</p>
<ul>
<li>headers name 和 value 需符合特定规则，详见 <a href="net/http/http_package_api/http_package_classes.html#class-httpheaders">HttpHeaders</a> 类说明，此外 name 不能包含大写字符，否则发送 RST 帧关闭流，即无法保证返回响应；</li>
<li>trailers name 和 value 需符合同样规则，否则关闭流；</li>
<li>headers 不能包含 &quot;connection&quot;，&quot;transfer-encoding&quot;，&quot;keep-alive&quot;，&quot;upgrade&quot;，&quot;proxy-connection&quot;，否则关闭流；</li>
<li>如果有 &quot;te&quot; header，其值只能为 &quot;trailers&quot;，否则关闭流；</li>
<li>如果有 &quot;host&quot; header 和 &quot;:authority&quot; pseudo header，&quot;host&quot; 值必须与 &quot;:authority&quot; 一致，否则关闭流；</li>
<li>如果有 &quot;content-length&quot; header，需符合 &quot;content-length&quot; 每个值都能解析为 Int64 类型，且如果有多个值，必须相等，否则关闭流；</li>
<li>如果有 &quot;content-length&quot; header，且有 body 大小，则 content-length 值与 body 大小必须相等，否则关闭流；</li>
<li>如果有 &quot;trailer&quot; header，其值不能包含 &quot;transfer-encoding&quot;，&quot;trailer&quot;，&quot;content-length&quot;，否则关闭流；</li>
<li>仅在升级 <a href="net/http/http_package_api/http_package_classes.html#class-websocket">WebSocket</a> 场景下支持 CONNECT 方法，否则关闭流；</li>
<li>pseudo headers 中，必须包含 &quot;:method&quot;、&quot;:scheme&quot;、&quot;:path&quot;，其中 &quot;:method&quot; 值必须由 tokens 字符组成，&quot;:scheme&quot; 值必须为 &quot;https&quot;，&quot;:path&quot; 不能为空，否则关闭流；</li>
<li>trailer 中条目的 name 必须被包含在 &quot;trailer&quot; 头中，否则将自动删除；</li>
<li>request headers 大小不能超过 maxHeaderListSize，否则关闭连接。</li>
</ul>
<p>h2 response 检查和处理：</p>
<ul>
<li>如果 HEAD 请求的响应包含 body，将自动删除；</li>
<li>将自动添加 &quot;date&quot; field，用户提供的 &quot;date&quot; 将被忽略；</li>
<li>如果 headers 包含 &quot;connection&quot;，&quot;transfer-encoding&quot;，&quot;keep-alive&quot;，&quot;upgrade&quot;，&quot;proxy-connection&quot;，将自动删除；</li>
<li>response 中 &quot;set-cookie&quot; header 将分条发送，其他 headers 同名条目将合成一条发送；</li>
<li>如果 headers 包含 &quot;content-length&quot;，且 method 不为 &quot;HEAD&quot;，&quot;content-length&quot; 将被删除；</li>
<li>如果 method 为 &quot;HEAD&quot;，则：
<ul>
<li>headers 包含 &quot;content-length&quot;，但 &quot;content-length&quot; 不合法（无法被解析为 Int64 值，或包含多个不同值），如果用户调用 <a href="net/http/http_package_api/http_package_classes.html#class-httpresponsewriter">HttpResponseWriter</a> 类的 write 函数，将抛出 <a href="net/http/http_package_api/http_package_exceptions.html#class-httpexception">HttpException</a>，如果用户 handler 已经结束，将打印日志；</li>
<li>headers 包含 &quot;content-length&quot;，同时 response.body.length 不为 -1，&quot;content-length&quot; 值与 body.length 不符，同 6.1 处理；</li>
<li>headers 包含 &quot;content-length&quot;，同时 response.body.length 为 -1，或 body.length 与 &quot;content-length&quot; 值一致，则保留 &quot;content-length&quot; header；</li>
</ul>
</li>
<li>trailer 中条目必须被包含在 &quot;trailer&quot; 头中，否则将自动删除；</li>
<li>如果 handler 中抛出异常，且用户未调用 write 发送部分响应，将返回 500 响应。如果用户已经调用 write 发送部分响应，将发送 RST 帧关闭 stream。</li>
</ul>
<p>h2 server 发完 response 之后，如果 stream 状态不是 CLOSED，会发送带 NO_ERROR 错误码的 RST 帧关闭 stream，避免已经处理完毕的 stream 继续占用服务器资源。</p>
<p>h2 流量控制：</p>
<ul>
<li>connection 流量窗口初始值为 65535，每次收到 DATA 帧将返回一个 connection 层面的 WINDOW-UPDATE，发送 DATA 时，如果 connection 流量窗口值为负数，将阻塞至其变为正数；</li>
<li>stream 流量窗口初始值可由用户设置，默认值为 65535，每次收到 DATA 帧将返回一个 stream 层面的 WINDOW-UPDATE，发送 DATA 时，如果 stream 流量窗口值为负数，将阻塞至其变为正数。</li>
</ul>
<p>h2 请求优先级：</p>
<ul>
<li>支持按 urgency 处理请求，h2 服务默认并发处理请求，当并发资源不足时，请求将按 urgency 处理，优先级高的请求优先处理。</li>
</ul>
<p>默认 <a href="net/http/http_package_api/http_package_interfaces.html#interface-protocolservicefactory">ProtocolServiceFactory</a> 协议选择：</p>
<ul>
<li>如果连接是 tcp，使用 HTTP/1.1 server；</li>
<li>如果连接是 tls，根据 alpn 协商结果确定 http 协议版本，如果协商结果为 &quot;http/1.0&quot;，&quot;http/1.1&quot; 或 &quot;&quot;，使用 HTTP/1.1 server，如果协商结果为 &quot;h2&quot;，使用 HTTP/2 server，否则不处理此次请求，打印日志关连接。</li>
</ul>
<p>异常：</p>
<ul>
<li>SocketException - 当端口监听失败时，抛出异常。</li>
</ul>
<h3 id="func-updatecaarrayx509certificate"><a class="header" href="#func-updatecaarrayx509certificate">func updateCA(Array&lt;X509Certificate&gt;)</a></h3>
<pre><code class="language-cangjie">public func updateCA(newCa: Array&lt;X509Certificate&gt;): Unit
</code></pre>
<p>功能：对 CA 证书进行热更新。</p>
<p>参数：</p>
<ul>
<li>newCa: Array&lt;<a href="net/http/http_package_api/../../../crypto/x509/x509_package_api/x509_package_classes.html#class-x509certificate">X509Certificate</a>&gt; - CA证书。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 参数包含空字符时抛出异常。</li>
<li><a href="net/http/http_package_api/http_package_exceptions.html#class-httpexception">HttpException</a> - 服务端未配置 tlsConfig时抛出异常。</li>
</ul>
<h3 id="func-updatecastring"><a class="header" href="#func-updatecastring">func updateCA(String)</a></h3>
<pre><code class="language-cangjie">public func updateCA(newCaFile: String): Unit
</code></pre>
<p>功能：对 CA 证书进行热更新。</p>
<p>参数：</p>
<ul>
<li>newCaFile: String - CA证书文件。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 参数包含空字符时抛出异常。</li>
<li><a href="net/http/http_package_api/http_package_exceptions.html#class-httpexception">HttpException</a> - 服务端未配置 tlsConfig时抛出异常。</li>
</ul>
<h3 id="func-updatecertarrayx509certificate-privatekey"><a class="header" href="#func-updatecertarrayx509certificate-privatekey">func updateCert(Array&lt;X509Certificate&gt;, PrivateKey)</a></h3>
<pre><code class="language-cangjie">public func updateCert(certChain: Array&lt;X509Certificate&gt;, certKey: PrivateKey): Unit
</code></pre>
<p>功能：对 TLS 证书进行热更新。</p>
<p>参数：</p>
<ul>
<li>certChain: Array&lt;<a href="net/http/http_package_api/../../../crypto/x509/x509_package_api/x509_package_classes.html#class-x509certificate">X509Certificate</a>&gt; - 证书链。</li>
<li>certKey: <a href="net/http/http_package_api/../../../crypto/x509/x509_package_api/x509_package_interfaces.html#interface-privatekey">PrivateKey</a> - 证书匹配的私钥。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_exceptions.html#class-httpexception">HttpException</a> - 服务端未配置 tlsConfig时抛出异常。</li>
</ul>
<h3 id="func-updatecertstring-string"><a class="header" href="#func-updatecertstring-string">func updateCert(String, String)</a></h3>
<pre><code class="language-cangjie">public func updateCert(certificateChainFile: String, privateKeyFile: String): Unit
</code></pre>
<p>功能：对 TLS 证书进行热更新。</p>
<p>参数：</p>
<ul>
<li>certificateChainFile: String - 证书链文件。</li>
<li>privateKeyFile: String - 证书匹配的私钥文件。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 参数包含空字符时抛出异常。</li>
<li><a href="net/http/http_package_api/http_package_exceptions.html#class-httpexception">HttpException</a> - 服务端未配置 tlsConfig时抛出异常。</li>
</ul>
<h2 id="class-serverbuilder"><a class="header" href="#class-serverbuilder">class ServerBuilder</a></h2>
<pre><code class="language-cangjie">public class ServerBuilder {
    public init()
}
</code></pre>
<p>功能：提供 <a href="net/http/http_package_api/http_package_classes.html#class-server">Server</a> 实例构建器。</p>
<p>支持通过如下参数构造一个 Http <a href="net/http/http_package_api/http_package_classes.html#class-server">Server</a>：</p>
<ul>
<li>地址、端口；</li>
<li>线程安全的 logger；</li>
<li><a href="net/http/http_package_api/http_package_interfaces.html#interface-httprequestdistributor">HttpRequestDistributor</a>，用于注册 handler、分发 request；</li>
<li>HTTP/2 的 settings；</li>
<li>shutdown 回调；</li>
<li>transport：listener、连接及其配置；</li>
<li>protocol service：http 协议解析服务；</li>
</ul>
<p>除地址端口、shutdown 回调外，均提供默认实现，用户在构造 server 过程中可不指定其他构建参数。
<a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> 文档中未明确说明支持版本的配置，在 HTTP/1.1 与 HTTP/2 都会生效。</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>该类提供了一系列配置参数的函数，配置完成后调用 <a href="net/http/http_package_api/./http_package_classes.html#func-build-3">build</a> 函数构造出 <a href="net/http/http_package_api/./http_package_classes.html#class-server">Server</a> 实例。配置函数中说明了参数的取值范围，但配置函数本身不做参数合法性校验，<a href="net/http/http_package_api/./http_package_classes.html#func-build-3">build</a> 时统一进行校验。</p>
</blockquote>
<h3 id="init-22"><a class="header" href="#init-22">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：创建 <a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> 实例。</p>
<h3 id="func-addrstring"><a class="header" href="#func-addrstring">func addr(String)</a></h3>
<pre><code class="language-cangjie">public func addr(addr: String): ServerBuilder
</code></pre>
<p>功能：设置服务端监听地址，若 listener 被设定，此值被忽略。</p>
<p>格式需符合 IPAddress 中相关规定。</p>
<p>参数：</p>
<ul>
<li>addr: String - 地址值。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> 的引用。</li>
</ul>
<h3 id="func-afterbind-unit"><a class="header" href="#func-afterbind-unit">func afterBind(()-&gt;Unit)</a></h3>
<pre><code class="language-cangjie">public func afterBind(f: ()-&gt;Unit): ServerBuilder
</code></pre>
<p>功能：注册服务器启动时的回调函数，服务内部 ServerSocket 实例 bind 之后，accept 之前将调用该函数。重复调用将覆盖之前注册的函数。</p>
<p>参数：</p>
<ul>
<li>f: () -&gt;Unit - 回调函数，入参为空，返回值为 Unit 类型。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> 的引用。</li>
</ul>
<h3 id="func-build-4"><a class="header" href="#func-build-4">func build()</a></h3>
<pre><code class="language-cangjie">public func build(): Server
</code></pre>
<p>功能：根据设置的参数构建 <a href="net/http/http_package_api/http_package_classes.html#class-server">Server</a> 实例。</p>
<p>此处会对各参数的值进行检查，如果取值非法，将抛出异常。各参数的取值范围详见设置参数相关的函数。</p>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-server">Server</a> - 生成的 <a href="net/http/http_package_api/http_package_classes.html#class-server">Server</a> 实例。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 当设置的参数非法时，抛出异常。</li>
<li>IllegalFormatException 格式错误时，抛出异常。</li>
</ul>
<h3 id="func-distributorhttprequestdistributor"><a class="header" href="#func-distributorhttprequestdistributor">func distributor(HttpRequestDistributor)</a></h3>
<pre><code class="language-cangjie">public func distributor(distributor: HttpRequestDistributor): ServerBuilder
</code></pre>
<p>功能：设置请求分发器，请求分发器会根据 url 将请求分发给对应的 handler。不设置时使用默认请求分发器。</p>
<p>参数：</p>
<ul>
<li>distributor: <a href="net/http/http_package_api/http_package_interfaces.html#interface-httprequestdistributor">HttpRequestDistributor</a> - 自定义请求分发器实例。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> 的引用。</li>
</ul>
<h3 id="func-enableconnectprotocolbool"><a class="header" href="#func-enableconnectprotocolbool">func enableConnectProtocol(Bool)</a></h3>
<pre><code class="language-cangjie">public func enableConnectProtocol(flag: Bool): ServerBuilder
</code></pre>
<p>功能：HTTP/2 专用，设置本端是否接收 CONNECT 请求，默认 false。</p>
<p>参数：</p>
<ul>
<li>flag: Bool - 本端是否接收 CONNECT 请求。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> 的引用。</li>
</ul>
<h3 id="func-headertablesizeuint32-1"><a class="header" href="#func-headertablesizeuint32-1">func headerTableSize(UInt32)</a></h3>
<pre><code class="language-cangjie">public func headerTableSize(size: UInt32): ServerBuilder
</code></pre>
<p>功能：设置服务端 HTTP/2 Hpack 动态表的初始值，默认值为 4096。</p>
<p>参数：</p>
<ul>
<li>size: UInt32 - 本端对响应头编码时使用的最大 <code>table size</code></li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> 的引用。</li>
</ul>
<h3 id="func-httpkeepalivetimeoutduration"><a class="header" href="#func-httpkeepalivetimeoutduration">func httpKeepAliveTimeout(Duration)</a></h3>
<pre><code class="language-cangjie">public func httpKeepAliveTimeout(timeout: Duration): ServerBuilder
</code></pre>
<p>功能：HTTP/1.1 专用，设定服务端连接保活时长，该时长内客户端未再次发送请求，服务端将关闭长连接，默认不进行限制。</p>
<p>参数：</p>
<ul>
<li>timeout: Duration - 设定保持长连接的超时时间，如果传入负的 Duration 将被替换为 Duration.Zero。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> 的引用。</li>
</ul>
<h3 id="func-initialwindowsizeuint32-1"><a class="header" href="#func-initialwindowsizeuint32-1">func initialWindowSize(UInt32)</a></h3>
<pre><code class="language-cangjie">public func initialWindowSize(size: UInt32): ServerBuilder
</code></pre>
<p>功能：HTTP/2 专用，设置当前服务器上每个流的接收报文的初始流量窗口大小，默认值为 65535。取值范围为 0 至 2^31 - 1。</p>
<p>参数：</p>
<ul>
<li>size: UInt32 - 本端一个 stream 上接收报文的初始流量窗口大小。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> 的引用。</li>
</ul>
<h3 id="func-listenerserversocket"><a class="header" href="#func-listenerserversocket">func listener(ServerSocket)</a></h3>
<pre><code class="language-cangjie">public func listener(listener: ServerSocket): ServerBuilder
</code></pre>
<p>功能：服务端调用此函数对指定 socket 进行绑定监听。</p>
<p>参数：</p>
<ul>
<li>listener: ServerSocket - 所绑定的socket。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> 的引用。</li>
</ul>
<h3 id="func-loggerlogger-1"><a class="header" href="#func-loggerlogger-1">func logger(Logger)</a></h3>
<pre><code class="language-cangjie">public func logger(logger: Logger): ServerBuilder
</code></pre>
<p>功能：设定服务器的 logger，默认 logger 级别为 INFO，logger 内容将写入 Console.stdout。</p>
<p>参数：</p>
<ul>
<li>logger: <a href="net/http/http_package_api/../../../log/log_package_api/log_package_classes.html#class-logger">Logger</a> - 需要是线程安全的，默认使用内置线程安全 logger。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> 的引用。</li>
</ul>
<h3 id="func-maxconcurrentstreamsuint32-1"><a class="header" href="#func-maxconcurrentstreamsuint32-1">func maxConcurrentStreams(UInt32)</a></h3>
<pre><code class="language-cangjie">public func maxConcurrentStreams(size: UInt32): ServerBuilder
</code></pre>
<p>功能：HTTP/2 专用，设置本端同时处理的最大请求数量，限制对端并发发送请求的数量，默认值为 100。</p>
<p>参数：</p>
<ul>
<li>size: UInt32 - 本端同时处理的最大请求数量。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> 的引用。</li>
</ul>
<h3 id="func-maxframesizeuint32-1"><a class="header" href="#func-maxframesizeuint32-1">func maxFrameSize(UInt32)</a></h3>
<pre><code class="language-cangjie">public func maxFrameSize(size: UInt32): ServerBuilder
</code></pre>
<p>功能：HTTP/2 专用，设置本端接收的一个帧的最大长度，用来限制对端发送帧的长度，默认值为 16384. 取值范围为 2^14 至 2^24 - 1。</p>
<p>参数：</p>
<ul>
<li>size: UInt32 - 本端接收的一个帧的最大长度。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> 的引用。</li>
</ul>
<h3 id="func-maxheaderlistsizeuint32-1"><a class="header" href="#func-maxheaderlistsizeuint32-1">func maxHeaderListSize(UInt32)</a></h3>
<pre><code class="language-cangjie">public func maxHeaderListSize(size: UInt32): ServerBuilder
</code></pre>
<p>功能：获取客户端支持的 HTTP/2 最大头部（Header）大小。这个大小指的是响应头部中所有头部字段（Header Field）的最大允许长度之和，其中包括所有字段名称（name）的长度、字段值（value）的长度以及每个字段自动添加的伪头开销（通常每个字段会有32字节的开销，这包括了 HTTP/2 协议本身为头部字段添加的伪头部信息）。默认情况下，这个最大长度被设置为 UInt32.Max。</p>
<p>参数：</p>
<ul>
<li>size: UInt32 - 本端接收的报文头最大长度。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> 的引用。</li>
</ul>
<h3 id="func-maxrequestbodysizeint64"><a class="header" href="#func-maxrequestbodysizeint64">func maxRequestBodySize(Int64)</a></h3>
<pre><code class="language-cangjie">public func maxRequestBodySize(size: Int64): ServerBuilder
</code></pre>
<p>功能：设置服务端允许客户端发送单个请求的请求体最大长度，请求体长度超过该值时，将返回状态码为 413 的响应。默认值为 2M。仅对于 HTTP/1.1 且未设置 &quot;Transfer-Encoding: chunked&quot; 的请求生效。</p>
<p>参数：</p>
<ul>
<li>size: Int64 - 设定允许接收请求的请求体大小最大值，值为 0 代表不作限制。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> 的引用。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 当入参size &lt; 0时，抛出异常。</li>
</ul>
<h3 id="func-maxrequestheadersizeint64"><a class="header" href="#func-maxrequestheadersizeint64">func maxRequestHeaderSize(Int64)</a></h3>
<pre><code class="language-cangjie">public func maxRequestHeaderSize(size: Int64): ServerBuilder
</code></pre>
<p>功能：设定服务端允许客户端发送单个请求的请求头最大长度，请求头长度超过该值时，将返回状态码为 431 的响应；仅对 HTTP/1.1 生效，HTTP/2 中有专门的配置 maxHeaderListSize。</p>
<p>参数：</p>
<ul>
<li>size: Int64 - 设定允许接收请求的请求头大小最大值，值为 0 代表不作限制。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> 的引用。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 当入参size &lt; 0时，抛出异常。</li>
</ul>
<h3 id="func-onshutdown---unit-1"><a class="header" href="#func-onshutdown---unit-1">func onShutdown(() -&gt; Unit)</a></h3>
<pre><code class="language-cangjie">public func onShutdown(f: () -&gt; Unit): ServerBuilder
</code></pre>
<p>功能：注册服务器关闭时的回调函数，服务器关闭时将调用该回调函数，重复调用将覆盖之前注册的函数。</p>
<p>参数：</p>
<ul>
<li>f: () -&gt;Unit - 回调函数，入参为空，返回值为 Unit 类型。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> 的引用。</li>
</ul>
<h3 id="func-portuint16"><a class="header" href="#func-portuint16">func port(UInt16)</a></h3>
<pre><code class="language-cangjie">public func port(port: UInt16): ServerBuilder
</code></pre>
<p>功能：设置服务端监听端口，若 listener 被设定，此值被忽略。</p>
<p>参数：</p>
<ul>
<li>port: UInt16 - 端口值。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> 的引用。</li>
</ul>
<h3 id="func-protocolservicefactoryprotocolservicefactory"><a class="header" href="#func-protocolservicefactoryprotocolservicefactory">func protocolServiceFactory(ProtocolServiceFactory)</a></h3>
<pre><code class="language-cangjie">public func protocolServiceFactory(factory: ProtocolServiceFactory): ServerBuilder
</code></pre>
<p>功能：设置协议服务工厂，服务协议工厂会生成每个协议所需的服务实例，不设置时使用默认工厂。</p>
<p>参数：</p>
<ul>
<li>factory: <a href="net/http/http_package_api/http_package_interfaces.html#interface-protocolservicefactory">ProtocolServiceFactory</a> - 自定义工厂实例。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> 的引用。</li>
</ul>
<h3 id="func-readheadertimeoutduration"><a class="header" href="#func-readheadertimeoutduration">func readHeaderTimeout(Duration)</a></h3>
<pre><code class="language-cangjie">public func readHeaderTimeout(timeout: Duration): ServerBuilder
</code></pre>
<p>功能：设定服务端读取客户端发送一个请求的请求头最大时长，超过该时长将不再进行读取并关闭连接，默认不进行限制。</p>
<p>参数：</p>
<ul>
<li>timeout: Duration - 设定的读请求头超时时间，如果传入负的 Duration 将被替换为 Duration.Zero。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> 的引用。</li>
</ul>
<h3 id="func-readtimeoutduration-2"><a class="header" href="#func-readtimeoutduration-2">func readTimeout(Duration)</a></h3>
<pre><code class="language-cangjie">public func readTimeout(timeout: Duration): ServerBuilder
</code></pre>
<p>功能：设定服务端读取一个请求的最大时长，超过该时长将不再进行读取并关闭连接，默认不进行限制。</p>
<p>参数：</p>
<ul>
<li>timeout: Duration - 设定读请求的超时时间，如果传入时间为负值将被替换为 Duration.Zero。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> 的引用。</li>
</ul>
<h3 id="func-servicepoolconfigservicepoolconfig"><a class="header" href="#func-servicepoolconfigservicepoolconfig">func servicePoolConfig(ServicePoolConfig)</a></h3>
<pre><code class="language-cangjie">public func servicePoolConfig(cfg: ServicePoolConfig): ServerBuilder
</code></pre>
<p>功能：服务过程中使用的协程池相关设置，具体说明见 <a href="net/http/http_package_api/http_package_structs.html#struct-servicepoolconfig">ServicePoolConfig</a> 结构体。</p>
<p>参数：</p>
<ul>
<li>cfg: <a href="net/http/http_package_api/http_package_structs.html#struct-servicepoolconfig">ServicePoolConfig</a> - 协程池相关设置。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> 的引用。</li>
</ul>
<h3 id="func-tlsconfigtlsserverconfig"><a class="header" href="#func-tlsconfigtlsserverconfig">func tlsConfig(TlsServerConfig)</a></h3>
<pre><code class="language-cangjie">public func tlsConfig(config: TlsServerConfig): ServerBuilder
</code></pre>
<p>功能：设置 TLS 层配置，默认不对其进行设置。</p>
<p>参数：</p>
<ul>
<li>config: <a href="net/http/http_package_api/../../tls/tls_package_api/tls_package_structs.html#struct-tlsserverconfig">TlsServerConfig</a> - 设定支持 tls 服务所需要的配置信息。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> 的引用。</li>
</ul>
<h3 id="func-transportconfigtransportconfig"><a class="header" href="#func-transportconfigtransportconfig">func transportConfig(TransportConfig)</a></h3>
<pre><code class="language-cangjie">public func transportConfig(config: TransportConfig): ServerBuilder
</code></pre>
<p>功能：设置传输层配置，默认配置详见 <a href="net/http/http_package_api/http_package_structs.html#struct-transportconfig">TransportConfig</a> 结构体说明。</p>
<p>参数：</p>
<ul>
<li>config: <a href="net/http/http_package_api/http_package_structs.html#struct-transportconfig">TransportConfig</a> - 设定的传输层配置信息。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> 的引用。</li>
</ul>
<h3 id="func-writetimeoutduration-2"><a class="header" href="#func-writetimeoutduration-2">func writeTimeout(Duration)</a></h3>
<pre><code class="language-cangjie">public func writeTimeout(timeout: Duration): ServerBuilder
</code></pre>
<p>功能：设定服务端发送一个响应的最大时长，超过该时长将不再进行写入并关闭连接，默认不进行限制。</p>
<p>参数：</p>
<ul>
<li>timeout: Duration - 设定写响应的超时时间，如果传入时间为负值将被替换为 Duration.Zero。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> - 当前 <a href="net/http/http_package_api/http_package_classes.html#class-serverbuilder">ServerBuilder</a> 的引用。</li>
</ul>
<h2 id="class-websocket"><a class="header" href="#class-websocket">class WebSocket</a></h2>
<pre><code class="language-cangjie">public class WebSocket
</code></pre>
<p>功能：提供 <a href="net/http/http_package_api/http_package_classes.html#class-websocket">WebSocket</a> 服务的相关类，提供 <a href="net/http/http_package_api/http_package_classes.html#class-websocket">WebSocket</a> 连接的读、写、关闭等函数。用户通过 upgradeFrom 函数以获取 <a href="net/http/http_package_api/http_package_classes.html#class-websocket">WebSocket</a> 连接。</p>
<ul>
<li>调用 <code>read()</code> 读取一个 <a href="net/http/http_package_api/http_package_classes.html#class-websocketframe">WebSocketFrame</a>，用户可通过 <a href="net/http/http_package_api/http_package_classes.html#class-websocketframe">WebSocketFrame</a>.frameType 来知晓帧的类型，通过 <a href="net/http/http_package_api/http_package_classes.html#class-websocketframe">WebSocketFrame</a>.fin 来知晓是否是分段帧。</li>
<li>调用 <code>write(frameType: WebSocketFrameType, byteArray: Array&lt;UInt8&gt;)</code>，传入 message 的类型和 message 的 byte 来发送 <a href="net/http/http_package_api/http_package_classes.html#class-websocket">WebSocket</a> 信息，如果写的是控制帧，则不会分段发送，如果写的是数据帧（Text、Binary），则会将 message 按底层 buffer 的大小分段（分成多个 fragment）发送。</li>
</ul>
<p>详细说明见下文接口说明，接口行为以 RFC 6455 为准。</p>
<h3 id="prop-logger-2"><a class="header" href="#prop-logger-2">prop logger</a></h3>
<pre><code class="language-cangjie">public prop logger: Logger
</code></pre>
<p>功能：日志记录器。</p>
<p>类型：<a href="net/http/http_package_api/../../../log/log_package_api/log_package_classes.html#class-logger">Logger</a></p>
<h3 id="prop-subprotocol"><a class="header" href="#prop-subprotocol">prop subProtocol</a></h3>
<pre><code class="language-cangjie">public prop subProtocol: String
</code></pre>
<p>功能：获取与对端协商到的 subProtocol，协商时，客户端提供一个按偏好排名的 subProtocols 列表，服务器从中选取一个或零个子协议。</p>
<p>类型：String</p>
<h3 id="static-func-upgradefromclientclient-url-protocol-arrayliststring-httpheaders"><a class="header" href="#static-func-upgradefromclientclient-url-protocol-arrayliststring-httpheaders">static func upgradeFromClient(Client, URL, Protocol, ArrayList&lt;String&gt;, HttpHeaders)</a></h3>
<pre><code class="language-cangjie">public static func upgradeFromClient(client: Client, url: URL,
 version!: Protocol = HTTP1_1,
 subProtocols!: ArrayList&lt;String&gt; = ArrayList&lt;String&gt;(), 
 headers!: HttpHeaders = HttpHeaders()): (WebSocket, HttpHeaders)
</code></pre>
<p>功能：提供客户端升级到 <a href="net/http/http_package_api/http_package_classes.html#class-websocket">WebSocket</a> 协议的函数。</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>客户端的升级流程为：传入 client 对象，url 对象，构建升级请求，请求服务器后验证其响应，如果握手成功，则返回 <a href="net/http/http_package_api/http_package_classes.html#class-websocket">WebSocket</a> 对象用于 <a href="net/http/http_package_api/http_package_classes.html#class-websocket">WebSocket</a> 通讯，并返回 101 响应头的 <a href="net/http/http_package_api/http_package_classes.html#class-httpheaders">HttpHeaders</a> 对象给用户。暂不支持 extensions。如果子协议协商成功，用户可通过调用返回的 <a href="net/http/http_package_api/http_package_classes.html#class-websocket">WebSocket</a> 的 subProtocol 查看子协议。</p>
</blockquote>
<p>参数：</p>
<ul>
<li>client: <a href="net/http/http_package_api/http_package_classes.html#class-client">Client</a> - 用于请求的 client 对象。</li>
<li>url: <a href="net/http/http_package_api/../../../encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> - 用于请求的 url 对象，<a href="net/http/http_package_api/http_package_classes.html#class-websocket">WebSocket</a> 升级时要注意 url 的 scheme 为 ws 或 wss。</li>
<li>version!: <a href="net/http/http_package_api/http_package_enums.html#enum-protocol">Protocol</a> - 创建 socket 使用的 HTTP 版本，只支持  <a href="net/http/http_package_api/./http_package_enums.html#enum-Protocol">HTTP1_1</a> 和  <a href="net/http/http_package_api/./http_package_enums.html#enum-Protocol">HTTP2_0</a> 向 <a href="net/http/http_package_api/http_package_classes.html#class-websocket">WebSocket</a> 升级。</li>
<li>subProtocols!: ArrayList&lt;String&gt; - 用户配置的子协议列表，按偏好排名，默认为空。若用户配置了，则会随着升级请求发送给服务器。</li>
<li>headers!: <a href="net/http/http_package_api/http_package_classes.html#class-httpheaders">HttpHeaders</a> - 需要随着升级请求一同发送的非升级必要头，如 cookie 等。</li>
</ul>
<p>返回值：</p>
<ul>
<li>(<a href="net/http/http_package_api/http_package_classes.html#class-websocket">WebSocket</a>, HttpHeaders) - 升级成功，则返回 <a href="net/http/http_package_api/http_package_classes.html#class-websocket">WebSocket</a> 对象用于通讯和 101 响应的头。</li>
</ul>
<p>异常：</p>
<ul>
<li>SocketException - 底层连接错误时抛出异常。</li>
<li><a href="net/http/http_package_api/http_package_exceptions.html#class-httpexception">HttpException</a> - 握手时 HTTP 请求过程中出现错误时抛出异常。</li>
<li><a href="net/http/http_package_api/http_package_exceptions.html#class-websocketexception">WebSocketException</a> - 升级失败，升级响应验证不通过时抛出异常。</li>
</ul>
<h3 id="static-func-upgradefromserverhttpcontext-arrayliststring-arrayliststring-httprequest---httpheaders"><a class="header" href="#static-func-upgradefromserverhttpcontext-arrayliststring-arrayliststring-httprequest---httpheaders">static func upgradeFromServer(HttpContext, ArrayList&lt;String&gt;, ArrayList&lt;String&gt;, (HttpRequest) -&gt; HttpHeaders)</a></h3>
<pre><code class="language-cangjie">public static func upgradeFromServer(ctx: HttpContext, subProtocols!: ArrayList&lt;String&gt; = ArrayList&lt;String&gt;(), 
                                        origins!: ArrayList&lt;String&gt; = ArrayList&lt;String&gt;(), 
                                        userFunc!:(HttpRequest) -&gt; HttpHeaders = {_: HttpRequest =&gt; HttpHeaders()}): WebSocket
</code></pre>
<p>功能：提供服务端升级到 <a href="net/http/http_package_api/http_package_classes.html#class-websocket">WebSocket</a> 协议的函数，通常在 handler 中使用。</p>
<p>服务端升级的流程为：收到客户端发来的升级请求，验证请求，如果验证通过，则回复 101 响应并返回 <a href="net/http/http_package_api/http_package_classes.html#class-websocket">WebSocket</a> 对象用于 <a href="net/http/http_package_api/http_package_classes.html#class-websocket">WebSocket</a> 通讯。</p>
<ul>
<li>用户通过 subProtocols，origins 参数来配置其支持的 subprotocol 和 origin 白名单，subProtocols如果不设置，则表示不支持子协议，origins 如果不设置，则表示接受所有 origin 的握手请求；</li>
<li>用户通过 userFunc 来自定义处理升级请求的行为，如处理 cookie 等，传入的 userFunc 要求返回一个 <a href="net/http/http_package_api/http_package_classes.html#class-httpheaders">HttpHeaders</a> 对象，其会通过 101 响应回给客户端（升级失败的请求则不会）；</li>
<li>暂不支持 <a href="net/http/http_package_api/http_package_classes.html#class-websocket">WebSocket</a> 的 extensions，因此如果握手过程中出现 extensions 协商则会抛 <a href="net/http/http_package_api/http_package_exceptions.html#class-websocketexception">WebSocketException</a>；</li>
<li>只支持 HTTP1_1 和 HTTP2_0 向 <a href="net/http/http_package_api/http_package_classes.html#class-websocket">WebSocket</a> 升级。</li>
</ul>
<p>参数：</p>
<ul>
<li>ctx: <a href="net/http/http_package_api/http_package_classes.html#class-httpcontext">HttpContext</a> - Http 请求上下文，将传入给 handler 的直接传给 upgradeFromServer 即可。</li>
<li>subProtocols!: ArrayList&lt;String&gt; - 用户配置的子协议列表，默认值为空，表示不支持。如果用户配置了，则会选取升级请求中最靠前的作为升级后的 <a href="net/http/http_package_api/http_package_classes.html#class-websocket">WebSocket</a> 的子协议，用户可通过调用返回的 <a href="net/http/http_package_api/http_package_classes.html#class-websocket">WebSocket</a> 的 subProtocol 查看子协议。</li>
<li>origins!: ArrayList&lt;String&gt; - 用户配置的同意握手的 origin 的白名单，如果不配置，则同意来自所有 origin 的握手，如果配置了，则只接受来自配置 origin 的握手。</li>
<li>userFunc!: (<a href="net/http/http_package_api/http_package_classes.html#class-httprequest">HttpRequest</a>) -&gt;<a href="net/http/http_package_api/http_package_classes.html#class-httpheaders">HttpHeaders</a> - 用户配置的自定义处理升级请求的函数，该函数返回一个 <a href="net/http/http_package_api/http_package_classes.html#class-httpheaders">HttpHeaders</a>。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-websocket">WebSocket</a> - 升级得到的 <a href="net/http/http_package_api/http_package_classes.html#class-websocket">WebSocket</a> 实例。</li>
</ul>
<h3 id="func-closeconn"><a class="header" href="#func-closeconn">func closeConn()</a></h3>
<pre><code class="language-cangjie">public func closeConn(): Unit
</code></pre>
<p>功能：提供关闭底层 <a href="net/http/http_package_api/http_package_classes.html#class-websocket">WebSocket</a> 连接的函数。</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>直接关闭底层连接。正常的关闭流程需要遵循协议规定的握手流程，即先发送 Close 帧给对端，并等待对端回应的 Close 帧。握手流程结束后方可关闭底层连接。</p>
</blockquote>
<h3 id="func-read"><a class="header" href="#func-read">func read()</a></h3>
<pre><code class="language-cangjie">public func read(): WebSocketFrame
</code></pre>
<p>功能：从连接中读取一个帧，如果连接上数据未就绪会阻塞，非线程安全（即对同一个 <a href="net/http/http_package_api/http_package_classes.html#class-websocket">WebSocket</a> 对象不支持多线程读）。</p>
<p>read 函数返回一个 <a href="net/http/http_package_api/http_package_classes.html#class-websocketframe">WebSocketFrame</a> 对象，用户可以调用 <a href="net/http/http_package_api/http_package_classes.html#class-websocketframe">WebSocketFrame</a> 的 frameType，fin 属性确定其帧类型和是否是分段帧调用。通过 <a href="net/http/http_package_api/http_package_classes.html#class-websocketframe">WebSocketFrame</a> 的 payload 函数得到原始二进制数据数组：Array&lt;UInt8&gt;</p>
<ul>
<li>分段帧的首帧为 fin == false，frameType == TextWebFrame 或 BinaryWebFrame中间帧 fin == false，frameType == ContinuationWebFrame尾帧 fin == true， frameType == ContinuationWebFrame；</li>
<li>非分段帧为     fin == true， frameType != ContinuationWebFrame。</li>
</ul>
<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>数据帧（Text，Binary）可以分段，用户需要多次调用 read 将所有分段帧读完（以下称为接收到完整的 message），再将分段帧的 payload 按接收序拼接Text 帧的 payload 为 UTF-8 编码，用户在接收到完整的 message 后，调用 String.fromUtf8函数将拼接后的 payload 转成字符串Binary 帧的 payload 的意义由使用其的应用确定，用户在接收到完整的 message 后，将拼接后的 payload 传给上层应用；</li>
<li>控制帧（Close，Ping，Pong）不可分段；</li>
<li>控制帧本身不可分段，但其可以穿插在分段的数据帧之间。分段的数据帧之间不可出现其他数据帧，如果用户收到穿插的分段数据帧，则需要当作错误处理；</li>
<li>客户端收到 masked 帧，服务器收到 unmasked 帧，断开底层连接并抛出异常；</li>
<li>rsv1、rsv2、rsv3 位被设置（暂不支持 extensions，因此 rsv 位必须为 0），断开底层连接并抛出异常；</li>
<li>收到无法理解的帧类型（只支持 Continuation，Text，Binary，Close，Ping，Pong），断开底层连接并抛出异常；</li>
<li>收到分段或 payload 长度大于 125 bytes 的控制帧（Close，Ping，Pong），断开底层连接并抛出异常；</li>
<li>收到 payload 长度大于 20M 的帧，断开底层连接并抛出异常；</li>
<li>closeConn 关闭连接后继续调用读，抛出异常。</li>
</ul>
</blockquote>
<p>返回值：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_classes.html#class-websocketframe">WebSocketFrame</a> - 读到的 <a href="net/http/http_package_api/http_package_classes.html#class-websocketframe">WebSocketFrame</a> 对象。</li>
</ul>
<p>异常：</p>
<ul>
<li>SocketException - 底层连接错误。</li>
<li><a href="net/http/http_package_api/http_package_exceptions.html#class-websocketexception">WebSocketException</a> - 收到不符合协议规定的帧，此时会给对端发送 Close 帧说明错误信息，并断开底层连接。</li>
<li><a href="net/http/http_package_api/http_package_exceptions.html#class-connectionexception">ConnectionException</a> - 从连接中读数据时对端已关闭连接抛此异常。</li>
</ul>
<h3 id="func-writewebsocketframetype-arrayuint8-int64"><a class="header" href="#func-writewebsocketframetype-arrayuint8-int64">func write(WebSocketFrameType, Array&lt;UInt8&gt;, Int64)</a></h3>
<pre><code class="language-cangjie">public func write(frameType: WebSocketFrameType, byteArray: Array&lt;UInt8&gt;, frameSize!: Int64 = FRAMESIZE): Unit
</code></pre>
<p>功能：发送数据，非线程安全（即对同一个 <a href="net/http/http_package_api/http_package_classes.html#class-websocket">WebSocket</a> 对象不支持多线程写）。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>write 函数将数据以 <a href="net/http/http_package_api/http_package_classes.html#class-websocket">WebSocket</a> 帧的形式发送给对端；</p>
<ul>
<li>如果发送数据帧（Text，Binary），传入的 byteArray 如果大于 frameSize (默认 4 * 1024 bytes)，我们会将其分成小于等于 frameSize 的 payload 以分段帧的形式发送，否则不分段；</li>
<li>如果发送控制帧（Close，Ping，Pong），传入的 byteArray 的大小需要小于等于 125 bytes，Close 帧的前两个字节为状态码，可用的状态码见 RFC 6455 7.4. Status Codes协议规定，Close 帧发送之后，禁止再发送数据帧，如果发送则会抛出异常；</li>
<li>用户需要自己保证其传入的 byteArray 符合协议，如 Text 帧的 payload 需要是 UTF-8 编码，如果数据帧设置了 frameSize，那么需要大于 0，否则抛出异常；</li>
<li>发送数据帧时，frameSize 小于等于 0，抛出异常；</li>
<li>用户发送控制帧时，传入的数据大于 125 bytes，抛出异常；</li>
<li>用户传入非 Text，Binary，Close，Ping，Pong 类型的帧类型，抛出异常；</li>
<li>发送 Close 帧时传入非法的状态码，或 reason 数据超过 123 bytes，抛出异常；</li>
<li>发送完 Close 帧后继续发送数据帧，抛出异常；</li>
<li>closeConn 关闭连接后调用写，抛出异常。</li>
</ul>
</blockquote>
<p>参数：</p>
<ul>
<li>frameType: <a href="net/http/http_package_api/http_package_enums.html#enum-websocketframetype">WebSocketFrameType</a> - 所需发送的帧的类型。</li>
<li>byteArray: Array&lt;UInt8&gt; - 所需发送的帧的 payload（二进制形式）。</li>
<li>frameSize!: Int64 - 分段帧的大小，默认为 4 * 1024 bytes，frameSize 不会对控制帧生效（控制帧设置了无效）。</li>
</ul>
<p>异常：</p>
<ul>
<li>SocketException - 底层连接错误时抛出异常。</li>
<li><a href="net/http/http_package_api/http_package_exceptions.html#class-websocketexception">WebSocketException</a> - 传入非法的帧类型，或者数据时抛出异常。</li>
</ul>
<h3 id="func-writecloseframeuint16-string"><a class="header" href="#func-writecloseframeuint16-string">func writeCloseFrame(?UInt16, String)</a></h3>
<pre><code class="language-cangjie">public func writeCloseFrame(status!: ?UInt16 = None, reason!: String = &quot;&quot;): Unit
</code></pre>
<p>功能：发送 Close 帧。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>协议规定，Close 帧发送之后，禁止再发送数据帧。如果用户不设置 status，那么 reason 不会被发送（即有 reason 必有 status）；控制帧的 payload 不超过 125 bytes，Close 帧的前两个 bytes 为 status，因此 reason 不能超过 123 bytes，closeConn 关闭连接后调用写，抛出异常。</p>
</blockquote>
<p>参数：</p>
<ul>
<li>status!: ?UInt16 - 发送的 Close 帧的状态码，默认为 None，表示不发送状态码和 reason。</li>
<li>reason!: String - 关闭连接的说明，默认为空字符串，发送时会转成 UTF-8，不保证可读，debug 用。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="net/http/http_package_api/http_package_exceptions.html#class-websocketexception">WebSocketException</a> - 传入非法的状态码，或 reason 数据超过 123 bytes时抛出异常。</li>
</ul>
<h3 id="func-writepingframearrayuint8"><a class="header" href="#func-writepingframearrayuint8">func writePingFrame(Array&lt;UInt8&gt;)</a></h3>
<pre><code class="language-cangjie">public func writePingFrame(byteArray: Array&lt;UInt8&gt;): Unit
</code></pre>
<p>功能：提供发送 Ping 帧的快捷函数，closeConn 关闭连接后调用写，抛出异常。</p>
<p>参数：</p>
<ul>
<li>byteArray: Array&lt;UInt8&gt; - 所需发送的帧的 payload（二进制形式）。</li>
</ul>
<p>异常：</p>
<ul>
<li>SocketException - 底层连接错误时抛出异常。</li>
<li><a href="net/http/http_package_api/http_package_exceptions.html#class-websocketexception">WebSocketException</a> - 传入的数据大于 125 bytes，抛出异常。</li>
</ul>
<h3 id="func-writepongframearrayuint8"><a class="header" href="#func-writepongframearrayuint8">func writePongFrame(Array&lt;UInt8&gt;)</a></h3>
<pre><code class="language-cangjie">public func writePongFrame(byteArray: Array&lt;UInt8&gt;): Unit
</code></pre>
<p>功能：提供发送 Pong 帧的快捷函数，closeConn 关闭连接后调用写，抛出异常。</p>
<p>参数：</p>
<ul>
<li>byteArray: Array&lt;UInt8&gt; - 所需发送的帧的 payload（二进制形式）。</li>
</ul>
<p>异常：</p>
<ul>
<li>SocketException - 底层连接错误时抛出异常。</li>
<li><a href="net/http/http_package_api/http_package_exceptions.html#class-websocketexception">WebSocketException</a> - 传入的数据大于 125 bytes，抛出异常。</li>
</ul>
<h2 id="class-websocketframe"><a class="header" href="#class-websocketframe">class WebSocketFrame</a></h2>
<pre><code class="language-cangjie">public class WebSocketFrame
</code></pre>
<p>功能：<a href="net/http/http_package_api/http_package_classes.html#class-websocket">WebSocket</a> 用于读的基本单元。</p>
<p><a href="net/http/http_package_api/http_package_classes.html#class-websocketframe">WebSocketFrame</a> 提供了三个属性，其中 fin 和 frameType 共同说明了帧是否分段和帧的类型。payload 为帧的载荷。</p>
<ul>
<li>分段帧的首帧为 fin == false，frameType == TextWebFrame 或 BinaryWebFrame；</li>
<li>中间帧 fin == false，frameType == ContinuationWebFrame；</li>
<li>尾帧 fin == true， frameType == ContinuationWebFrame；</li>
<li>非分段帧为     fin == true， frameType != ContinuationWebFrame；</li>
<li>用户仅能通过 <a href="net/http/http_package_api/http_package_classes.html#class-websocket">WebSocket</a> 对象的 read 函数得到 <a href="net/http/http_package_api/http_package_classes.html#class-websocketframe">WebSocketFrame</a>。数据帧可分段，如果用户收到分段帧，则需要多次调用 read 函数直到收到完整的 message，并将所有分段的 payload 按接收顺序拼接。</li>
</ul>
<blockquote>
<p><strong>注意：</strong></p>
<p>由于控制帧可以穿插在分段帧之间，用户在拼接分段帧的 payload 时需要单独处理控制帧。分段帧之间仅可穿插控制帧，如果用户在分段帧之间接收到其他数据帧，则需要当作错误处理。</p>
</blockquote>
<h3 id="prop-fin"><a class="header" href="#prop-fin">prop fin</a></h3>
<pre><code class="language-cangjie">public prop fin: Bool
</code></pre>
<p>功能：获取 <a href="net/http/http_package_api/http_package_classes.html#class-websocketframe">WebSocketFrame</a> 的 fin 属性，fin 与 frameType 共同说明了帧是否分段和帧的类型。</p>
<p>类型：Bool</p>
<h3 id="prop-frametype"><a class="header" href="#prop-frametype">prop frameType</a></h3>
<pre><code class="language-cangjie">public prop frameType: WebSocketFrameType
</code></pre>
<p>功能：获取 <a href="net/http/http_package_api/http_package_classes.html#class-websocketframe">WebSocketFrame</a> 的帧类型，fin 与 frameType 共同说明了帧是否分段和帧的类型。</p>
<p>类型：<a href="net/http/http_package_api/http_package_enums.html#enum-websocketframetype">WebSocketFrameType</a></p>
<h3 id="prop-payload"><a class="header" href="#prop-payload">prop payload</a></h3>
<pre><code class="language-cangjie">public prop payload: Array&lt;UInt8&gt;
</code></pre>
<p>功能：获取 <a href="net/http/http_package_api/http_package_classes.html#class-websocketframe">WebSocketFrame</a> 的帧载荷。如果是分段数据帧，用户需要在接收到完整的 message 后，将所有分段的 payload 按接收序拼接。</p>
<p>类型：Array&lt;UInt8&gt;</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="枚举-11"><a class="header" href="#枚举-11">枚举</a></h1>
<h2 id="enum-filehandlertype"><a class="header" href="#enum-filehandlertype">enum FileHandlerType</a></h2>
<pre><code class="language-cangjie">public enum FileHandlerType {
    | DownLoad
    | UpLoad
}
</code></pre>
<p>功能：用于设置 <a href="net/http/http_package_api/http_package_classes.html#class-filehandler">FileHandler</a> 是上传还是下载模式。</p>
<h3 id="download"><a class="header" href="#download">DownLoad</a></h3>
<pre><code class="language-cangjie">DownLoad
</code></pre>
<p>功能：设置 <a href="net/http/http_package_api/http_package_classes.html#class-filehandler">FileHandler</a> 为下载模式。</p>
<h3 id="upload"><a class="header" href="#upload">UpLoad</a></h3>
<pre><code class="language-cangjie">UpLoad
</code></pre>
<p>功能：设置 <a href="net/http/http_package_api/http_package_classes.html#class-filehandler">FileHandler</a> 为上传模式。</p>
<h2 id="enum-protocol"><a class="header" href="#enum-protocol">enum Protocol</a></h2>
<pre><code class="language-cangjie">public enum Protocol &lt;: Equatable&lt;Protocol&gt; &amp; ToString {
    | HTTP1_0
    | HTTP1_1
    | HTTP2_0
    | UnknownProtocol(String)
}
</code></pre>
<p>功能：定义 HTTP 协议类型枚举。</p>
<p>父类型：</p>
<ul>
<li>Equatable&lt;<a href="net/http/http_package_api/http_package_enums.html#enum-protocol">Protocol</a>&gt;</li>
<li>ToString</li>
</ul>
<h3 id="http1_0"><a class="header" href="#http1_0">HTTP1_0</a></h3>
<pre><code class="language-cangjie">HTTP1_0
</code></pre>
<p>功能：定义 1.0 版本 HTTP 协议。</p>
<h3 id="http1_1"><a class="header" href="#http1_1">HTTP1_1</a></h3>
<pre><code class="language-cangjie">HTTP1_1
</code></pre>
<p>功能：定义 1.1 版本 HTTP 协议。</p>
<h3 id="http2_0"><a class="header" href="#http2_0">HTTP2_0</a></h3>
<pre><code class="language-cangjie">HTTP2_0
</code></pre>
<p>功能：定义 2.0 版本 HTTP 协议。</p>
<h3 id="unknownprotocolstring"><a class="header" href="#unknownprotocolstring">UnknownProtocol(String)</a></h3>
<pre><code class="language-cangjie">UnknownProtocol(String)
</code></pre>
<p>功能：定义未知 HTTP 协议。</p>
<h3 id="func-tostring-31"><a class="header" href="#func-tostring-31">func toString()</a></h3>
<pre><code class="language-cangjie">public override func toString(): String
</code></pre>
<p>功能：获取 Http 协议版本字符串。</p>
<p>返回值：</p>
<ul>
<li>String - Http 协议版本字符串。</li>
</ul>
<h3 id="operator-func--protocol"><a class="header" href="#operator-func--protocol">operator func != (Protocol)</a></h3>
<pre><code class="language-cangjie">public override operator func != (that: Protocol): Bool
</code></pre>
<p>功能：判断枚举值是否不相等。</p>
<p>参数：</p>
<ul>
<li>that: <a href="net/http/http_package_api/http_package_enums.html#enum-protocol">Protocol</a> - 被比较的枚举值。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - 当前实例与 <code>that</code> 不等，返回 <code>true</code>；否则返回 <code>false</code>。</li>
</ul>
<h3 id="operator-func--protocol-1"><a class="header" href="#operator-func--protocol-1">operator func == (Protocol)</a></h3>
<pre><code class="language-cangjie">public override operator func == (that: Protocol): Bool
</code></pre>
<p>功能：判断枚举值是否相等。</p>
<p>参数：</p>
<ul>
<li>that: <a href="net/http/http_package_api/http_package_enums.html#enum-protocol">Protocol</a> - 被比较的枚举值。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - 当前实例与 <code>that</code> 相等，返回 <code>true</code>；否则返回 <code>false</code>。</li>
</ul>
<h2 id="enum-websocketframetype"><a class="header" href="#enum-websocketframetype">enum WebSocketFrameType</a></h2>
<pre><code class="language-cangjie">public enum WebSocketFrameType &lt;: Equatable&lt;WebSocketFrameType&gt; &amp; ToString {
    | ContinuationWebFrame
    | TextWebFrame
    | BinaryWebFrame
    | CloseWebFrame
    | PingWebFrame
    | PongWebFrame
    | UnknownWebFrame
}
</code></pre>
<p>功能：定义 <a href="net/http/http_package_api/http_package_classes.html#class-websocketframe">WebSocketFrame</a> 的枚举类型。</p>
<p>父类型：</p>
<ul>
<li>Equatable&lt;<a href="net/http/http_package_api/http_package_enums.html#enum-websocketframetype">WebSocketFrameType</a>&gt;</li>
<li>ToString</li>
</ul>
<h3 id="continuationwebframe"><a class="header" href="#continuationwebframe">ContinuationWebFrame</a></h3>
<pre><code class="language-cangjie">ContinuationWebFrame
</code></pre>
<p>功能：定义 websocket 协议中的未结束的分片帧。</p>
<h3 id="textwebframe"><a class="header" href="#textwebframe">TextWebFrame</a></h3>
<pre><code class="language-cangjie">TextWebFrame
</code></pre>
<p>功能：定义 websocket 协议中的文本帧。</p>
<h3 id="binarywebframe"><a class="header" href="#binarywebframe">BinaryWebFrame</a></h3>
<pre><code class="language-cangjie">BinaryWebFrame
</code></pre>
<p>功能：定义 websocket 协议中的数据帧。</p>
<h3 id="closewebframe"><a class="header" href="#closewebframe">CloseWebFrame</a></h3>
<pre><code class="language-cangjie">CloseWebFrame
</code></pre>
<p>功能：定义 websocket 协议中的关闭帧。</p>
<h3 id="pingwebframe"><a class="header" href="#pingwebframe">PingWebFrame</a></h3>
<pre><code class="language-cangjie">PingWebFrame
</code></pre>
<p>功能：定义 websocket 协议中的心跳帧。</p>
<h3 id="pongwebframe"><a class="header" href="#pongwebframe">PongWebFrame</a></h3>
<pre><code class="language-cangjie">PongWebFrame
</code></pre>
<p>功能：定义 websocket 协议中的心跳帧。</p>
<h3 id="unknownwebframe"><a class="header" href="#unknownwebframe">UnknownWebFrame</a></h3>
<pre><code class="language-cangjie">UnknownWebFrame
</code></pre>
<p>功能：定义 websocket 协议中的未知类型帧。</p>
<h3 id="func-tostring-32"><a class="header" href="#func-tostring-32">func toString()</a></h3>
<pre><code class="language-cangjie">public override func toString(): String
</code></pre>
<p>功能：获取 <a href="net/http/http_package_api/http_package_classes.html#class-websocket">WebSocket</a> 帧类型字符串。</p>
<p>返回值：</p>
<ul>
<li>String - <a href="net/http/http_package_api/http_package_classes.html#class-websocket">WebSocket</a> 帧类型字符串。</li>
</ul>
<h3 id="operator-func--websocketframetype"><a class="header" href="#operator-func--websocketframetype">operator func != (WebSocketFrameType)</a></h3>
<pre><code class="language-cangjie">public override operator func != (that: WebSocketFrameType): Bool
</code></pre>
<p>功能：判断枚举值是否不相等。</p>
<p>参数：</p>
<ul>
<li>that: <a href="net/http/http_package_api/http_package_enums.html#enum-websocketframetype">WebSocketFrameType</a> - 被比较的枚举值。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - 当前实例与 <code>that</code> 不等返回 <code>true</code>，否则返回 <code>false</code>。</li>
</ul>
<h3 id="operator-func--websocketframetype-1"><a class="header" href="#operator-func--websocketframetype-1">operator func == (WebSocketFrameType)</a></h3>
<pre><code class="language-cangjie">public override operator func == (that: WebSocketFrameType): Bool
</code></pre>
<p>功能：判断枚举值是否相等。</p>
<p>参数：</p>
<ul>
<li>that: <a href="net/http/http_package_api/http_package_enums.html#enum-websocketframetype">WebSocketFrameType</a> - 被比较的枚举值。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - 当前实例与 <code>that</code> 相等返回 <code>true</code>，否则返回 <code>false</code>。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="结构体-13"><a class="header" href="#结构体-13">结构体</a></h1>
<h2 id="struct-httpstatuscode"><a class="header" href="#struct-httpstatuscode">struct HttpStatusCode</a></h2>
<pre><code class="language-cangjie">public struct HttpStatusCode {
    public static const STATUS_CONTINUE: UInt16 =                        100
    public static const STATUS_SWITCHING_PROTOCOLS: UInt16 =             101
    public static const STATUS_PROCESSING: UInt16 =                      102
    public static const STATUS_EARLY_HINTS: UInt16 =                     103
 
    public static const STATUS_OK: UInt16 =                              200
    public static const STATUS_CREATED: UInt16 =                         201
    public static const STATUS_ACCEPTED: UInt16 =                        202
    public static const STATUS_NON_AUTHORITATIVE_INFO: UInt16 =          203
    public static const STATUS_NO_CONTENT: UInt16 =                      204
    public static const STATUS_RESET_CONTENT: UInt16 =                   205
    public static const STATUS_PARTIAL_CONTENT: UInt16 =                 206
    public static const STATUS_MULTI_STATUS: UInt16 =                    207
    public static const STATUS_ALREADY_REPORTED: UInt16 =                208
    public static const STATUS_IM_USED: UInt16 =                         226
 
    public static const STATUS_MULTIPLE_CHOICES: UInt16 =                300
    public static const STATUS_MOVED_PERMANENTLY: UInt16 =               301
    public static const STATUS_FOUND: UInt16 =                           302
    public static const STATUS_SEE_OTHER: UInt16 =                       303
    public static const STATUS_NOT_MODIFIED: UInt16 =                    304
    public static const STATUS_USE_PROXY: UInt16 =                       305
    public static const STATUS_TEMPORARY_REDIRECT: UInt16 =              307
    public static const STATUS_PERMANENT_REDIRECT: UInt16 =              308
 
    public static const STATUS_BAD_REQUEST: UInt16 =                     400
    public static const STATUS_UNAUTHORIZED: UInt16 =                    401
    public static const STATUS_PAYMENT_REQUIRED: UInt16 =                402
    public static const STATUS_FORBIDDEN: UInt16 =                       403
    public static const STATUS_NOT_FOUND: UInt16 =                       404
    public static const STATUS_METHOD_NOT_ALLOWED: UInt16 =              405
    public static const STATUS_NOT_ACCEPTABLE: UInt16 =                  406
    public static const STATUS_PROXY_AUTH_REQUIRED: UInt16 =             407
    public static const STATUS_REQUEST_TIMEOUT: UInt16 =                 408
    public static const STATUS_CONFLICT: UInt16 =                        409
    public static const STATUS_GONE: UInt16 =                            410
    public static const STATUS_LENGTH_REQUIRED: UInt16 =                 411
    public static const STATUS_PRECONDITION_FAILED: UInt16 =             412
    public static const STATUS_REQUEST_CONTENT_TOO_LARGE: UInt16 =       413
    public static const STATUS_REQUEST_URI_TOO_LONG: UInt16 =            414
    public static const STATUS_UNSUPPORTED_MEDIA_TYPE: UInt16 =          415
    public static const STATUS_REQUESTED_RANGE_NOT_SATISFIABLE: UInt16 = 416
    public static const STATUS_EXPECTATION_FAILED: UInt16 =              417
    public static const STATUS_TEAPOT: UInt16 =                          418
    public static const STATUS_MISDIRECTED_REQUEST: UInt16 =             421
    public static const STATUS_UNPROCESSABLE_ENTITY: UInt16 =            422
    public static const STATUS_LOCKED: UInt16 =                          423
    public static const STATUS_FAILED_DEPENDENCY: UInt16 =               424
    public static const STATUS_TOO_EARLY: UInt16 =                       425
    public static const STATUS_UPGRADE_REQUIRED: UInt16 =                426
    public static const STATUS_PRECONDITION_REQUIRED: UInt16 =           428
    public static const STATUS_TOO_MANY_REQUESTS: UInt16 =               429
    public static const STATUS_REQUEST_HEADER_FIELDS_TOO_LARGE: UInt16 = 431
    public static const STATUS_UNAVAILABLE_FOR_LEGAL_REASONS: UInt16 =   451
 
    public static const STATUS_INTERNAL_SERVER_ERROR: UInt16 =           500
    public static const STATUS_NOT_IMPLEMENTED: UInt16 =                 501
    public static const STATUS_BAD_GATEWAY: UInt16 =                     502
    public static const STATUS_SERVICE_UNAVAILABLE: UInt16 =             503
    public static const STATUS_GATEWAY_TIMEOUT: UInt16 =                 504
    public static const STATUS_HTTP_VERSION_NOT_SUPPORTED: UInt16 =      505
    public static const STATUS_VARIANT_ALSO_NEGOTIATES: UInt16 =         506
    public static const STATUS_INSUFFICIENT_STORAGE: UInt16 =            507
    public static const STATUS_LOOP_DETECTED: UInt16 =                   508
    public static const STATUS_NOT_EXTENDED: UInt16 =                    510
    public static const STATUS_NETWORK_AUTHENTICATION_REQUIRED: UInt16 = 511
}
</code></pre>
<p>功能：用来表示网页服务器超文本传输协议响应状态的 3 位数字代码。</p>
<p>状态码由 RFC 9110 规范定义，并得到 RFC2518、RFC 3229、RFC 4918、RFC 5842、RFC 7168 与 RFC 8297 等规范扩展。</p>
<p>所有状态码的第一个数字代表了响应的五种状态之一：</p>
<ul>
<li>状态代码的 1xx（信息）指示在完成请求的操作并发送最终响应之前通信连接状态或请求进度的临时响应。</li>
<li>状态代码的 2xx（成功）指示客户端的请求已成功接收、理解和接受。</li>
<li>状态代码的 3xx（重定向）指示用户代理需要采取进一步的操作才能完成请求。</li>
<li>状态代码的 4xx（客户端错误）指示客户端似乎出错。</li>
<li>状态代码的 5xx（服务器错误）指示服务器意识到它出错或无法执行请求的方法。</li>
</ul>
<h3 id="static-const-status_accepted"><a class="header" href="#static-const-status_accepted">static const STATUS_ACCEPTED</a></h3>
<pre><code class="language-cangjie">public static const STATUS_ACCEPTED: UInt16 = 202
</code></pre>
<p>功能：服务器已接受请求，但尚未处理。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_already_reported"><a class="header" href="#static-const-status_already_reported">static const STATUS_ALREADY_REPORTED</a></h3>
<pre><code class="language-cangjie">public static const STATUS_ALREADY_REPORTED: UInt16 = 208
</code></pre>
<p>功能：消息体将是一个 XML 消息。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_bad_gateway"><a class="header" href="#static-const-status_bad_gateway">static const STATUS_BAD_GATEWAY</a></h3>
<pre><code class="language-cangjie">public static const STATUS_BAD_GATEWAY: UInt16 = 502
</code></pre>
<p>功能：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_bad_request"><a class="header" href="#static-const-status_bad_request">static const STATUS_BAD_REQUEST</a></h3>
<pre><code class="language-cangjie">public static const STATUS_BAD_REQUEST: UInt16 = 400
</code></pre>
<p>功能：语义有误，当前请求无法被服务器理解；或请求参数有误。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_conflict"><a class="header" href="#static-const-status_conflict">static const STATUS_CONFLICT</a></h3>
<pre><code class="language-cangjie">public static const STATUS_CONFLICT: UInt16 = 409
</code></pre>
<p>功能：由于和被请求的资源的当前状态之间存在冲突，请求无法完成。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_continue"><a class="header" href="#static-const-status_continue">static const STATUS_CONTINUE</a></h3>
<pre><code class="language-cangjie">public static const STATUS_CONTINUE: UInt16 = 100
</code></pre>
<p>功能：这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。</p>
<p>类型：Int64</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。
服务器必须在请求完成后向客户端发送一个最终响应。</p>
</blockquote>
<h3 id="static-const-status_created"><a class="header" href="#static-const-status_created">static const STATUS_CREATED</a></h3>
<pre><code class="language-cangjie">public static const STATUS_CREATED: UInt16 = 201
</code></pre>
<p>功能：请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随 Location 头信息返回。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_early_hints"><a class="header" href="#static-const-status_early_hints">static const STATUS_EARLY_HINTS</a></h3>
<pre><code class="language-cangjie">public static const STATUS_EARLY_HINTS: UInt16 = 103
</code></pre>
<p>功能：提前预加载 (css、js) 文档。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_expectation_failed"><a class="header" href="#static-const-status_expectation_failed">static const STATUS_EXPECTATION_FAILED</a></h3>
<pre><code class="language-cangjie">public static const STATUS_EXPECTATION_FAILED: UInt16 = 417
</code></pre>
<p>功能：服务器无法满足 Expect 的请求头信息。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_failed_dependency"><a class="header" href="#static-const-status_failed_dependency">static const STATUS_FAILED_DEPENDENCY</a></h3>
<pre><code class="language-cangjie">public static const STATUS_FAILED_DEPENDENCY: UInt16 = 424
</code></pre>
<p>功能：由于之前的某个请求发生的错误，导致当前请求失败。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_forbidden"><a class="header" href="#static-const-status_forbidden">static const STATUS_FORBIDDEN</a></h3>
<pre><code class="language-cangjie">public static const STATUS_FORBIDDEN: UInt16 = 403
</code></pre>
<p>功能：服务器已经理解请求，但是拒绝执行。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_found"><a class="header" href="#static-const-status_found">static const STATUS_FOUND</a></h3>
<pre><code class="language-cangjie">public static const STATUS_FOUND: UInt16 = 302
</code></pre>
<p>功能：临时移动。</p>
<p>类型：Int64</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>请求的资源已被临时的移动到新 URI，客户端应当继续向原有地址发送以后的请求。</p>
</blockquote>
<h3 id="static-const-status_gateway_timeout"><a class="header" href="#static-const-status_gateway_timeout">static const STATUS_GATEWAY_TIMEOUT</a></h3>
<pre><code class="language-cangjie">public static const STATUS_GATEWAY_TIMEOUT: UInt16 = 504
</code></pre>
<p>功能：从上游服务器（URI 标识出的服务器，例如 HTTP、FTP、LDAP）或者辅助服务器（例如 DNS）收到响应超时。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_gone"><a class="header" href="#static-const-status_gone">static const STATUS_GONE</a></h3>
<pre><code class="language-cangjie">public static const STATUS_GONE: UInt16 = 410
</code></pre>
<p>功能：被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_http_version_not_supported"><a class="header" href="#static-const-status_http_version_not_supported">static const STATUS_HTTP_VERSION_NOT_SUPPORTED</a></h3>
<pre><code class="language-cangjie">public static const STATUS_HTTP_VERSION_NOT_SUPPORTED: UInt16 = 505
</code></pre>
<p>功能：服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_im_used"><a class="header" href="#static-const-status_im_used">static const STATUS_IM_USED</a></h3>
<pre><code class="language-cangjie">public static const STATUS_IM_USED: UInt16 = 226
</code></pre>
<p>功能：服务器已完成对资源的请求，并且响应是应用于当前实例的一个或多个实例操作的结果的表示。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_insufficient_storage"><a class="header" href="#static-const-status_insufficient_storage">static const STATUS_INSUFFICIENT_STORAGE</a></h3>
<pre><code class="language-cangjie">public static const STATUS_INSUFFICIENT_STORAGE: UInt16 = 507
</code></pre>
<p>功能：服务器无法存储完成请求所必须的内容。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_internal_server_error"><a class="header" href="#static-const-status_internal_server_error">static const STATUS_INTERNAL_SERVER_ERROR</a></h3>
<pre><code class="language-cangjie">public static const STATUS_INTERNAL_SERVER_ERROR: UInt16 = 500
</code></pre>
<p>功能：服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_length_required"><a class="header" href="#static-const-status_length_required">static const STATUS_LENGTH_REQUIRED</a></h3>
<pre><code class="language-cangjie">public static const STATUS_LENGTH_REQUIRED: UInt16 = 411
</code></pre>
<p>功能：服务器拒绝在没有定义 Content-Length 头的情况下接受请求。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_locked"><a class="header" href="#static-const-status_locked">static const STATUS_LOCKED</a></h3>
<pre><code class="language-cangjie">public static const STATUS_LOCKED: UInt16 = 423
</code></pre>
<p>功能：当前资源被锁定。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_loop_detected"><a class="header" href="#static-const-status_loop_detected">static const STATUS_LOOP_DETECTED</a></h3>
<pre><code class="language-cangjie">public static const STATUS_LOOP_DETECTED: UInt16 = 508
</code></pre>
<p>功能：服务器在处理请求时检测到无限递归。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_method_not_allowed"><a class="header" href="#static-const-status_method_not_allowed">static const STATUS_METHOD_NOT_ALLOWED</a></h3>
<pre><code class="language-cangjie">public static const STATUS_METHOD_NOT_ALLOWED: UInt16 = 405
</code></pre>
<p>功能：请求行中指定的请求函数不能被用于请求响应的资源。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_misdirected_request"><a class="header" href="#static-const-status_misdirected_request">static const STATUS_MISDIRECTED_REQUEST</a></h3>
<pre><code class="language-cangjie">public static const STATUS_MISDIRECTED_REQUEST: UInt16 = 421
</code></pre>
<p>功能：请求被指向到无法生成响应的服务器。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_moved_permanently"><a class="header" href="#static-const-status_moved_permanently">static const STATUS_MOVED_PERMANENTLY</a></h3>
<pre><code class="language-cangjie">public static const STATUS_MOVED_PERMANENTLY: UInt16 = 301
</code></pre>
<p>功能：永久移动。</p>
<p>类型：Int64</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>请求的资源已被永久的移动到新 URI，返回信息会包括新的 URI，浏览器会自动定向到新 URI。</p>
</blockquote>
<h3 id="static-const-status_multiple_choices"><a class="header" href="#static-const-status_multiple_choices">static const STATUS_MULTIPLE_CHOICES</a></h3>
<pre><code class="language-cangjie">public static const STATUS_MULTIPLE_CHOICES: UInt16 = 300
</code></pre>
<p>功能：被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。</p>
<p>类型：Int64</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>用户或浏览器能够自行选择一个首选的地址进行重定向。</p>
</blockquote>
<h3 id="static-const-status_multi_status"><a class="header" href="#static-const-status_multi_status">static const STATUS_MULTI_STATUS</a></h3>
<pre><code class="language-cangjie">public static const STATUS_MULTI_STATUS: UInt16 = 207
</code></pre>
<p>功能：DAV 绑定的成员已经在（多状态）响应之前的部分被列举，且未被再次包含。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_network_authentication_required"><a class="header" href="#static-const-status_network_authentication_required">static const STATUS_NETWORK_AUTHENTICATION_REQUIRED</a></h3>
<pre><code class="language-cangjie">public static const STATUS_NETWORK_AUTHENTICATION_REQUIRED: UInt16 = 511
</code></pre>
<p>功能：要求网络认证。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_non_authoritative_info"><a class="header" href="#static-const-status_non_authoritative_info">static const STATUS_NON_AUTHORITATIVE_INFO</a></h3>
<pre><code class="language-cangjie">public static const STATUS_NON_AUTHORITATIVE_INFO: UInt16 = 203
</code></pre>
<p>功能：服务器已成功处理了请求。</p>
<p>类型：Int64</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。</p>
</blockquote>
<h3 id="static-const-status_not_acceptable"><a class="header" href="#static-const-status_not_acceptable">static const STATUS_NOT_ACCEPTABLE</a></h3>
<pre><code class="language-cangjie">public static const STATUS_NOT_ACCEPTABLE: UInt16 = 406
</code></pre>
<p>功能：请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_not_extended"><a class="header" href="#static-const-status_not_extended">static const STATUS_NOT_EXTENDED</a></h3>
<pre><code class="language-cangjie">public static const STATUS_NOT_EXTENDED: UInt16 = 510
</code></pre>
<p>功能：获取资源所需要的策略并没有被满足。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_not_found"><a class="header" href="#static-const-status_not_found">static const STATUS_NOT_FOUND</a></h3>
<pre><code class="language-cangjie">public static const STATUS_NOT_FOUND: UInt16 = 404
</code></pre>
<p>功能：请求失败，请求所希望得到的资源未被在服务器上发现。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_not_implemented"><a class="header" href="#static-const-status_not_implemented">static const STATUS_NOT_IMPLEMENTED</a></h3>
<pre><code class="language-cangjie">public static const STATUS_NOT_IMPLEMENTED: UInt16 = 501
</code></pre>
<p>功能：服务器不支持当前请求所需要的某个功能。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_not_modified"><a class="header" href="#static-const-status_not_modified">static const STATUS_NOT_MODIFIED</a></h3>
<pre><code class="language-cangjie">public static const STATUS_NOT_MODIFIED: UInt16 = 304
</code></pre>
<p>功能：请求的资源未修改，服务器返回此状态码时，不会返回任何资源。</p>
<p>类型：Int64</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源。</p>
</blockquote>
<h3 id="static-const-status_no_content"><a class="header" href="#static-const-status_no_content">static const STATUS_NO_CONTENT</a></h3>
<pre><code class="language-cangjie">public static const STATUS_NO_CONTENT: UInt16 = 204
</code></pre>
<p>功能：服务器成功处理，但未返回内容。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_ok"><a class="header" href="#static-const-status_ok">static const STATUS_OK</a></h3>
<pre><code class="language-cangjie">public static const STATUS_OK: UInt16 = 200
</code></pre>
<p>功能：请求已经成功，请求所希望的响应头或数据体将随此响应返回。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_partial_content"><a class="header" href="#static-const-status_partial_content">static const STATUS_PARTIAL_CONTENT</a></h3>
<pre><code class="language-cangjie">public static const STATUS_PARTIAL_CONTENT: UInt16 = 206
</code></pre>
<p>功能：服务器已经成功处理了部分 GET 请求。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_payment_required"><a class="header" href="#static-const-status_payment_required">static const STATUS_PAYMENT_REQUIRED</a></h3>
<pre><code class="language-cangjie">public static const STATUS_PAYMENT_REQUIRED: UInt16 = 402
</code></pre>
<p>功能：为了将来可能的需求而预留的状态码。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_permanent_redirect"><a class="header" href="#static-const-status_permanent_redirect">static const STATUS_PERMANENT_REDIRECT</a></h3>
<pre><code class="language-cangjie">public static const STATUS_PERMANENT_REDIRECT: UInt16 = 308
</code></pre>
<p>功能：请求和所有将来的请求应该使用另一个 URI。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_precondition_failed"><a class="header" href="#static-const-status_precondition_failed">static const STATUS_PRECONDITION_FAILED</a></h3>
<pre><code class="language-cangjie">public static const STATUS_PRECONDITION_FAILED: UInt16 = 412
</code></pre>
<p>功能：服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_precondition_required"><a class="header" href="#static-const-status_precondition_required">static const STATUS_PRECONDITION_REQUIRED</a></h3>
<pre><code class="language-cangjie">public static const STATUS_PRECONDITION_REQUIRED: UInt16 = 428
</code></pre>
<p>功能：客户端发送 HTTP 请求时，必须要满足的一些预设条件。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_processing"><a class="header" href="#static-const-status_processing">static const STATUS_PROCESSING</a></h3>
<pre><code class="language-cangjie">public static const STATUS_PROCESSING: UInt16 = 102
</code></pre>
<p>功能：处理将被继续执行。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_proxy_auth_required"><a class="header" href="#static-const-status_proxy_auth_required">static const STATUS_PROXY_AUTH_REQUIRED</a></h3>
<pre><code class="language-cangjie">public static const STATUS_PROXY_AUTH_REQUIRED: UInt16 = 407
</code></pre>
<p>功能：必须在代理服务器上进行身份验证。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_requested_range_not_satisfiable"><a class="header" href="#static-const-status_requested_range_not_satisfiable">static const STATUS_REQUESTED_RANGE_NOT_SATISFIABLE</a></h3>
<pre><code class="language-cangjie">public static const STATUS_REQUESTED_RANGE_NOT_SATISFIABLE: UInt16 = 416
</code></pre>
<p>功能：客户端请求的范围无效。</p>
<p>类型：Int64</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>请求中包含了 <code>Range</code> 请求头，并且 <code>Range</code> 中指定的任何数据范围都与当前资源的可用范围不重合；
同时请求中又没有定义 <code>If-Range</code> 请求头。</p>
</blockquote>
<h3 id="static-const-status_request_content_too_large"><a class="header" href="#static-const-status_request_content_too_large">static const STATUS_REQUEST_CONTENT_TOO_LARGE</a></h3>
<pre><code class="language-cangjie">public static const STATUS_REQUEST_CONTENT_TOO_LARGE: UInt16 = 413
</code></pre>
<p>功能：请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_request_header_fields_too_large"><a class="header" href="#static-const-status_request_header_fields_too_large">static const STATUS_REQUEST_HEADER_FIELDS_TOO_LARGE</a></h3>
<pre><code class="language-cangjie">public static const STATUS_REQUEST_HEADER_FIELDS_TOO_LARGE: UInt16 = 431
</code></pre>
<p>功能：请求头字段太大。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_request_timeout"><a class="header" href="#static-const-status_request_timeout">static const STATUS_REQUEST_TIMEOUT</a></h3>
<pre><code class="language-cangjie">public static const STATUS_REQUEST_TIMEOUT: UInt16 = 408
</code></pre>
<p>功能：请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_request_uri_too_long"><a class="header" href="#static-const-status_request_uri_too_long">static const STATUS_REQUEST_URI_TOO_LONG</a></h3>
<pre><code class="language-cangjie">public static const STATUS_REQUEST_URI_TOO_LONG: UInt16 = 414
</code></pre>
<p>功能：求的 URI 长度超过了服务器能够解释的长度。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_reset_content"><a class="header" href="#static-const-status_reset_content">static const STATUS_RESET_CONTENT</a></h3>
<pre><code class="language-cangjie">public static const STATUS_RESET_CONTENT: UInt16 = 205
</code></pre>
<p>功能：服务器成功处理了请求，且没有返回任何内容，希望请求者重置文档视图。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_see_other"><a class="header" href="#static-const-status_see_other">static const STATUS_SEE_OTHER</a></h3>
<pre><code class="language-cangjie">public static const STATUS_SEE_OTHER: UInt16 = 303
</code></pre>
<p>功能：对应当前请求的响应可以在另一个 <a href="net/http/http_package_api/../../../encoding/url/url_package_api/url_package_classes.html#class-url">URL</a> 上被找到，而且客户端应当采用 GET 的方式访问那个资源。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_service_unavailable"><a class="header" href="#static-const-status_service_unavailable">static const STATUS_SERVICE_UNAVAILABLE</a></h3>
<pre><code class="language-cangjie">public static const STATUS_SERVICE_UNAVAILABLE: UInt16 = 503
</code></pre>
<p>功能：临时的服务器维护或者过载。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_switching_protocols"><a class="header" href="#static-const-status_switching_protocols">static const STATUS_SWITCHING_PROTOCOLS</a></h3>
<pre><code class="language-cangjie">public static const STATUS_SWITCHING_PROTOCOLS: UInt16 = 101
</code></pre>
<p>功能：服务器已经理解了客户端的请求，并将通过 Upgrade 消息头通知客户端采用不同的协议来完成这个请求。</p>
<p>类型：Int64</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>在发送完这个响应最后的空行后，服务器将会切换到在 Upgrade 消息头中定义的那些协议。</p>
</blockquote>
<h3 id="static-const-status_teapot"><a class="header" href="#static-const-status_teapot">static const STATUS_TEAPOT</a></h3>
<pre><code class="language-cangjie">public static const STATUS_TEAPOT: UInt16 = 418
</code></pre>
<p>功能：服务端无法处理请求，一个愚弄客户端的状态码，被称为“我是茶壶”错误码，不应被认真对待。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_temporary_redirect"><a class="header" href="#static-const-status_temporary_redirect">static const STATUS_TEMPORARY_REDIRECT</a></h3>
<pre><code class="language-cangjie">public static const STATUS_TEMPORARY_REDIRECT: UInt16 = 307
</code></pre>
<p>功能：临时重定向。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_too_early"><a class="header" href="#static-const-status_too_early">static const STATUS_TOO_EARLY</a></h3>
<pre><code class="language-cangjie">public static const STATUS_TOO_EARLY: UInt16 = 425
</code></pre>
<p>功能：服务器不愿意冒风险来处理该请求。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_too_many_requests"><a class="header" href="#static-const-status_too_many_requests">static const STATUS_TOO_MANY_REQUESTS</a></h3>
<pre><code class="language-cangjie">public static const STATUS_TOO_MANY_REQUESTS: UInt16 = 429
</code></pre>
<p>功能：请求过多。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_unauthorized"><a class="header" href="#static-const-status_unauthorized">static const STATUS_UNAUTHORIZED</a></h3>
<pre><code class="language-cangjie">public static const STATUS_UNAUTHORIZED: UInt16 = 401
</code></pre>
<p>功能：当前请求需要用户验证。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_unavailable_for_legal_reasons"><a class="header" href="#static-const-status_unavailable_for_legal_reasons">static const STATUS_UNAVAILABLE_FOR_LEGAL_REASONS</a></h3>
<pre><code class="language-cangjie">public static const STATUS_UNAVAILABLE_FOR_LEGAL_REASONS: UInt16 = 451
</code></pre>
<p>功能：该请求因法律原因不可用。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_unprocessable_entity"><a class="header" href="#static-const-status_unprocessable_entity">static const STATUS_UNPROCESSABLE_ENTITY</a></h3>
<pre><code class="language-cangjie">public static const STATUS_UNPROCESSABLE_ENTITY: UInt16 = 422
</code></pre>
<p>功能：请求格式正确，但是由于含有语义错误，无法响应。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_unsupported_media_type"><a class="header" href="#static-const-status_unsupported_media_type">static const STATUS_UNSUPPORTED_MEDIA_TYPE</a></h3>
<pre><code class="language-cangjie">public static const STATUS_UNSUPPORTED_MEDIA_TYPE: UInt16 = 415
</code></pre>
<p>功能：服务器无法处理请求附带的媒体格式。</p>
<p>类型：Int64</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>对于当前请求的函数和所请求的资源，请求中提交的实体并不是服务器中所支持的格式。</p>
</blockquote>
<h3 id="static-const-status_upgrade_required"><a class="header" href="#static-const-status_upgrade_required">static const STATUS_UPGRADE_REQUIRED</a></h3>
<pre><code class="language-cangjie">public static const STATUS_UPGRADE_REQUIRED: UInt16 = 426
</code></pre>
<p>功能：服务器拒绝处理客户端使用当前协议发送的请求，但是可以接受其使用升级后的协议发送的请求。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_use_proxy"><a class="header" href="#static-const-status_use_proxy">static const STATUS_USE_PROXY</a></h3>
<pre><code class="language-cangjie">public static const STATUS_USE_PROXY: UInt16 = 305
</code></pre>
<p>功能：使用代理，所请求的资源必须通过代理访问。</p>
<p>类型：Int64</p>
<h3 id="static-const-status_variant_also_negotiates"><a class="header" href="#static-const-status_variant_also_negotiates">static const STATUS_VARIANT_ALSO_NEGOTIATES</a></h3>
<pre><code class="language-cangjie">public static const STATUS_VARIANT_ALSO_NEGOTIATES: UInt16 = 506
</code></pre>
<p>功能：服务器存在内部配置错误。</p>
<p>类型：Int64</p>
<h2 id="struct-servicepoolconfig"><a class="header" href="#struct-servicepoolconfig">struct ServicePoolConfig</a></h2>
<pre><code class="language-cangjie">public struct ServicePoolConfig {
    public let capacity: Int64
    public let queueCapacity: Int64
    public let preheat: Int64
    public init(capacity!: Int64 = 10 ** 4, queueCapacity!: Int64 = 10 ** 4, preheat!: Int64 = 0)
}
</code></pre>
<p>功能：Http <a href="net/http/http_package_api/http_package_classes.html#class-server">Server</a> 协程池配置。</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>HTTP/1.1 <a href="net/http/http_package_api/http_package_classes.html#class-server">Server</a> 每次收到一个请求，将从协程池取出一个协程进行处理，如果任务等待队列已满，将拒绝服务该次请求，并断开连接。
HTTP/2 <a href="net/http/http_package_api/http_package_classes.html#class-server">Server</a> 处理过程中会从协程池取出若干协程进行处理，如果任务等待队列已满，将阻塞直至有协程空闲。</p>
</blockquote>
<h3 id="let-capacity"><a class="header" href="#let-capacity">let capacity</a></h3>
<pre><code class="language-cangjie">public let capacity: Int64
</code></pre>
<p>功能：获取协程池容量。</p>
<p>类型：Int64</p>
<h3 id="let-preheat"><a class="header" href="#let-preheat">let preheat</a></h3>
<pre><code class="language-cangjie">public let preheat: Int64
</code></pre>
<p>功能：获取服务启动时预先启动的协程数量。</p>
<p>类型：Int64</p>
<h3 id="let-queuecapacity"><a class="header" href="#let-queuecapacity">let queueCapacity</a></h3>
<pre><code class="language-cangjie">public let queueCapacity: Int64
</code></pre>
<p>功能：获取缓冲区等待任务的最大数量。</p>
<p>类型：Int64</p>
<h3 id="initint64-int64-int64"><a class="header" href="#initint64-int64-int64">init(Int64, Int64, Int64)</a></h3>
<pre><code class="language-cangjie">public init(
    capacity!: Int64 = 10 ** 4,
    queueCapacity!: Int64 = 10 ** 4,
    preheat!: Int64 = 0
)
</code></pre>
<p>功能：构造一个 <a href="net/http/http_package_api/http_package_structs.html#struct-servicepoolconfig">ServicePoolConfig</a> 实例。</p>
<p>参数：</p>
<ul>
<li>capacity!: Int64 - 协程池容量，默认值为 10000。</li>
<li>queueCapacity!: Int64 - 缓冲区等待任务的最大数量，默认值为 10000。</li>
<li>preheat!: Int64 - 服务启动时预先启动的协程数量，默认值为 0。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 当参数 capacity/queueCapacity/preheat 小于 0，或参数 preheat 大于 capacity。</li>
</ul>
<h2 id="struct-transportconfig"><a class="header" href="#struct-transportconfig">struct TransportConfig</a></h2>
<pre><code class="language-cangjie">public struct TransportConfig
</code></pre>
<p>功能：传输层配置类，服务器建立连接使用的传输层配置。</p>
<h3 id="prop-keepaliveconfig"><a class="header" href="#prop-keepaliveconfig">prop keepAliveConfig</a></h3>
<pre><code class="language-cangjie">public mut prop keepAliveConfig: SocketKeepAliveConfig
</code></pre>
<p>功能：设定和读取传输层连接的消息保活配置，默认配置空闲时间为 45s，发送探测报文的时间间隔为 5s，在连接被认为无效之前发送的探测报文数 5 次，实际时间粒度可能因操作系统而异。</p>
<p>类型：SocketKeepAliveConfig</p>
<h3 id="prop-readbuffersize"><a class="header" href="#prop-readbuffersize">prop readBufferSize</a></h3>
<pre><code class="language-cangjie">public mut prop readBufferSize: ?Int64
</code></pre>
<p>功能：设定和读取传输层连接的读缓冲区大小，默认值为 None ，若设置的值小于 0，将在服务器进行服务建立连接后抛出 IllegalArgumentException。</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>使用默认值时，实际的缓冲区大小将由操作系统决定。</p>
</blockquote>
<p>类型：?Int64</p>
<h3 id="prop-readtimeout-3"><a class="header" href="#prop-readtimeout-3">prop readTimeout</a></h3>
<pre><code class="language-cangjie">public mut prop readTimeout: Duration
</code></pre>
<p>功能：设定和读取传输层连接的读超时时间，如果设置的时间小于 0 将置为 0，默认值为 Duration.Max。</p>
<p>类型：Duration</p>
<h3 id="prop-writebuffersize"><a class="header" href="#prop-writebuffersize">prop writeBufferSize</a></h3>
<pre><code class="language-cangjie">public mut prop writeBufferSize: ?Int64
</code></pre>
<p>功能：设定和读取传输层连接的写缓冲区大小，默认值为 None ，若设置的值小于 0，将在服务器进行服务建立连接后抛出 IllegalArgumentException。</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>使用默认值时，实际的缓冲区大小将由操作系统决定。</p>
</blockquote>
<p>类型：?Int64</p>
<h3 id="prop-writetimeout-3"><a class="header" href="#prop-writetimeout-3">prop writeTimeout</a></h3>
<pre><code class="language-cangjie">public mut prop writeTimeout: Duration
</code></pre>
<p>功能：设定和读取传输层连接的写超时时间，如果设置的时间小于 0 将置为 0，默认值为 Duration.Max。</p>
<p>类型：Duration</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="异常类-16"><a class="header" href="#异常类-16">异常类</a></h1>
<h2 id="class-connectionexception"><a class="header" href="#class-connectionexception">class ConnectionException</a></h2>
<pre><code class="language-cangjie">public class ConnectionException &lt;: IOException {
    public init(message: String)
}
</code></pre>
<p>功能：Http 的tcp连接异常类。</p>
<p>父类型：</p>
<ul>
<li>IOException</li>
</ul>
<h3 id="initstring-11"><a class="header" href="#initstring-11">init(String)</a></h3>
<pre><code class="language-cangjie">public init(message: String)
</code></pre>
<p>功能：创建 <a href="net/http/http_package_api/http_package_exceptions.html#class-connectionexception">ConnectionException</a> 实例。</p>
<p>参数：</p>
<ul>
<li>message: String - 异常提示信息。</li>
</ul>
<h2 id="class-coroutinepoolrejectexception"><a class="header" href="#class-coroutinepoolrejectexception">class CoroutinePoolRejectException</a></h2>
<pre><code class="language-cangjie">public class CoroutinePoolRejectException &lt;: Exception {
    public init(message: String)
}
</code></pre>
<p>功能：Http 的协程池拒绝请求处理异常类。</p>
<p>父类型：</p>
<ul>
<li>Exception</li>
</ul>
<h3 id="initstring-12"><a class="header" href="#initstring-12">init(String)</a></h3>
<pre><code class="language-cangjie">public init(message: String)
</code></pre>
<p>功能：创建 <a href="net/http/http_package_api/http_package_exceptions.html#class-coroutinepoolrejectexception">CoroutinePoolRejectException</a> 实例。</p>
<p>参数：</p>
<ul>
<li>message: String - 异常提示信息。</li>
</ul>
<h2 id="class-httpexception"><a class="header" href="#class-httpexception">class HttpException</a></h2>
<pre><code class="language-cangjie">public class HttpException &lt;: Exception {
    public init(message: String)
}
</code></pre>
<p>功能：Http 的通用异常类。</p>
<p>父类型：</p>
<ul>
<li>Exception</li>
</ul>
<h3 id="initstring-13"><a class="header" href="#initstring-13">init(String)</a></h3>
<pre><code class="language-cangjie">public init(message: String)
</code></pre>
<p>功能：创建 <a href="net/http/http_package_api/http_package_exceptions.html#class-httpexception">HttpException</a> 实例。</p>
<p>参数：</p>
<ul>
<li>message: String - 异常提示信息。</li>
</ul>
<h2 id="class-httpstatusexception"><a class="header" href="#class-httpstatusexception">class HttpStatusException</a></h2>
<pre><code class="language-cangjie">public class HttpStatusException &lt;: Exception {
    public init(statusCode: UInt16, message: String)
}
</code></pre>
<p>功能：Http 的响应状态异常类。</p>
<p>父类型：</p>
<ul>
<li>Exception</li>
</ul>
<h3 id="inituint16-string"><a class="header" href="#inituint16-string">init(UInt16, String)</a></h3>
<pre><code class="language-cangjie">public init(statusCode: UInt16, message: String)
</code></pre>
<p>功能：创建 <a href="net/http/http_package_api/http_package_exceptions.html#class-httpstatusexception">HttpStatusException</a> 实例。</p>
<p>参数：</p>
<ul>
<li>statusCode: UInt16 - 状态码。</li>
<li>message: String - 异常提示信息。</li>
</ul>
<h2 id="class-httptimeoutexception"><a class="header" href="#class-httptimeoutexception">class HttpTimeoutException</a></h2>
<pre><code class="language-cangjie">public class HttpTimeoutException &lt;: Exception {
    public init(message: String)
}
</code></pre>
<p>功能：Http 的超时异常类。</p>
<p>父类型：</p>
<ul>
<li>Exception</li>
</ul>
<h3 id="initstring-14"><a class="header" href="#initstring-14">init(String)</a></h3>
<pre><code class="language-cangjie">public init(message: String)
</code></pre>
<p>功能：创建 <a href="net/http/http_package_api/http_package_exceptions.html#class-httptimeoutexception">HttpTimeoutException</a> 实例。</p>
<p>参数：</p>
<ul>
<li>message: String - 异常提示信息。</li>
</ul>
<h2 id="class-websocketexception"><a class="header" href="#class-websocketexception">class WebSocketException</a></h2>
<pre><code class="language-cangjie">public class WebSocketException &lt;: Exception {
    public init(message: String)
}
</code></pre>
<p>功能：<a href="net/http/http_package_api/http_package_classes.html#class-websocket">WebSocket</a> 的通用异常类。</p>
<p>父类型：</p>
<ul>
<li>Exception</li>
</ul>
<h3 id="initstring-15"><a class="header" href="#initstring-15">init(String)</a></h3>
<pre><code class="language-cangjie">public init(message: String)
</code></pre>
<p>功能：创建 <a href="net/http/http_package_api/http_package_exceptions.html#class-websocketexception">WebSocketException</a> 实例。</p>
<p>参数：</p>
<ul>
<li>message: String - 异常提示信息。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="client"><a class="header" href="#client">client</a></h1>
<h2 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h2>
<p>示例：</p>
<!-- compile -->
<pre><code class="language-cangjie">import stdx.net.http.*

main () {
    // 1. 构建 client 实例
    let client = ClientBuilder().build()
    // 2. 发送 request
    let rsp = client.get(&quot;http://example.com/hello&quot;)
    // 3. 读取response
    println(rsp)
    // 4. 关闭连接
    client.close()
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-text">HTTP/1.1 200 OK
accept-ranges: bytes
age: 258597
cache-control: max-age=604800
content-type: text/html
date: Wed, 05 Jun 2024 02:19:26 GMT
etag: &quot;3147526947&quot;
expires: Wed, 12 Jun 2024 02:19:26 GMT
last-modified: Thu, 17 Oct 2019 07:18:26 GMT
server: ECAcc (lac/55A4)
vary: Accept-Encoding
x-cache: HIT
content-length: 1256
connection: close

body size: 1256
</code></pre>
<h2 id="自定义-client-网络配置"><a class="header" href="#自定义-client-网络配置">自定义 client 网络配置</a></h2>
<p>示例：</p>
<!-- compile -->
<pre><code class="language-cangjie">import std.net.{TcpSocket, SocketAddress}
import std.convert.Parsable
import std.fs.*
import stdx.net.tls.*
import stdx.crypto.x509.X509Certificate
import stdx.net.http.*
import std.io.*

// 该程序需要用户配置存在且合法的文件路径才能执行
main() {
    // 1. 自定义配置
    // tls 配置
    var tlsConfig = TlsClientConfig()
    let pem = String.fromUtf8(readToEnd(File(&quot;/rootCerPath&quot;, Read)))
    tlsConfig.verifyMode = CustomCA(X509Certificate.decodeFromPem(pem))
    tlsConfig.alpnProtocolsList = [&quot;h2&quot;]
    let TcpSocketConnector = {
        sa: SocketAddress =&gt;
        let socket = TcpSocket(sa)
        socket.connect()
        return socket
    }
    // 2. 构建 client 实例
    let client = ClientBuilder().tlsConfig(tlsConfig).enablePush(false).connector(TcpSocketConnector).build()
    // 3. 发送 request
    let rsp = client.get(&quot;https://example.com/hello&quot;)
    // 4. 读取 response
    let buf = Array&lt;UInt8&gt;(1024, repeat: 0)
    let len = rsp.body.read(buf)
    println(String.fromUtf8(buf.slice(0, len)))
    // 5. 关闭连接
    client.close()
}
</code></pre>
<h2 id="request中的-chunked-与-trailer"><a class="header" href="#request中的-chunked-与-trailer">request中的 chunked 与 trailer</a></h2>
<p>示例：</p>
<!-- compile -->
<pre><code class="language-cangjie">import std.io.*
import std.fs.*
import stdx.net.http.*

func checksum(chunk: Array&lt;UInt8&gt;): Int64 {
    var sum = 0
    for (i in chunk) {
        if (i == b'\n') {
            sum += 1
        }
    }
    return sum / 2
}

// 该程序需要用户配置存在且合法的文件路径才能执行
main() {
    // 1. 构建 client 实例
    let client = ClientBuilder().build()
    var requestBuilder = HttpRequestBuilder()
    let file = File(&quot;./res.jpg&quot;, Read)
    let sum = checksum(readToEnd(file))
    let req = requestBuilder
        .method(&quot;PUT&quot;)
        .url(&quot;https://example.com/src/&quot;)
        .header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;)
        .header(&quot;Trailer&quot;, &quot;checksum&quot;)
        .body(FileBody(&quot;./res.jpg&quot;))
        .trailer(&quot;checksum&quot;, sum.toString())
        .build()
    let rsp = client.send(req)
    println(rsp)
    client.close()
}

class FileBody &lt;: InputStream {
    var file: File
    init(path: String) {
        file = File(path, Read)
    }
    public func read(buf: Array&lt;UInt8&gt;): Int64 {
        file.read(buf)
    }
}
</code></pre>
<h2 id="配置代理"><a class="header" href="#配置代理">配置代理</a></h2>
<p>示例：</p>
<!-- compile -->
<pre><code class="language-cangjie">import stdx.net.http.*

main() {
    // 1. 构建 client 实例
    let client = ClientBuilder().httpProxy(&quot;http://192.168.0.1:8080&quot;).build()
    // 2. 发送 request，所有 request 都会被发送至 192.168.0.1 地址的 8080 端口，而不是 example.com
    let rsp = client.get(&quot;http://example.com/hello&quot;)
    // 3. 读取 response
    println(rsp)
    // 4. 关闭连接
    client.close()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cookie"><a class="header" href="#cookie">cookie</a></h1>
<h2 id="client-1"><a class="header" href="#client-1">Client</a></h2>
<p>示例：</p>
<!-- run -->
<pre><code class="language-cangjie">import stdx.net.http.*
import stdx.encoding.url.*
import std.net.*
import std.time.*
import std.sync.*

main() {
    // 1、启动socket服务器
    let serverSocket = TcpServerSocket(bindAt: 0)
    serverSocket.bind()
    let fut = spawn {
        serverPacketCapture(serverSocket)
    }
    sleep(Duration.millisecond * 10)
    // 客户端一般从 response 中的 Set-Cookie header 中读取 cookie，并将其存入 cookieJar 中，
    // 下次发起 request时，将其放在 request 的 Cookie header 中发送
    // 2、启动客户端
    let client = ClientBuilder().build()
    let port = (serverSocket.localAddress as IPSocketAddress)?.port ?? throw Exception(&quot;Port not found.&quot;)
    var u = URL.parse(&quot;http://127.0.0.1:${port}/a/b/c&quot;)
    var r = HttpRequestBuilder()
                        .url(u)
                        .build()
    // 3、发送request
    client.send(r)
    sleep(Duration.second * 2)
    r = HttpRequestBuilder()
                        .url(u)
                        .build()
    // 4、发送新 request，从 CookieJar 中取出 cookie，并转成 Cookie header 中的值
    // 此时 cookie 2=2 已经过期，因此只发送 1=1 cookie
    client.send(r)
    // 5、关闭客户端
    client.close()
    fut.get()
    serverSocket.close()
}

func serverPacketCapture(serverSocket: TcpServerSocket) {
    let buf = Array&lt;UInt8&gt;(500, repeat: 0)
    let server = serverSocket.accept()
    var i = server.read(buf)
    println(String.fromUtf8(buf[..i]))
    // GET /a/b/c HTTP/1.1
    // host: 127.0.0.1:44649
    // user-agent: CANGJIEUSERAGENT_1_1
    // connection: keep-alive
    // content-length: 0
    //
    // 过期时间为 4 秒的 cookie1
    let cookie1 = Cookie(&quot;1&quot;, &quot;1&quot;, maxAge: 4, domain: &quot;127.0.0.1&quot;, path: &quot;/a/b/&quot;)
    let setCookie1 = cookie1.toSetCookieString()
    // 过期时间为 2 秒的 cookie2
    let cookie2 = Cookie(&quot;2&quot;, &quot;2&quot;, maxAge: 2, path: &quot;/a/&quot;)
    let setCookie2 = cookie2.toSetCookieString()
    // 服务器发送 Set-Cookie 头，客户端解析并将其存进 CookieJar 中
    server.write(&quot;HTTP/1.1 204 ok\r\nSet-Cookie: ${setCookie1}\r\nSet-Cookie: ${setCookie2}\r\nConnection: close\r\n\r\n&quot;.toArray())

    let server2 = serverSocket.accept()
    i = server2.read(buf)
    // 接收客户端的带 cookie 的请求
    println(String.fromUtf8(buf[..i]))
    // GET /a/b/c HTTP/1.1
    // host: 127.0.0.1:34857
    // cookie: 1=1
    // user-agent: CANGJIEUSERAGENT_1_1
    // connection: keep-alive
    // content-length: 0
    //
    server2.write(&quot;HTTP/1.1 204 ok\r\nConnection: close\r\n\r\n&quot;.toArray())
    server2.close()
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-text">GET /a/b/c HTTP/1.1
host: 127.0.0.1:37359
user-agent: CANGJIEUSERAGENT_1_1
connection: keep-alive
content-length: 0


GET /a/b/c HTTP/1.1
host: 127.0.0.1:37359
cookie: 1=1
user-agent: CANGJIEUSERAGENT_1_1
connection: keep-alive
content-length: 0
</code></pre>
<h2 id="server"><a class="header" href="#server">Server</a></h2>
<p>示例：</p>
<!-- compile -->
<pre><code class="language-cangjie">import stdx.net.http.*

main () {
    // 服务器设置 cookie 时将 cookie 放在 Set-Cookie header 中发给客户端
    // 1. 构建 Server 实例
    let server = ServerBuilder()
                       .addr(&quot;127.0.0.1&quot;)
                       .port(8080)
                       .build()
    // 2. 注册 HttpRequestHandler
    server.distributor.register(&quot;/index&quot;, {httpContext =&gt;
        let cookie = Cookie(&quot;name&quot;, &quot;value&quot;)
        httpContext.responseBuilder.header(&quot;Set-Cookie&quot;, cookie.toSetCookieString()).body(&quot;Hello 仓颉!&quot;)
    })
    // 3. 启动服务
    server.serve()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="log"><a class="header" href="#log">log</a></h1>
<p>示例：</p>
<!-- compile -->
<pre><code class="language-cangjie">import stdx.log.*
import stdx.net.http.*

main() {
    // 1. 构建 Server 实例
    let server = ServerBuilder().addr(&quot;127.0.0.1&quot;).port(8080).build()
    // 2. 注册 HttpRequestHandler
    server.distributor.register(&quot;/index&quot;, {
        httpContext =&gt; httpContext.responseBuilder.body(&quot;Hello 仓颉!&quot;)
    })
    // 3. 开启日志
    server.logger.level = LogLevel.DEBUG
    // client 端通过 client.logger.level = DEBUG 开启
    // 4. 启动服务
    server.serve()
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-text">2024/01/25 17:23:54.344205 DEBUG Logger [Server#serve] bindAndListen(127.0.0.1, 8080)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="server-1"><a class="header" href="#server-1">server</a></h1>
<h2 id="hello-仓颉"><a class="header" href="#hello-仓颉">Hello 仓颉</a></h2>
<p>示例：</p>
<!-- compile -->
<pre><code class="language-cangjie">import stdx.net.http.ServerBuilder

main() {
    // 1. 构建 Server 实例
    let server = ServerBuilder().addr(&quot;127.0.0.1&quot;).port(8080).build()
    // 2. 注册 HttpRequestHandler
    server.distributor.register(&quot;/index&quot;, {
        httpContext =&gt; httpContext.responseBuilder.body(&quot;Hello 仓颉!&quot;)
    })
    // 3. 启动服务
    server.serve()
}
</code></pre>
<h2 id="通过-request-distributor注册处理器"><a class="header" href="#通过-request-distributor注册处理器">通过 request distributor注册处理器</a></h2>
<p>示例：</p>
<!-- compile -->
<pre><code class="language-cangjie">import stdx.net.http.{ServerBuilder, HttpRequestHandler, FuncHandler}

main() {
    // 1. 构建 Server 实例
    let server = ServerBuilder().addr(&quot;127.0.0.1&quot;).port(8080).build()
    var a: HttpRequestHandler = FuncHandler({
        httpContext =&gt; httpContext.responseBuilder.body(&quot;index&quot;)
    })
    var b: HttpRequestHandler = FuncHandler({
        httpContext =&gt; httpContext.responseBuilder.body(&quot;id&quot;)
    })
    var c: HttpRequestHandler = FuncHandler({
        httpContext =&gt; httpContext.responseBuilder.body(&quot;help&quot;)
    })
    server.distributor.register(&quot;/index&quot;, a)
    server.distributor.register(&quot;/id&quot;, b)
    server.distributor.register(&quot;/help&quot;, c)
    // 2. 启动服务
    server.serve()
}
</code></pre>
<h2 id="自定义-request-distributor与处理器"><a class="header" href="#自定义-request-distributor与处理器">自定义 request distributor与处理器</a></h2>
<p>示例：</p>
<!-- compile -->
<pre><code class="language-cangjie">import stdx.net.http.*
import std.collection.HashMap

class NaiveDistributor &lt;: HttpRequestDistributor {
    let map = HashMap&lt;String, HttpRequestHandler&gt;()
    public func register(path: String, handler: HttpRequestHandler): Unit {
        map.add(path, handler)
    }

    public func distribute(path: String): HttpRequestHandler {
        if (path == &quot;/index&quot;) {
            return PageHandler()
        }
        return NotFoundHandler()
    }
}

// 返回一个简单的 HTML 页面
class PageHandler &lt;: HttpRequestHandler {
    public func handle(httpContext: HttpContext): Unit {
        httpContext.responseBuilder.body(&quot;&lt;html&gt;&lt;/html&gt;&quot;)
    }
}

main() {
    // 1. 构建 Server 实例并自定义分发器
    let server = ServerBuilder().addr(&quot;127.0.0.1&quot;).port(8080).distributor(NaiveDistributor()).build()
    // 2. 启动服务
    server.serve()
}

</code></pre>
<h2 id="自定义-server-网络配置"><a class="header" href="#自定义-server-网络配置">自定义 server 网络配置</a></h2>
<p>示例：</p>
<!-- compile -->
<pre><code class="language-cangjie">import std.io.*
import std.fs.*
import stdx.net.tls.*
import stdx.crypto.x509.{X509Certificate, PrivateKey}
import stdx.net.http.*

//该程序需要用户配置存在且合法的文件路径才能执行
main() {
    // 1. 自定义配置
    // tcp 配置
    var transportCfg = TransportConfig()
    transportCfg.readBufferSize = 8192
    // tls 配置，需要传入配套的证书与私钥文件路径
    let pem0 = String.fromUtf8(readToEnd(File(&quot;/certPath&quot;, Read)))
    let pem02 = String.fromUtf8(readToEnd(File(&quot;/keyPath&quot;, Read)))
    var tlsConfig = TlsServerConfig(X509Certificate.decodeFromPem(pem0), PrivateKey.decodeFromPem(pem02))
    tlsConfig.supportedAlpnProtocols = [&quot;h2&quot;]
    // 2. 构建 Server 实例
    let server = ServerBuilder()
        .addr(&quot;127.0.0.1&quot;)
        .port(8080)
        .transportConfig(transportCfg)
        .tlsConfig(tlsConfig)
        .headerTableSize(10 * 1024)
        .maxRequestHeaderSize(1024 * 1024)
        .build()
    // 3. 注册 HttpRequestHandler
    server.distributor.register(&quot;/index&quot;, {
        httpContext =&gt; httpContext.responseBuilder.body(&quot;Hello 仓颉!&quot;)
    })
    // 4. 启动服务
    server.serve()
}
</code></pre>
<h2 id="response中的-chunked与trailer"><a class="header" href="#response中的-chunked与trailer">response中的 chunked与trailer</a></h2>
<p>示例：</p>
<!-- compile -->
<pre><code class="language-cangjie">import stdx.net.http.*
import std.io.*
import std.collection.HashMap

func checksum(chunk: Array&lt;UInt8&gt;): Int64 {
    var sum = 0
    for (i in chunk) {
        if (i == UInt8(UInt32(r'\n'))) {
            sum += 1
        }
    }
    return sum / 2
}

main() {
    // 1. 构建 Server 实例
    let server = ServerBuilder().addr(&quot;127.0.0.1&quot;).port(8080).build()
    // 2. 注册 HttpRequestHandler
    server
        .distributor
        .register(
            &quot;/index&quot;,
            {
                httpContext =&gt;
                let responseBuilder = httpContext.responseBuilder
                responseBuilder.header(&quot;transfer-encoding&quot;, &quot;chunked&quot;)
                responseBuilder.header(&quot;trailer&quot;, &quot;checkSum&quot;)
                let writer = HttpResponseWriter(httpContext)
                var sum = 0
                for (_ in 0..10) {
                    let chunk = Array&lt;UInt8&gt;(10, repeat: 0)
                    sum += checksum(chunk)
                    writer.write(chunk)
                }
                // handler 结束后发送
                responseBuilder.trailer(&quot;checkSum&quot;, &quot;${sum}&quot;)
            }
        )
    // 3. 启动服务
    server.serve()
}
</code></pre>
<h2 id="处理重定向-request"><a class="header" href="#处理重定向-request">处理重定向 request</a></h2>
<p>示例：</p>
<!-- compile -->
<pre><code class="language-cangjie">import stdx.net.http.*

main() {
    // 1. 构建 Server 实例
    let server = ServerBuilder().addr(&quot;127.0.0.1&quot;).port(8080).build()
    // 2. 注册 HttpRequestHandler
    server.distributor.register(&quot;/redirecta&quot;, RedirectHandler(&quot;/movedsource&quot;, 308))
    server.distributor.register(&quot;/redirectb&quot;, RedirectHandler(&quot;http://www.example.com&quot;, 308))
    // 3. 启动服务
    server.serve()
}
</code></pre>
<h2 id="tls-证书热加载"><a class="header" href="#tls-证书热加载">tls 证书热加载</a></h2>
<p>示例：</p>
<!-- compile -->
<pre><code class="language-cangjie">import std.io.*
import std.fs.*
import stdx.net.tls.*
import stdx.crypto.x509.{X509Certificate, PrivateKey}
import stdx.net.http.*

//该程序需要用户配置存在且合法的文件路径才能执行
main() {
    // 1. tls 配置
    let pem0 = String.fromUtf8(readToEnd(File(&quot;/certPath&quot;, Read)))
    let pem02 = String.fromUtf8(readToEnd(File(&quot;/keyPath&quot;, Read)))
    var tlsConfig = TlsServerConfig(X509Certificate.decodeFromPem(pem0), PrivateKey.decodeFromPem(pem02))
    tlsConfig.supportedAlpnProtocols = [&quot;http/1.1&quot;]
    let pem = String.fromUtf8(readToEnd(File(&quot;/rootCerPath&quot;, Read)))
    tlsConfig.verifyMode = CustomCA(X509Certificate.decodeFromPem(pem))
    // 2. 构建 Server 实例，并启动服务
    let server = ServerBuilder().addr(&quot;127.0.0.1&quot;).port(8080).tlsConfig(tlsConfig).build()
    spawn {
        server.serve()
    }
    // 3. 更新 tls 证书和私钥，之后收到的 request 将使用新的证书和私钥
    server.updateCert(&quot;/newCerPath&quot;, &quot;/newKeyPath&quot;)
    // 4. 更新 CA ，双向认证时使用，之后收到的 request 将使用新的 CA
    server.updateCA(&quot;/newRootCerPath&quot;)
}
</code></pre>
<h2 id="server-push"><a class="header" href="#server-push">server push</a></h2>
<p>仅用于 HTTP/2</p>
<p>client:</p>
<p>示例：</p>
<!-- compile -->
<pre><code class="language-cangjie">import std.io.*
import std.fs.*
import std.collection.ArrayList
import stdx.net.tls.*
import stdx.crypto.x509.X509Certificate
import stdx.net.http.*

//该程序需要用户配置存在且合法的文件路径才能执行
main() {
    // 1. tls 配置
    var tlsConfig = TlsClientConfig()
    let pem = String.fromUtf8(readToEnd(File(&quot;/rootCerPath&quot;, Read)))
    tlsConfig.verifyMode = CustomCA(X509Certificate.decodeFromPem(pem))
    tlsConfig.alpnProtocolsList = [&quot;h2&quot;]
    // 2. 构建 Client 实例
    let client = ClientBuilder().tlsConfig(tlsConfig).build()
    // 3. 发送 request ，接收 response
    let response = client.get(&quot;https://example.com/index.html&quot;)
    // 4. 收 pushResponse ，此例中相当于 client.get(&quot;http://example.com/picture.png&quot;) 的 response
    let pushResponses: Option&lt;ArrayList&lt;HttpResponse&gt;&gt; = response.getPush()
    client.close()
}
</code></pre>
<p>server:</p>
<p>示例：</p>
<!-- compile -->
<pre><code class="language-cangjie">import std.io.*
import std.fs.*
import stdx.net.tls.*
import stdx.crypto.x509.{X509Certificate, PrivateKey}
import stdx.net.http.*

// 该程序需要用户配置存在且合法的文件路径才能执行
main() {
    // 1. tls 配置
    let pem0 = String.fromUtf8(readToEnd(File(&quot;/certPath&quot;, Read)))
    let pem02 = String.fromUtf8(readToEnd(File(&quot;/keyPath&quot;, Read)))
    var tlsConfig = TlsServerConfig(X509Certificate.decodeFromPem(pem0), PrivateKey.decodeFromPem(pem02))
    tlsConfig.supportedAlpnProtocols = [&quot;h2&quot;]
    // 2. 构建 Server 实例
    let server = ServerBuilder().addr(&quot;127.0.0.1&quot;).port(8080).tlsConfig(tlsConfig).build()
    // 3. 注册原 request 的 handler
    server
        .distributor
        .register(
            &quot;/index.html&quot;,
            {
                httpContext =&gt;
                let pusher = HttpResponsePusher.getPusher(httpContext)
                match (pusher) {
                    case Some(pusher) =&gt; pusher.push(&quot;/picture.png&quot;, &quot;GET&quot;, httpContext.request.headers)
                    case None =&gt; ()
                }
            }
        )
    // 4. 注册 pushRequest 的 handler
    server.distributor.register(&quot;/picture.png&quot;, {
        httpContext =&gt; httpContext.responseBuilder.body(&quot;picture.png&quot;)
    })
    // 4. 启动服务
    server.serve()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="websocket-1"><a class="header" href="#websocket-1">webSocket</a></h1>
<p>示例：</p>
<!-- verify -->
<pre><code class="language-cangjie">import stdx.net.http.*
import stdx.encoding.url.*
import std.time.*
import std.sync.*
import std.collection.*
import stdx.log.*

let server = ServerBuilder().addr(&quot;127.0.0.1&quot;).port(0).build()

main() {
    // 1 启动服务器
    spawn {startServer()}
    sleep(Duration.millisecond * 200)

    let client = ClientBuilder().build()
    let u = URL.parse(&quot;ws://127.0.0.1:${server.port}/webSocket&quot;)

    let subProtocol = ArrayList&lt;String&gt;([&quot;foo1&quot;, &quot;bar1&quot;])
    let headers = HttpHeaders()
    headers.add(&quot;test&quot;, &quot;echo&quot;)

    // 2 完成 WebSocket 握手，获取 WebSocket 实例
    let websocket: WebSocket
    let respHeaders: HttpHeaders
    (websocket, respHeaders) = WebSocket.upgradeFromClient(client, u, subProtocols: subProtocol, headers: headers)
    client.close()

    println(&quot;subProtocol: ${websocket.subProtocol}&quot;)
    println(respHeaders.getFirst(&quot;rsp&quot;) ?? &quot;&quot;)

    // 3 消息收发
    // 发送 hello
    websocket.write(TextWebFrame, &quot;hello&quot;.toArray())
    // 接收消息
    let data = ArrayList&lt;UInt8&gt;()
    var frame = websocket.read()
    while (true) {
        match (frame.frameType) {
            case ContinuationWebFrame =&gt;
                data.add(all: frame.payload)
                if (frame.fin) {
                    break
                }
            case TextWebFrame | BinaryWebFrame =&gt;
                if (!data.isEmpty()) {
                    throw Exception(&quot;invalid frame&quot;)
                }
                data.add(all: frame.payload)
                if (frame.fin) {
                    break
                }
            case CloseWebFrame =&gt;
                websocket.write(CloseWebFrame, frame.payload)
                break
            case PingWebFrame =&gt; websocket.writePongFrame(frame.payload)
            case _ =&gt; ()
        }
        frame = websocket.read()
    }
    println(&quot;data size: ${data.size}&quot;)
    println(&quot;last item: ${String.fromUtf8(data.toArray()[4096])}&quot;)

    // 4 关闭 websocket，
    // 收发 CloseFrame
    websocket.writeCloseFrame(status: 1000)
    let websocketFrame = websocket.read()
    println(&quot;close frame type: ${websocketFrame.frameType}&quot;)
    println(&quot;close frame payload: ${websocketFrame.payload}&quot;)

    // 关闭底层连接
    websocket.closeConn()

    server.close()
}

func startServer() {
    // 1 注册 handler
    server.distributor.register(&quot;/webSocket&quot;, handler1)
    server.logger.level = LogLevel.OFF
    server.serve()
}

// server:
func handler1(ctx: HttpContext): Unit {
    // 2 完成 websocket 握手，获取 websocket 实例
    let websocketServer = WebSocket.upgradeFromServer(
        ctx,
        subProtocols: ArrayList&lt;String&gt;([&quot;foo&quot;, &quot;bar&quot;, &quot;foo1&quot;]),
        userFunc: {
            request: HttpRequest =&gt;
            let value = request.headers.getFirst(&quot;test&quot;) ?? &quot;&quot;
            let headers = HttpHeaders()
            headers.add(&quot;rsp&quot;, value)
            headers
        }
    )
    // 3 消息收发
    // 接收 hello
    let data = ArrayList&lt;UInt8&gt;()
    var frame = websocketServer.read()
    while (true) {
        match (frame.frameType) {
            case ContinuationWebFrame =&gt;
                data.add(all: frame.payload)
                if (frame.fin) {
                    break
                }
            case TextWebFrame | BinaryWebFrame =&gt;
                if (!data.isEmpty()) {
                    throw Exception(&quot;invalid frame&quot;)
                }
                data.add(all: frame.payload)
                if (frame.fin) {
                    break
                }
            case CloseWebFrame =&gt;
                websocketServer.write(CloseWebFrame, frame.payload)
                break
            case PingWebFrame =&gt; websocketServer.writePongFrame(frame.payload)
            case _ =&gt; ()
        }
        frame = websocketServer.read()
    }
    println(&quot;data: ${String.fromUtf8(data.toArray())}&quot;)

    // 发 4097 个 a
    websocketServer.write(TextWebFrame, Array&lt;UInt8&gt;(4097, repeat: 97))

    // 4 关闭 websocket，
    // 收发 CloseFrame
    let websocketFrame = websocketServer.read()
    println(&quot;close frame type: ${websocketFrame.frameType}&quot;)
    println(&quot;close frame payload: ${websocketFrame.payload}&quot;)
    websocketServer.write(CloseWebFrame, websocketFrame.payload)
    // 关闭底层连接
    websocketServer.closeConn()
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-text">subProtocol: foo1
echo
data: hello
data size: 4097
last item: a
close frame type: CloseWebFrame
close frame payload: [3, 232]
close frame type: CloseWebFrame
close frame payload: [3, 232]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdxnettls"><a class="header" href="#stdxnettls">stdx.net.tls</a></h1>
<h2 id="功能介绍-14"><a class="header" href="#功能介绍-14">功能介绍</a></h2>
<p>tls 包用于进行安全加密的网络通信，提供创建 TLS 服务器、基于协议进行 TLS 握手、收发加密数据、恢复 TLS 会话等能力。</p>
<p>本包支持TLS 1.2 及 TLS 1.3 传输层安全协议通信。</p>
<p>使用本包需要外部依赖 <code>OpenSSL 3</code> 的 <code>ssl</code> 和 <code>crypto</code> 动态库文件，故使用前需安装相关工具：</p>
<ul>
<li>对于 <code>Linux</code> 操作系统，可参考以下方式：
<ul>
<li>如果系统的包管理工具支持安装 <code>OpenSSL 3</code> 开发工具包，可通过这个方式安装，并确保系统安装目录下含有 <code>libssl.so</code>、<code>libssl.so.3</code>、<code>libcrypto.so</code> 和 <code>libcrypto.so.3</code> 这些动态库文件，例如 <code>Ubuntu 22.04</code> 系统上可使用 <code>sudo apt install libssl-dev</code> 命令安装 <code>libssl-dev</code> 工具包；</li>
<li>如果无法通过上面的方式安装，可自行下载 <code>OpenSSL 3.x.x</code> 源码编译安装软件包，并确保安装目录下含有 <code>libssl.so</code>、<code>libssl.so.3</code>、<code>libcrypto.so</code> 和 <code>libcrypto.so.3</code> 这些动态库文件，然后可选择下面任意一种方式来保证系统链接器可以找到这些文件:
<ul>
<li>在系统未安装 OpenSSL 的场景，安装时选择直接安装到系统路径下；</li>
<li>安装在自定义目录的场景，将这些文件所在目录设置到环境变量 <code>LD_LIBRARY_PATH</code> 以及 <code>LIBRARY_PATH</code> 中。</li>
</ul>
</li>
</ul>
</li>
<li>对于 <code>Windows</code> 操作系统，可按照以下步骤：
<ul>
<li>自行下载 <code>OpenSSL 3.x.x</code> 源码编译安装 x64 架构软件包或者自行下载安装第三方预编译的供开发人员使用的 <code>OpenSSL 3.x.x</code> 软件包；</li>
<li>确保安装目录下含有 <code>libssl.dll.a</code>（或 <code>libssl.lib</code>）、<code>libssl-3-x64.dll</code>、<code>libcrypto.dll.a</code>（或 <code>libcrypto.lib</code>）、<code>libcrypto-3-x64.dll</code> 这些库文件；</li>
<li>将 <code>libssl.dll.a</code>（或 <code>libssl.lib</code>）、<code>libcrypto.dll.a</code>（或 <code>libcrypto.lib</code>）所在的目录路径设置到环境变量 <code>LIBRARY_PATH</code> 中，将 <code>libssl-3-x64.dll</code>、<code>libcrypto-3-x64.dll</code> 所在的目录路径设置到环境变量 <code>PATH</code> 中。</li>
</ul>
</li>
<li>对于 <code>macOS</code> 操作系统，可参考以下方式：
<ul>
<li>使用 <code>brew install openssl@3</code> 安装，并确保系统安装目录下含有 <code>libcrypto.dylib</code> 和 <code>libcrypto.3.dylib</code> 这两个动态库文件；</li>
<li>如果无法通过上面的方式安装，可自行下载 <code>OpenSSL 3.x.x</code> 源码编译安装软件包，并确保安装目录下含有 <code>libcrypto.dylib</code> 和 <code>libcrypto.3.dylib</code> 这两个动态库文件，然后可选择下面任意一种方式来保证系统链接器可以找到这些文件:
<ul>
<li>在系统未安装 OpenSSL 的场景，安装时选择直接安装到系统路径下；</li>
<li>安装在自定义目录的场景，将这些文件所在目录设置到环境变量 <code>DYLD_LIBRARY_PATH</code> 以及 <code>LIBRARY_PATH</code> 中。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>注意：</strong></p>
<p>如果未安装<code>OpenSSL 3</code>软件包或者安装低版本的软件包，程序可能无法使用并抛出相关异常 TlsException: Can not load openssl library or function xxx.。</p>
</blockquote>
<h2 id="api-列表-14"><a class="header" href="#api-列表-14">API 列表</a></h2>
<h3 id="类-23"><a class="header" href="#类-23">类</a></h3>
<div class="table-wrapper"><table><thead><tr><th>类名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="net/tls/./tls_package_api/tls_package_classes.html#class-tlssessioncontext">TlsSessionContext</a></td><td>服务端启用 session 特性恢复会话，存储 session 用于对客户端进行验证类型。</td></tr>
<tr><td><a href="net/tls/./tls_package_api/tls_package_classes.html#class-tlssocket">TlsSocket</a></td><td>用于在客户端及服务端间创建加密传输通道。</td></tr>
</tbody></table>
</div>
<h3 id="枚举-12"><a class="header" href="#枚举-12">枚举</a></h3>
<div class="table-wrapper"><table><thead><tr><th>枚举名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="net/tls/./tls_package_api/tls_package_enums.html#enum-certificateverifymode">CertificateVerifyMode</a></td><td>证书认证模式。</td></tr>
<tr><td><a href="net/tls/./tls_package_api/tls_package_enums.html#enum-signaturealgorithm">SignatureAlgorithm</a></td><td>签名算法类型，签名算法用于确保传输数据的身份验证、完整性和真实性。</td></tr>
<tr><td><a href="net/tls/./tls_package_api/tls_package_enums.html#enum-signatureschemetype">SignatureSchemeType</a></td><td>加密算法类型，用于保护网络通信的安全性和隐私性。</td></tr>
<tr><td><a href="net/tls/./tls_package_api/tls_package_enums.html#enum-signaturetype">SignatureType</a></td><td>签名算法类型，用于认证真实性。</td></tr>
<tr><td><a href="net/tls/./tls_package_api/tls_package_enums.html#enum-tlsclientidentificationmode">TlsClientIdentificationMode</a></td><td>服务端对客户端证书的认证模式。</td></tr>
<tr><td><a href="net/tls/./tls_package_api/tls_package_enums.html#enum-tlsversion">TlsVersion</a></td><td>TLS 协议版本。</td></tr>
</tbody></table>
</div>
<h3 id="结构体-14"><a class="header" href="#结构体-14">结构体</a></h3>
<div class="table-wrapper"><table><thead><tr><th>结构体名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="net/tls/./tls_package_api/tls_package_structs.html#struct-ciphersuite">CipherSuite</a></td><td>TLS 中的密码套件。</td></tr>
<tr><td><a href="net/tls/./tls_package_api/tls_package_structs.html#struct-tlsclientconfig">TlsClientConfig</a></td><td>客户端配置。</td></tr>
<tr><td><a href="net/tls/./tls_package_api/tls_package_structs.html#struct-tlsserverconfig">TlsServerConfig</a></td><td>服务端配置。</td></tr>
<tr><td><a href="net/tls/./tls_package_api/tls_package_structs.html#struct-tlssession">TlsSession</a></td><td>当客户端 TLS 握手成功后，将会生成一个会话，当连接因一些原因丢失后，客户端可以通过这个会话 id 复用此次会话，省略握手流程。</td></tr>
</tbody></table>
</div>
<h3 id="异常类-17"><a class="header" href="#异常类-17">异常类</a></h3>
<div class="table-wrapper"><table><thead><tr><th>类名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="net/tls/./tls_package_api/tls_package_exceptions.html#class-tlsexception">TlsException</a></td><td>TLS 处理出现错误时抛出的异常类型。</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="类-24"><a class="header" href="#类-24">类</a></h1>
<h2 id="class-tlssessioncontext"><a class="header" href="#class-tlssessioncontext">class TlsSessionContext</a></h2>
<pre><code class="language-cangjie">public class TlsSessionContext &lt;: Equatable&lt;TlsSessionContext&gt; &amp; ToString
</code></pre>
<p>功能：该类表示 TLS 会话上下文，给客户端提供信息，确保客户端所连接的服务端仍为相同实例，用于连接复用时，验证客户端合法性。</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>当客户端尝试恢复会话时，双方都必须确保他们正在恢复与合法对端的会话。</p>
</blockquote>
<p>父类型：</p>
<ul>
<li>Equatable&lt;<a href="net/tls/tls_package_api/tls_package_classes.html#class-tlssessioncontext">TlsSessionContext</a>&gt;</li>
<li>ToString</li>
</ul>
<h3 id="static-func-fromnamestring"><a class="header" href="#static-func-fromnamestring">static func fromName(String)</a></h3>
<pre><code class="language-cangjie">public static func fromName(name: String): TlsSessionContext
</code></pre>
<p>功能：通过名称创建 <a href="net/tls/tls_package_api/tls_package_classes.html#class-tlssessioncontext">TlsSessionContext</a> 实例。</p>
<p>通过 <a href="net/tls/tls_package_api/tls_package_classes.html#class-tlssessioncontext">TlsSessionContext</a> 保存的名称获取 <a href="net/tls/tls_package_api/tls_package_classes.html#class-tlssessioncontext">TlsSessionContext</a> 对象。该名称用于区分 TLS 服务器，因此客户端依赖此名称来避免意外，尝试恢复与错误的服务器的连接。这里不一定使用加密安全名称，因为底层实现可以完成这项工作。从此函数返回的具有相同名称的两个 TlsSessionContext 可能不相等，并且不保证可替换。尽管它们是从相同的名称创建的，因此服务器实例应该在整个生命周期内创建一个 TlsSessionContext ，并且在每次 <a href="net/tls/tls_package_api/tls_package_classes.html#class-tlssocket">TlsSocket</a>.server() 调用中使用它。</p>
<p>参数：</p>
<ul>
<li>name: String - 会话上下文名称。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/tls/tls_package_api/tls_package_classes.html#class-tlssessioncontext">TlsSessionContext</a> - 会话上下文。</li>
</ul>
<h3 id="func-tostring-33"><a class="header" href="#func-tostring-33">func toString()</a></h3>
<pre><code class="language-cangjie">public override func toString(): String
</code></pre>
<p>功能：生成会话上下文名称字符串。</p>
<p>返回值：</p>
<ul>
<li>String - <a href="net/tls/tls_package_api/tls_package_classes.html#class-tlssessioncontext">TlsSessionContext</a>（会话上下文名称字符串）。</li>
</ul>
<h3 id="operator-func-tlssessioncontext"><a class="header" href="#operator-func-tlssessioncontext">operator func !=(TlsSessionContext)</a></h3>
<pre><code class="language-cangjie">public override operator func !=(other: TlsSessionContext)
</code></pre>
<p>功能：判断两 <a href="net/tls/tls_package_api/tls_package_classes.html#class-tlssessioncontext">TlsSessionContext</a> 实例名称是否不同。</p>
<p>参数：</p>
<ul>
<li>other: <a href="net/tls/tls_package_api/tls_package_classes.html#class-tlssessioncontext">TlsSessionContext</a> - 被比较的会话上下文对象。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Unit - 若 <a href="net/tls/tls_package_api/tls_package_classes.html#class-tlssessioncontext">TlsSessionContext</a> 对象不同，返回 <code>true</code>；否则，返回 <code>false</code>。</li>
</ul>
<h3 id="operator-func-tlssessioncontext-1"><a class="header" href="#operator-func-tlssessioncontext-1">operator func ==(TlsSessionContext)</a></h3>
<pre><code class="language-cangjie">public override operator func ==(other: TlsSessionContext)
</code></pre>
<p>功能：判断两 <a href="net/tls/tls_package_api/tls_package_classes.html#class-tlssessioncontext">TlsSessionContext</a> 实例名称是否相同。</p>
<p>参数：</p>
<ul>
<li>other: <a href="net/tls/tls_package_api/tls_package_classes.html#class-tlssessioncontext">TlsSessionContext</a> - 被比较的会话上下文对象。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Unit - 若 <a href="net/tls/tls_package_api/tls_package_classes.html#class-tlssessioncontext">TlsSessionContext</a> 对象相同，返回 <code>true</code>；否则，返回 <code>false</code>。</li>
</ul>
<h2 id="class-tlssocket"><a class="header" href="#class-tlssocket">class TlsSocket</a></h2>
<pre><code class="language-cangjie">public class TlsSocket &lt;: StreamingSocket &amp; ToString &amp; Equatable&lt;TlsSocket&gt; &amp; Hashable
</code></pre>
<p>功能：<a href="net/tls/tls_package_api/tls_package_classes.html#class-tlssocket">TlsSocket</a> 用于在客户端及服务端间创建加密传输通道。</p>
<p>父类型：</p>
<ul>
<li>StreamingSocket</li>
<li>ToString</li>
<li>Equatable&lt;<a href="net/tls/tls_package_api/tls_package_classes.html#class-tlssocket">TlsSocket</a>&gt;</li>
<li>Hashable</li>
</ul>
<h3 id="prop-alpnprotocolname"><a class="header" href="#prop-alpnprotocolname">prop alpnProtocolName</a></h3>
<pre><code class="language-cangjie">public prop alpnProtocolName: ?String
</code></pre>
<p>功能：读取协商到的应用层协议名称。</p>
<p>类型：?String</p>
<p>异常：</p>
<ul>
<li><a href="net/tls/tls_package_api/tls_package_exceptions.html#class-tlsexception">TlsException</a> - 当套接字未完成 TLS 握手或本端 TLS 套接字已关闭时，抛出异常。</li>
<li>IllegalMemoryException - 当内存申请失败时，抛出异常。</li>
</ul>
<h3 id="prop-ciphersuite"><a class="header" href="#prop-ciphersuite">prop cipherSuite</a></h3>
<pre><code class="language-cangjie">public prop cipherSuite: CipherSuite
</code></pre>
<p>功能：握手后协商到的加密套。</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>密码套件包含加密算法、用于消息认证的散列函数、密钥交换算法。</p>
</blockquote>
<p>类型：<a href="net/tls/tls_package_api/tls_package_structs.html#struct-ciphersuite">CipherSuite</a></p>
<p>异常：</p>
<ul>
<li><a href="net/tls/tls_package_api/tls_package_exceptions.html#class-tlsexception">TlsException</a> - 当套接字未完成 TLS 握手或本端 TLS 套接字已关闭时，抛出异常。</li>
</ul>
<h3 id="prop-clientcertificate-1"><a class="header" href="#prop-clientcertificate-1">prop clientCertificate</a></h3>
<pre><code class="language-cangjie">public prop clientCertificate: ?Array&lt;X509Certificate&gt;
</code></pre>
<p>功能：客户端提供的客户端证书。在客户端获取时为本端证书，在服务端获取时为对端证书。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>获取对端证书时，如果对端没有发送证书，该接口可能获取失败，返回 None。详见 <a href="net/tls/tls_package_api/./tls_package_classes.html#prop-peercertificate">peerCertificate</a>。</p>
</blockquote>
<p>类型：?Array&lt;<a href="net/tls/tls_package_api/../../../crypto/x509/x509_package_api/x509_package_classes.html#class-x509certificate">X509Certificate</a>&gt;</p>
<p>异常：</p>
<ul>
<li><a href="net/tls/tls_package_api/tls_package_exceptions.html#class-tlsexception">TlsException</a> - 当套接字未完成 TLS 握手或本端 TLS 套接字已关闭时，抛出异常。</li>
</ul>
<h3 id="prop-domain-1"><a class="header" href="#prop-domain-1">prop domain</a></h3>
<pre><code class="language-cangjie">public prop domain: ?String
</code></pre>
<p>功能：读取协商到的服务端主机名称。</p>
<ul>
<li><a href="net/tls/tls_package_api/tls_package_exceptions.html#class-tlsexception">TlsException</a> - 当套接字未完成 TLS 握手或本端 TLS 套接字已关闭时，抛出异常。</li>
</ul>
<p>类型：?String</p>
<h3 id="prop-localaddress"><a class="header" href="#prop-localaddress">prop localAddress</a></h3>
<pre><code class="language-cangjie">public override prop localAddress: SocketAddress
</code></pre>
<p>功能：读取 <a href="net/tls/tls_package_api/tls_package_classes.html#class-tlssocket">TlsSocket</a> 的本地地址。</p>
<p>类型：SocketAddress</p>
<p>异常：</p>
<ul>
<li>SocketException - 本端建连的底层 TCP 套接字关闭，抛出异常。</li>
<li><a href="net/tls/tls_package_api/tls_package_exceptions.html#class-tlsexception">TlsException</a> - 本端配置为 TLS 的套接字已关闭时，抛出异常。</li>
</ul>
<h3 id="prop-peercertificate"><a class="header" href="#prop-peercertificate">prop peerCertificate</a></h3>
<pre><code class="language-cangjie">public prop peerCertificate: ?Array&lt;X509Certificate&gt;
</code></pre>
<p>功能：获取对端证书。在客户端获取时同 <a href="net/tls/tls_package_api/./tls_package_classes.html#prop-servercertificate">serverCertificate</a>，在服务端获取时同 <a href="net/tls/tls_package_api/./tls_package_classes.html#prop-clientcertificate">clientCertificate</a>。</p>
<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>
<p>如果握手时没有要求对端发送证书，此处将无法获取对端证书，返回 None。</p>
</li>
<li>
<p>通过 session 机制恢复连接时，双方都不发送证书，该接口行为如下：</p>
<ul>
<li>在服务端，如果被恢复的原始连接建立时获取了对端证书，服务端将缓存对端证书，并在此处获取到缓存的证书；</li>
<li>在客户端，不缓存原始连接的对端证书，此处将无法获取对端证书，返回 None。</li>
</ul>
</li>
</ul>
</blockquote>
<p>类型：?Array&lt;<a href="net/tls/tls_package_api/../../../crypto/x509/x509_package_api/x509_package_classes.html#class-x509certificate">X509Certificate</a>&gt;</p>
<p>异常：</p>
<ul>
<li><a href="net/tls/tls_package_api/tls_package_exceptions.html#class-tlsexception">TlsException</a> - 当套接字未完成 TLS 握手或本端 TLS 套接字已关闭时，抛出异常。</li>
</ul>
<h3 id="prop-readtimeout-4"><a class="header" href="#prop-readtimeout-4">prop readTimeout</a></h3>
<pre><code class="language-cangjie">public override mut prop readTimeout: ?Duration
</code></pre>
<p>功能：读写 <a href="net/tls/tls_package_api/tls_package_classes.html#class-tlssocket">TlsSocket</a> 的读超时时间。</p>
<p>类型：?Duration</p>
<p>异常：</p>
<ul>
<li>SocketException - 本端建连的底层 TCP 套接字关闭，抛出异常。</li>
<li><a href="net/tls/tls_package_api/tls_package_exceptions.html#class-tlsexception">TlsException</a> - 本端配置为 TLS 的套接字已关闭时，抛出异常。</li>
<li>IllegalArgumentException - 设定的读超时时间为负值时，抛出异常。</li>
</ul>
<h3 id="prop-remoteaddress"><a class="header" href="#prop-remoteaddress">prop remoteAddress</a></h3>
<pre><code class="language-cangjie">public override prop remoteAddress: SocketAddress
</code></pre>
<p>功能：读取 <a href="net/tls/tls_package_api/tls_package_classes.html#class-tlssocket">TlsSocket</a> 的远端地址。</p>
<p>类型：SocketAddress</p>
<p>异常：</p>
<ul>
<li>SocketException - 本端建连的底层 TCP 套接字关闭，抛出异常。</li>
<li><a href="net/tls/tls_package_api/tls_package_exceptions.html#class-tlsexception">TlsException</a> - 本端配置为 TLS 的套接字已关闭时，抛出异常。</li>
</ul>
<h3 id="prop-servercertificate"><a class="header" href="#prop-servercertificate">prop serverCertificate</a></h3>
<pre><code class="language-cangjie">public prop serverCertificate: Array&lt;X509Certificate&gt;
</code></pre>
<p>功能：服务器证书链由服务器提供或在服务器配置中预先配置。在服务端获取时为本端证书，在客户端获取时为对端证书。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>获取对端证书时，如果对端没有发送证书，该接口可能获取失败，返回 None。详见 <a href="net/tls/tls_package_api/./tls_package_classes.html#prop-peercertificate">peerCertificate</a>。</p>
</blockquote>
<p>类型：Array&lt;<a href="net/tls/tls_package_api/../../../crypto/x509/x509_package_api/x509_package_classes.html#class-x509certificate">X509Certificate</a>&gt;</p>
<p>异常：</p>
<ul>
<li><a href="net/tls/tls_package_api/tls_package_exceptions.html#class-tlsexception">TlsException</a> - 当套接字未完成 TLS 握手或本端 TLS 套接字已关闭时，抛出异常。</li>
</ul>
<h3 id="prop-session"><a class="header" href="#prop-session">prop session</a></h3>
<pre><code class="language-cangjie">public prop session: ?TlsSession
</code></pre>
<p>功能：读取 TLS 会话 id , 客户端会在握手成功后捕获当前会话的 id ，可使用该 id 重用该会话，省去 TLS 建立连接时间。连接建立未成功时，返回 <code>None</code>。</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>服务端不做捕获因此始终为 None。</p>
</blockquote>
<p>类型：?<a href="net/tls/tls_package_api/tls_package_structs.html#struct-tlssession">TlsSession</a></p>
<p>异常：</p>
<ul>
<li><a href="net/tls/tls_package_api/tls_package_exceptions.html#class-tlsexception">TlsException</a> - 当套接字未完成 TLS 握手，抛出异常。</li>
</ul>
<h3 id="prop-socket"><a class="header" href="#prop-socket">prop socket</a></h3>
<pre><code class="language-cangjie">public prop socket: StreamingSocket
</code></pre>
<p>功能：<a href="net/tls/tls_package_api/tls_package_classes.html#class-tlssocket">TlsSocket</a> 创建所使用的 StreamingSocket。</p>
<p>类型：StreamingSocket</p>
<p>异常：</p>
<ul>
<li><a href="net/tls/tls_package_api/tls_package_exceptions.html#class-tlsexception">TlsException</a> - 本端配置为 TLS 套接字已关闭时，抛出异常。</li>
</ul>
<h3 id="prop-tlsversion"><a class="header" href="#prop-tlsversion">prop tlsVersion</a></h3>
<pre><code class="language-cangjie">public prop tlsVersion: TlsVersion
</code></pre>
<p>功能：读取协商到的 TLS 版本。</p>
<p>类型：<a href="net/tls/tls_package_api/tls_package_enums.html#enum-tlsversion">TlsVersion</a></p>
<p>异常：</p>
<ul>
<li><a href="net/tls/tls_package_api/tls_package_exceptions.html#class-tlsexception">TlsException</a> - 当套接字未完成 TLS 握手或本端 TLS 套接字已关闭时，抛出异常。</li>
</ul>
<h3 id="prop-writetimeout-4"><a class="header" href="#prop-writetimeout-4">prop writeTimeout</a></h3>
<pre><code class="language-cangjie">public override mut prop writeTimeout: ?Duration
</code></pre>
<p>功能：读写 <a href="net/tls/tls_package_api/tls_package_classes.html#class-tlssocket">TlsSocket</a> 的写超时时间。</p>
<p>类型：?Duration</p>
<p>异常：</p>
<ul>
<li>SocketException - 本端建连的底层 TCP 套接字关闭，抛出异常。</li>
<li><a href="net/tls/tls_package_api/tls_package_exceptions.html#class-tlsexception">TlsException</a> - 本端配置为 TLS 的套接字已关闭时，抛出异常。</li>
<li>IllegalArgumentException - 设定的写超时时间为负值时，抛出异常。</li>
</ul>
<h3 id="static-func-clientstreamingsocket-tlssession-tlsclientconfig"><a class="header" href="#static-func-clientstreamingsocket-tlssession-tlsclientconfig">static func client(StreamingSocket, ?TlsSession, TlsClientConfig)</a></h3>
<pre><code class="language-cangjie">public static func client(
    socket: StreamingSocket,
    session!: ?TlsSession = None,
    clientConfig!: TlsClientConfig = TlsClientConfig()
): TlsSocket
</code></pre>
<p>功能：根据传入的 StreamingSocket 实例创建指定地址的客户端 TLS 套接字，该套接字可用于客户端 TLS 握手及会话。</p>
<p>参数：</p>
<ul>
<li>socket: StreamingSocket - 已连接到服务端的客户端 TCP 套接字。</li>
<li>session!: ?<a href="net/tls/tls_package_api/tls_package_structs.html#struct-tlssession">TlsSession</a> - TLS 会话 id，若存在可用的 TLS 会话， 则可通过该 id 恢复历史 TLS 会话，省去 TLS 建立连接时间，但使用该会话依然可能协商失败。默认为 <code>None</code>。</li>
<li>clientConfig!: <a href="net/tls/tls_package_api/tls_package_structs.html#struct-tlsclientconfig">TlsClientConfig</a> - 客户端配置，默认为 <a href="net/tls/tls_package_api/tls_package_structs.html#struct-tlsclientconfig">TlsClientConfig</a>()。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/tls/tls_package_api/tls_package_classes.html#class-tlssocket">TlsSocket</a> - 构造出的 <a href="net/tls/tls_package_api/tls_package_classes.html#class-tlssocket">TlsSocket</a> 实例。</li>
</ul>
<h3 id="static-func-serverstreamingsocket-tlssessioncontext-tlsserverconfig"><a class="header" href="#static-func-serverstreamingsocket-tlssessioncontext-tlsserverconfig">static func server(StreamingSocket, ?TlsSessionContext, TlsServerConfig)</a></h3>
<pre><code class="language-cangjie">public static func server(
    socket: StreamingSocket,
    sessionContext!: ?TlsSessionContext = None,
    serverConfig!: TlsServerConfig
): TlsSocket
</code></pre>
<p>功能：根据传入的 StreamingSocket 实例创建指定地址的服务端 TLS 套接字，该套接字可用于服务端 TLS 握手及会话。</p>
<p>参数：</p>
<ul>
<li>socket: StreamingSocket - TCP 连接建立完成后接受到套接字。</li>
<li>sessionContext!: ?<a href="net/tls/tls_package_api/tls_package_classes.html#class-tlssessioncontext">TlsSessionContext</a> - TLS 会话 id， 若存在可用的 TLS 会话， 则可通过该 id 恢复历史 TLS 会话，省去 TLS 建立连接时间，但使用该会话依然可能协商失败。默认为 None。</li>
<li>serverConfig!: <a href="net/tls/tls_package_api/tls_package_structs.html#struct-tlsserverconfig">TlsServerConfig</a> - 服务端配置，默认为 <a href="net/tls/tls_package_api/tls_package_structs.html#struct-tlsserverconfig">TlsServerConfig</a>()。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="net/tls/tls_package_api/tls_package_classes.html#class-tlssocket">TlsSocket</a> - 构造出的 <a href="net/tls/tls_package_api/tls_package_classes.html#class-tlssocket">TlsSocket</a> 实例。</li>
</ul>
<h3 id="func-close-11"><a class="header" href="#func-close-11">func close()</a></h3>
<pre><code class="language-cangjie">public func close(): Unit
</code></pre>
<p>功能：关闭套接字。</p>
<p>异常：</p>
<ul>
<li>SocketException - 底层连接无法关闭时，抛出异常。</li>
</ul>
<h3 id="func-handshakeduration"><a class="header" href="#func-handshakeduration">func handshake(?Duration)</a></h3>
<pre><code class="language-cangjie">public func handshake(timeout!: ?Duration = None): Unit
</code></pre>
<p>功能：TLS 握手。不支持重新协商握手，因此只能被调用一次。调用对象可以为客户端或者服务端的 <a href="net/tls/tls_package_api/tls_package_classes.html#class-tlssocket">TlsSocket</a>。</p>
<p>参数：</p>
<ul>
<li>timeout!: ?Duration - 握手超时时间，默认为 None 不对超时时间进行设置，此时采用默认 30s 的超时时间。</li>
</ul>
<p>异常：</p>
<ul>
<li>SocketException - 本端建连的底层 TCP 套接字关闭，抛出异常。</li>
<li>SocketTimeoutException - 底层 TCP 套接字连接超时时，抛出异常。</li>
<li><a href="net/tls/tls_package_api/tls_package_exceptions.html#class-tlsexception">TlsException</a> - 当握手已经开始或者已经结束，抛出异常或当握手阶段出现系统错误时，抛出异常。</li>
<li>IllegalArgumentException - 设定的握手超时时间为负值时，抛出异常。</li>
</ul>
<h3 id="func-hashcode-6"><a class="header" href="#func-hashcode-6">func hashCode()</a></h3>
<pre><code class="language-cangjie">public override func hashCode(): Int64
</code></pre>
<p>功能：返回 TLS 套接字对象的哈希值。</p>
<p>返回值：</p>
<ul>
<li>Int64 - 对 TLS 套接字对象进行哈希计算后得到的结果。</li>
</ul>
<h3 id="func-isclosed-4"><a class="header" href="#func-isclosed-4">func isClosed()</a></h3>
<pre><code class="language-cangjie">public func isClosed(): Bool
</code></pre>
<p>功能：返回套接字是否关闭的状态。</p>
<p>返回值：</p>
<ul>
<li>Bool - 连接断开返回 true；否则，返回 false。</li>
</ul>
<h3 id="func-readarraybyte-2"><a class="header" href="#func-readarraybyte-2">func read(Array&lt;Byte&gt;)</a></h3>
<pre><code class="language-cangjie">public override func read(buffer: Array&lt;Byte&gt;): Int64
</code></pre>
<p>功能：<a href="net/tls/tls_package_api/tls_package_classes.html#class-tlssocket">TlsSocket</a> 读取数据。</p>
<p>参数：</p>
<ul>
<li>buffer: Array&lt;Byte&gt; - 存储读取到的数据内容的数组。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Int64 - 读取到的数据内容字节数。</li>
</ul>
<p>异常：</p>
<ul>
<li>SocketException - 本端建连的底层 TCP 套接字关闭，抛出异常。</li>
<li><a href="net/tls/tls_package_api/tls_package_exceptions.html#class-tlsexception">TlsException</a> - 当 <code>buffer</code> 为空，或者 <a href="net/tls/tls_package_api/tls_package_classes.html#class-tlssocket">TlsSocket</a> 未连接，或读取数据出现系统错误等。</li>
</ul>
<h3 id="func-tostring-34"><a class="header" href="#func-tostring-34">func toString()</a></h3>
<pre><code class="language-cangjie">public func toString(): String
</code></pre>
<p>功能：套接字的字符串表示，字符串内容为当前套接字状态。</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>例如：当前套接字处于可开始进行握手状态时，该接口将返回字符串 &quot;<a href="net/tls/tls_package_api/tls_package_classes.html#class-tlssocket">TlsSocket</a>(TcpSocket(${本端地址} -&gt; ${对端地址}), ready for handshake)&quot;</p>
</blockquote>
<p>返回值：</p>
<ul>
<li>String - 该 TLS 连接字符串。</li>
</ul>
<h3 id="func-writearraybyte-11"><a class="header" href="#func-writearraybyte-11">func write(Array&lt;Byte&gt;)</a></h3>
<pre><code class="language-cangjie">public func write(buffer: Array&lt;Byte&gt;): Unit
</code></pre>
<p>功能：<a href="net/tls/tls_package_api/tls_package_classes.html#class-tlssocket">TlsSocket</a> 发送数据。</p>
<p>参数：</p>
<ul>
<li>buffer: Array&lt;Byte&gt; - 存储将要发送的数据内容数组。</li>
</ul>
<p>异常：</p>
<ul>
<li>SocketException - 本端建连的底层 TCP 套接字关闭，抛出异常。</li>
<li><a href="net/tls/tls_package_api/tls_package_exceptions.html#class-tlsexception">TlsException</a> - 当套接字已关闭，或者 <a href="net/tls/tls_package_api/tls_package_classes.html#class-tlssocket">TlsSocket</a> 未连接，或写入数据出现系统错误等。</li>
</ul>
<h3 id="operator-func-tlssocket"><a class="header" href="#operator-func-tlssocket">operator func !=(TlsSocket)</a></h3>
<pre><code class="language-cangjie">public override operator func !=(other: TlsSocket)
</code></pre>
<p>功能：判断两 <a href="net/tls/tls_package_api/tls_package_classes.html#class-tlssocket">TlsSocket</a> 是否引用不同实例。</p>
<p>参数：</p>
<ul>
<li>other: <a href="net/tls/tls_package_api/tls_package_classes.html#class-tlssocket">TlsSocket</a> - 对比的 TLS 套接字。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Unit - 对比的套接字不同返回 <code>true</code>；否则，返回 <code>false</code>。</li>
</ul>
<h3 id="operator-func-tlssocket-1"><a class="header" href="#operator-func-tlssocket-1">operator func ==(TlsSocket)</a></h3>
<pre><code class="language-cangjie">public override operator func ==(other: TlsSocket)
</code></pre>
<p>功能：判断两 <a href="net/tls/tls_package_api/tls_package_classes.html#class-tlssocket">TlsSocket</a> 是否引用同一实例。</p>
<p>参数：</p>
<ul>
<li>other: <a href="net/tls/tls_package_api/tls_package_classes.html#class-tlssocket">TlsSocket</a> - 对比的 TLS 套接字。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Unit - 对比的套接字相同返回 <code>true</code>；否则，返回 <code>false</code>。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="枚举-13"><a class="header" href="#枚举-13">枚举</a></h1>
<h2 id="enum-certificateverifymode"><a class="header" href="#enum-certificateverifymode">enum CertificateVerifyMode</a></h2>
<pre><code class="language-cangjie">public enum CertificateVerifyMode {
    | CustomCA(Array&lt;X509Certificate&gt;)
    | Default
    | TrustAll
}
</code></pre>
<p>功能：对证书验证的处理模式。</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>CustomCA 模式可使用用户配置的证书地址，适用于用户证书无法设置为系统证书的场景。<br>
证书认证模式，TCP 连接建立成功后，客户端和服务端可交换证书，Default 模式使用系统证书。<br>
在开发测试阶段，可使用 TrustAll 模式，该模式表示本端不作对对端证书的校验。此模式本端信任任意建立连接对象，一般仅在开发测试阶段使用。</p>
</blockquote>
<h3 id="customcaarrayx509certificate"><a class="header" href="#customcaarrayx509certificate">CustomCA(Array&lt;X509Certificate&gt;)</a></h3>
<pre><code class="language-cangjie">CustomCA(Array&lt;X509Certificate&gt;)
</code></pre>
<p>功能：表示根据提供的 CA 列表进行验证。</p>
<h3 id="default"><a class="header" href="#default">Default</a></h3>
<pre><code class="language-cangjie">Default
</code></pre>
<p>功能：表示默认验证模式，根据系统 CA 验证证书。</p>
<h3 id="trustall"><a class="header" href="#trustall">TrustAll</a></h3>
<pre><code class="language-cangjie">TrustAll
</code></pre>
<p>功能：表示信任所有证书。</p>
<h2 id="enum-signaturealgorithm-1"><a class="header" href="#enum-signaturealgorithm-1">enum SignatureAlgorithm</a></h2>
<pre><code class="language-cangjie">public enum SignatureAlgorithm &lt;: ToString &amp; Equatable&lt;SignatureAlgorithm&gt; {
    | SignatureAndHashAlgorithm(SignatureType, HashType)
    | SignatureScheme(SignatureSchemeType)
}
</code></pre>
<p>功能：签名算法类型，签名算法用于确保传输数据的身份验证、完整性和真实性。</p>
<p>父类型：</p>
<ul>
<li>ToString</li>
<li>Equatable&lt;<a href="net/tls/tls_package_api/../../../crypto/x509/x509_package_api/x509_package_enums.html#enum-signaturealgorithm">SignatureAlgorithm</a>&gt;</li>
</ul>
<h3 id="signatureandhashalgorithmsignaturetype-hashtype"><a class="header" href="#signatureandhashalgorithmsignaturetype-hashtype">SignatureAndHashAlgorithm(SignatureType, HashType)</a></h3>
<pre><code class="language-cangjie">SignatureAndHashAlgorithm(SignatureType, HashType)
</code></pre>
<p>功能：表明哪个签名和哈希算法对会被用于数字签名，自 TLS 1.2 及以后版本，包含签名和哈希算法类型。</p>
<h3 id="signatureschemesignatureschemetype"><a class="header" href="#signatureschemesignatureschemetype">SignatureScheme(SignatureSchemeType)</a></h3>
<pre><code class="language-cangjie">SignatureScheme(SignatureSchemeType)
</code></pre>
<p>功能：签名方案，自 TLS 1.3 及以后版本，业界更为推荐的指定签名算法的方式。</p>
<h3 id="func-tostring-35"><a class="header" href="#func-tostring-35">func toString()</a></h3>
<pre><code class="language-cangjie">public func toString():String
</code></pre>
<p>功能：转换签名算法的字符串表示。</p>
<p>返回值：</p>
<ul>
<li>String - 签名算法名称。</li>
</ul>
<h3 id="operator-func-signaturealgorithm"><a class="header" href="#operator-func-signaturealgorithm">operator func !=(SignatureAlgorithm)</a></h3>
<pre><code class="language-cangjie">public operator func !=(other: SignatureAlgorithm) : Bool
</code></pre>
<p>功能：判断签名算法类型是否不同。</p>
<p>参数：</p>
<ul>
<li>other: <a href="net/tls/tls_package_api/tls_package_enums.html#enum-signaturealgorithm">SignatureAlgorithm</a> - 对比的签名算法类型。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - 不相同返回 <code>true</code>；否则，返回 <code>false</code>。</li>
</ul>
<h3 id="operator-func-signaturealgorithm-1"><a class="header" href="#operator-func-signaturealgorithm-1">operator func ==(SignatureAlgorithm)</a></h3>
<pre><code class="language-cangjie">public operator func ==(other: SignatureAlgorithm) : Bool
</code></pre>
<p>功能：判断签名算法类型是否相同。</p>
<p>参数：</p>
<ul>
<li>other: <a href="net/tls/tls_package_api/tls_package_enums.html#enum-signaturealgorithm">SignatureAlgorithm</a> - 对比的签名算法类型。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - 相同返回 <code>true</code>；否则，返回 <code>false</code>。</li>
</ul>
<h2 id="enum-signatureschemetype"><a class="header" href="#enum-signatureschemetype">enum SignatureSchemeType</a></h2>
<pre><code class="language-cangjie">public enum SignatureSchemeType &lt;: ToString &amp; Equatable&lt;SignatureSchemeType&gt; {
    | RSA_PKCS1_SHA256
    | RSA_PKCS1_SHA384
    | RSA_PKCS1_SHA512
    | ECDSA_SECP256R1_SHA256
    | ECDSA_SECP384R1_SHA384
    | ECDSA_SECP521R1_SHA512
    | RSA_PSS_RSAE_SHA256
    | RSA_PSS_RSAE_SHA384
    | RSA_PSS_RSAE_SHA512
    | ED25519
    | ED448
    | RSA_PSS_PSS_SHA256
    | RSA_PSS_PSS_SHA384
    | RSA_PSS_PSS_SHA512
}
</code></pre>
<p>功能：加密算法类型，用于保护网络通信的安全性和隐私性。</p>
<p>父类型：</p>
<ul>
<li>ToString</li>
<li>Equatable&lt;<a href="net/tls/tls_package_api/tls_package_enums.html#enum-signatureschemetype">SignatureSchemeType</a>&gt;</li>
</ul>
<h3 id="ecdsa_secp256r1_sha256"><a class="header" href="#ecdsa_secp256r1_sha256">ECDSA_SECP256R1_SHA256</a></h3>
<pre><code class="language-cangjie">ECDSA_SECP256R1_SHA256
</code></pre>
<p>功能：创建一个 <code>ECDSA_SECP256R1_SHA256</code> 类型的枚举实例，表示加密算法类型使用 <code>ECDSA_SECP256R1_SHA256</code>。</p>
<h3 id="ecdsa_secp384r1_sha384"><a class="header" href="#ecdsa_secp384r1_sha384">ECDSA_SECP384R1_SHA384</a></h3>
<pre><code class="language-cangjie">ECDSA_SECP384R1_SHA384
</code></pre>
<p>功能：创建一个 <code>ECDSA_SECP384R1_SHA384</code> 类型的枚举实例，表示加密算法类型使用 <code>ECDSA_SECP384R1_SHA384</code>。</p>
<h3 id="ecdsa_secp521r1_sha512"><a class="header" href="#ecdsa_secp521r1_sha512">ECDSA_SECP521R1_SHA512</a></h3>
<pre><code class="language-cangjie">ECDSA_SECP521R1_SHA512
</code></pre>
<p>功能：创建一个 <code>ECDSA_SECP521R1_SHA512</code> 类型的枚举实例，表示加密算法类型使用 <code>ECDSA_SECP521R1_SHA512</code>。</p>
<h3 id="ed25519"><a class="header" href="#ed25519">ED25519</a></h3>
<pre><code class="language-cangjie">ED25519
</code></pre>
<p>功能：创建一个 <code>ED25519</code> 类型的枚举实例，表示加密算法类型使用 ED25519。</p>
<h3 id="ed448"><a class="header" href="#ed448">ED448</a></h3>
<pre><code class="language-cangjie">ED448
</code></pre>
<p>功能：创建一个 <code>ED448</code> 类型的枚举实例，表示加密算法类型使用 ED448。</p>
<h3 id="rsa_pkcs1_sha256"><a class="header" href="#rsa_pkcs1_sha256">RSA_PKCS1_SHA256</a></h3>
<pre><code class="language-cangjie">RSA_PKCS1_SHA256
</code></pre>
<p>功能：创建一个 <code>RSA_PKCS1_SHA256</code> 类型的枚举实例，表示加密算法类型使用 <code>RSA_PKCS1_SHA256</code>。</p>
<h3 id="rsa_pkcs1_sha384"><a class="header" href="#rsa_pkcs1_sha384">RSA_PKCS1_SHA384</a></h3>
<pre><code class="language-cangjie">RSA_PKCS1_SHA384
</code></pre>
<p>功能：创建一个 <code>RSA_PKCS1_SHA384</code> 类型的枚举实例，表示加密算法类型使用 <code>RSA_PKCS1_SHA384</code>。</p>
<h3 id="rsa_pkcs1_sha512"><a class="header" href="#rsa_pkcs1_sha512">RSA_PKCS1_SHA512</a></h3>
<pre><code class="language-cangjie">RSA_PKCS1_SHA512
</code></pre>
<p>功能：创建一个 <code>RSA_PKCS1_SHA512</code> 类型的枚举实例，表示加密算法类型使用 <code>RSA_PKCS1_SHA512</code>。</p>
<h3 id="rsa_pss_pss_sha256"><a class="header" href="#rsa_pss_pss_sha256">RSA_PSS_PSS_SHA256</a></h3>
<pre><code class="language-cangjie">RSA_PSS_PSS_SHA256
</code></pre>
<p>功能：创建一个 <code>RSA_PSS_PSS_SHA256</code> 类型的枚举实例，表示加密算法类型使用 <code>RSA_PSS_PSS_SHA256</code>。</p>
<h3 id="rsa_pss_pss_sha384"><a class="header" href="#rsa_pss_pss_sha384">RSA_PSS_PSS_SHA384</a></h3>
<pre><code class="language-cangjie">RSA_PSS_PSS_SHA384
</code></pre>
<p>功能：创建一个 <code>RSA_PSS_PSS_SHA384</code> 类型的枚举实例，表示加密算法类型使用 <code>RSA_PSS_PSS_SHA384</code>。</p>
<h3 id="rsa_pss_pss_sha512"><a class="header" href="#rsa_pss_pss_sha512">RSA_PSS_PSS_SHA512</a></h3>
<pre><code class="language-cangjie">RSA_PSS_PSS_SHA512
</code></pre>
<p>功能：创建一个 <code>RSA_PSS_PSS_SHA512</code> 类型的枚举实例，表示加密算法类型使用 <code>RSA_PSS_PSS_SHA512</code>。</p>
<h3 id="rsa_pss_rsae_sha256"><a class="header" href="#rsa_pss_rsae_sha256">RSA_PSS_RSAE_SHA256</a></h3>
<pre><code class="language-cangjie">RSA_PSS_RSAE_SHA256
</code></pre>
<p>功能：创建一个 <code>RSA_PSS_RSAE_SHA256</code> 类型的枚举实例，表示加密算法类型使用 <code>RSA_PSS_RSAE_SHA256</code>。</p>
<h3 id="rsa_pss_rsae_sha384"><a class="header" href="#rsa_pss_rsae_sha384">RSA_PSS_RSAE_SHA384</a></h3>
<pre><code class="language-cangjie">RSA_PSS_RSAE_SHA384
</code></pre>
<p>功能：创建一个 <code>RSA_PSS_RSAE_SHA384</code> 类型的枚举实例，表示加密算法类型使用 <code>RSA_PSS_RSAE_SHA384</code>。</p>
<h3 id="rsa_pss_rsae_sha512"><a class="header" href="#rsa_pss_rsae_sha512">RSA_PSS_RSAE_SHA512</a></h3>
<pre><code class="language-cangjie">RSA_PSS_RSAE_SHA512
</code></pre>
<p>功能：创建一个 <code>RSA_PSS_RSAE_SHA512</code> 类型的枚举实例，表示加密算法类型使用 <code>RSA_PSS_RSAE_SHA384</code>。</p>
<h3 id="func-tostring-36"><a class="header" href="#func-tostring-36">func toString()</a></h3>
<pre><code class="language-cangjie">public func toString(): String
</code></pre>
<p>功能：加密算法类型的字符串表示。</p>
<p>如 <code>RSA_PKCS1_SHA256</code> 的字符串表示为 &quot;rsa_pkcs1_sha256&quot;。</p>
<p>返回值：</p>
<ul>
<li>String - 加密算法类型的字符串表示。</li>
</ul>
<h3 id="operator-func-signatureschemetype"><a class="header" href="#operator-func-signatureschemetype">operator func !=(SignatureSchemeType)</a></h3>
<pre><code class="language-cangjie">public operator func !=(other: SignatureSchemeType): Bool
</code></pre>
<p>功能：判断两者是否为不同加密算法类型。</p>
<p>参数：</p>
<ul>
<li>other: <a href="net/tls/tls_package_api/tls_package_enums.html#enum-signatureschemetype">SignatureSchemeType</a> - 对比的加密算法类型。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - 不相同返回 true；否则，返回 false。</li>
</ul>
<h3 id="operator-func-signatureschemetype-1"><a class="header" href="#operator-func-signatureschemetype-1">operator func ==(SignatureSchemeType)</a></h3>
<pre><code class="language-cangjie">public operator func ==(other: SignatureSchemeType): Bool
</code></pre>
<p>功能：判断两者是否为同一加密算法类型。</p>
<p>参数：</p>
<ul>
<li>other: <a href="net/tls/tls_package_api/tls_package_enums.html#enum-signatureschemetype">SignatureSchemeType</a> - 对比的加密算法类型。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - 相同返回 true；否则，返回 false。</li>
</ul>
<h2 id="enum-signaturetype"><a class="header" href="#enum-signaturetype">enum SignatureType</a></h2>
<pre><code class="language-cangjie">public enum SignatureType &lt;: ToString &amp; Equatable&lt;SignatureType&gt; {
    | DSA
    | ECDSA
    | RSA
}
</code></pre>
<p>功能：签名算法类型，用于认证真实性。参见 <a href="https://www.rfc-editor.org/rfc/rfc5246.html#section-7.4.1.4.1">RFC5246 7.4.1.4.1</a> 章节。</p>
<p>父类型：</p>
<ul>
<li>ToString</li>
<li>Equatable&lt;<a href="net/tls/tls_package_api/tls_package_enums.html#enum-signaturetype">SignatureType</a>&gt;</li>
</ul>
<h3 id="dsa-1"><a class="header" href="#dsa-1">DSA</a></h3>
<pre><code class="language-cangjie">DSA
</code></pre>
<p>功能：创建一个 <code>DSA</code> 类型的枚举实例，表示采用数字签名算法。</p>
<h3 id="ecdsa-1"><a class="header" href="#ecdsa-1">ECDSA</a></h3>
<pre><code class="language-cangjie">ECDSA
</code></pre>
<p>功能：创建一个 <code>ECDSA</code> 类型的枚举实例，表示采用椭圆曲线数字签名算法。</p>
<h3 id="rsa-1"><a class="header" href="#rsa-1">RSA</a></h3>
<pre><code class="language-cangjie">RSA
</code></pre>
<p>功能：创建一个 <code>RSA</code> 类型的枚举实例，表示采用 RSA 加密算法。</p>
<h3 id="func-tostring-37"><a class="header" href="#func-tostring-37">func toString()</a></h3>
<pre><code class="language-cangjie">public func toString(): String
</code></pre>
<p>功能：转换为签名算法的字符串表示。</p>
<p>返回值：</p>
<ul>
<li>String - 签名算法的名称。</li>
</ul>
<h3 id="operator-func-signaturetype"><a class="header" href="#operator-func-signaturetype">operator func !=(SignatureType)</a></h3>
<pre><code class="language-cangjie">public operator func !=(other: SignatureType) : Bool
</code></pre>
<p>功能：判断两者是否为不同的签名算法。</p>
<p>参数：</p>
<ul>
<li>other: <a href="net/tls/tls_package_api/tls_package_enums.html#enum-signaturetype">SignatureType</a> - 对比的签名算法类型。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - 不相同返回 <code>true</code>；否则，返回 <code>false</code>。</li>
</ul>
<h3 id="operator-func-signaturetype-1"><a class="header" href="#operator-func-signaturetype-1">operator func ==(SignatureType)</a></h3>
<pre><code class="language-cangjie">public operator func ==(other: SignatureType) : Bool
</code></pre>
<p>功能：判断两者是否为相同的签名算法。</p>
<p>参数：</p>
<ul>
<li>other: <a href="net/tls/tls_package_api/tls_package_enums.html#enum-signaturetype">SignatureType</a> - 对比的签名算法类型。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - 相同返回 <code>true</code>；否则，返回 <code>false</code>。</li>
</ul>
<h2 id="enum-tlsclientidentificationmode"><a class="header" href="#enum-tlsclientidentificationmode">enum TlsClientIdentificationMode</a></h2>
<pre><code class="language-cangjie">public enum TlsClientIdentificationMode {
    | Disabled
    | Optional
    | Required
}
</code></pre>
<p>功能：服务端对客户端证书的认证模式。</p>
<h3 id="disabled"><a class="header" href="#disabled">Disabled</a></h3>
<pre><code class="language-cangjie">Disabled
</code></pre>
<p>功能：表示服务端不校验客户端证书，客户端可以不发送证书和公钥，即单向认证。</p>
<h3 id="optional"><a class="header" href="#optional">Optional</a></h3>
<pre><code class="language-cangjie">Optional
</code></pre>
<p>功能：表示服务端校验客户端证书，但客户端可以不提供证书及公钥，不提供时则单向认证，提供时则为双向认证。</p>
<h3 id="required"><a class="header" href="#required">Required</a></h3>
<pre><code class="language-cangjie">Required
</code></pre>
<p>功能：表示服务端校验客户端证书，并且要求客户端必须提供证书和公钥，即双向认证。</p>
<h2 id="enum-tlsversion"><a class="header" href="#enum-tlsversion">enum TlsVersion</a></h2>
<pre><code class="language-cangjie">public enum TlsVersion &lt;: ToString {
    | V1_2
    | V1_3
    | Unknown
}
</code></pre>
<p>功能：TLS 协议版本</p>
<p>父类型：</p>
<ul>
<li>ToString</li>
</ul>
<h3 id="unknown"><a class="header" href="#unknown">Unknown</a></h3>
<pre><code class="language-cangjie">Unknown
</code></pre>
<p>功能：表示未知协议版本。</p>
<h3 id="v1_2"><a class="header" href="#v1_2">V1_2</a></h3>
<pre><code class="language-cangjie">V1_2
</code></pre>
<p>功能：表示 TLS 1.2。</p>
<h3 id="v1_3"><a class="header" href="#v1_3">V1_3</a></h3>
<pre><code class="language-cangjie">V1_3
</code></pre>
<p>功能：表示 TLS 1.3。</p>
<h3 id="func-tostring-38"><a class="header" href="#func-tostring-38">func toString()</a></h3>
<pre><code class="language-cangjie">public override func toString(): String
</code></pre>
<p>功能：返回当前 <a href="net/tls/tls_package_api/tls_package_enums.html#enum-tlsversion">TlsVersion</a> 的字符串表示。</p>
<p>返回值：</p>
<ul>
<li>String - 当前 <a href="net/tls/tls_package_api/tls_package_enums.html#enum-tlsversion">TlsVersion</a> 的字符串表示。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="结构体-15"><a class="header" href="#结构体-15">结构体</a></h1>
<h2 id="struct-ciphersuite"><a class="header" href="#struct-ciphersuite">struct CipherSuite</a></h2>
<pre><code class="language-cangjie">public struct CipherSuite &lt;: ToString &amp; Equatable&lt;CipherSuite&gt;
</code></pre>
<p>功能：TLS 中的密码套件。</p>
<p>父类型：</p>
<ul>
<li>ToString</li>
<li>Equatable&lt;<a href="net/tls/tls_package_api/tls_package_structs.html#struct-ciphersuite">CipherSuite</a>&gt;</li>
</ul>
<h3 id="static-prop-allsupported"><a class="header" href="#static-prop-allsupported">static prop allSupported</a></h3>
<pre><code class="language-cangjie">public static prop allSupported: Array&lt;CipherSuite&gt;
</code></pre>
<p>功能：返回所有支持的密码套件。</p>
<p>返回值：存放密码套件的数组。</p>
<p>类型：Array&lt;<a href="net/tls/tls_package_api/tls_package_structs.html#struct-ciphersuite">CipherSuite</a>&gt;</p>
<h3 id="func-tostring-39"><a class="header" href="#func-tostring-39">func toString()</a></h3>
<pre><code class="language-cangjie">public func toString(): String
</code></pre>
<p>功能：返回密码套件名称。</p>
<p>返回值：</p>
<ul>
<li>String - 密码套件名称。</li>
</ul>
<h3 id="operator-func-ciphersuite"><a class="header" href="#operator-func-ciphersuite">operator func !=(CipherSuite)</a></h3>
<pre><code class="language-cangjie">public operator func !=(that: CipherSuite): Bool
</code></pre>
<p>功能：判断两个密码套件是否不等。</p>
<p>参数：</p>
<ul>
<li>that: <a href="net/tls/tls_package_api/tls_package_structs.html#struct-ciphersuite">CipherSuite</a> - 被比较的密码套件对象。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - 若不等，则返回 <code>true</code>；反之，返回 <code>false</code>。</li>
</ul>
<h3 id="operator-func-ciphersuite-1"><a class="header" href="#operator-func-ciphersuite-1">operator func ==(CipherSuite)</a></h3>
<pre><code class="language-cangjie">public operator func ==(that: CipherSuite): Bool
</code></pre>
<p>功能：判断两个密码套件是否相等。</p>
<p>参数：</p>
<ul>
<li>that: <a href="net/tls/tls_package_api/tls_package_structs.html#struct-ciphersuite">CipherSuite</a> - 被比较的密码套件对象。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - 若相等，则返回 <code>true</code>；反之，返回 <code>false</code>。</li>
</ul>
<h2 id="struct-tlsclientconfig"><a class="header" href="#struct-tlsclientconfig">struct TlsClientConfig</a></h2>
<pre><code class="language-cangjie">public struct TlsClientConfig {
    public var keylogCallback: ?(TlsSocket, String) -&gt; Unit = None
    public var verifyMode: CertificateVerifyMode = CertificateVerifyMode.Default
    public init()
}
</code></pre>
<p>功能：客户端配置。</p>
<h3 id="var-keylogcallback"><a class="header" href="#var-keylogcallback">var keylogCallback</a></h3>
<pre><code class="language-cangjie">public var keylogCallback: ?(TlsSocket, String) -&gt; Unit = None
</code></pre>
<p>功能：握手过程的回调函数，提供 TLS 初始秘钥数据，用于调试和解密记录使用。</p>
<p>类型：?(<a href="net/tls/tls_package_api/tls_package_classes.html#class-tlssocket">TlsSocket</a>, String) -&gt; Unit</p>
<h3 id="var-verifymode"><a class="header" href="#var-verifymode">var verifyMode</a></h3>
<pre><code class="language-cangjie">public var verifyMode: CertificateVerifyMode = CertificateVerifyMode.Default
</code></pre>
<p>功能：设置或获取证书认证模式，默认为 <code>Default</code>。</p>
<p>类型：<a href="net/tls/tls_package_api/tls_package_enums.html#enum-certificateverifymode">CertificateVerifyMode</a></p>
<h3 id="prop-alpnprotocolslist"><a class="header" href="#prop-alpnprotocolslist">prop alpnProtocolsList</a></h3>
<pre><code class="language-cangjie">public mut prop alpnProtocolsList: Array&lt;String&gt;
</code></pre>
<p>功能：要求的应用层协议名称。若列表为空，则客户将不协商应用层协议。</p>
<p>类型：Array&lt;String&gt;</p>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 列表元素有 '\0' 字符时，抛出异常。</li>
</ul>
<h3 id="prop-ciphersuitesv1_2"><a class="header" href="#prop-ciphersuitesv1_2">prop cipherSuitesV1_2</a></h3>
<pre><code class="language-cangjie">public mut prop cipherSuitesV1_2: ?Array&lt;String&gt;
</code></pre>
<p>功能：基于 TLS 1.2 协议下的加密套。</p>
<p>类型：?Array&lt;String&gt;</p>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 列表元素有 '\0' 字符时，抛出异常。</li>
</ul>
<h3 id="prop-ciphersuitesv1_3"><a class="header" href="#prop-ciphersuitesv1_3">prop cipherSuitesV1_3</a></h3>
<pre><code class="language-cangjie">public mut prop cipherSuitesV1_3: ?Array&lt;String&gt;
</code></pre>
<p>功能：基于 TLS 1.3 协议下的加密套。</p>
<p>类型：?Array&lt;String&gt;</p>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 列表元素有 '\0' 字符时，抛出异常。</li>
</ul>
<h3 id="prop-clientcertificate-2"><a class="header" href="#prop-clientcertificate-2">prop clientCertificate</a></h3>
<pre><code class="language-cangjie">public mut prop clientCertificate: ?(Array&lt;X509Certificate&gt;, PrivateKey)
</code></pre>
<p>功能：客户端证书和私钥。</p>
<p>类型：?(Array&lt;<a href="net/tls/tls_package_api/../../../crypto/x509/x509_package_api/x509_package_classes.html#class-x509certificate">X509Certificate</a>&gt;, PrivateKey)</p>
<h3 id="prop-domain-2"><a class="header" href="#prop-domain-2">prop domain</a></h3>
<pre><code class="language-cangjie">public mut prop domain: ?String
</code></pre>
<p>功能：读写要求的服务端主机地址 (SNI)， <code>None</code> 表示不要求。</p>
<p>类型：?String</p>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 参数有 '\0' 字符时，抛出异常。</li>
</ul>
<h3 id="prop-maxversion"><a class="header" href="#prop-maxversion">prop maxVersion</a></h3>
<pre><code class="language-cangjie">public mut prop maxVersion: TlsVersion
</code></pre>
<p>功能：支持的 TLS 最大的版本。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>当仅设置 <code>maxVersion</code> 而未设置 <code>minVersion</code> ，或设置的 <code>maxVersion</code> 低于 <code>minVersion</code> ，将会在握手阶段抛出 <a href="net/tls/tls_package_api/tls_package_exceptions.html#class-tlsexception">TlsException</a>。</p>
</blockquote>
<p>类型：<a href="net/tls/tls_package_api/tls_package_enums.html#enum-tlsversion">TlsVersion</a></p>
<h3 id="prop-minversion"><a class="header" href="#prop-minversion">prop minVersion</a></h3>
<pre><code class="language-cangjie">public mut prop minVersion: TlsVersion
</code></pre>
<p>功能：支持的 TLS 最小的版本。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>当仅设置 <code>minVersion</code> 而未设置 <code>maxVersion</code> ，或设置的 <code>minVersion</code> 高于 <code>maxVersion</code> ，将会在握手阶段抛出 <a href="net/tls/tls_package_api/tls_package_exceptions.html#class-tlsexception">TlsException</a>。</p>
</blockquote>
<p>类型：<a href="net/tls/tls_package_api/tls_package_enums.html#enum-tlsversion">TlsVersion</a></p>
<h3 id="prop-securitylevel"><a class="header" href="#prop-securitylevel">prop securityLevel</a></h3>
<pre><code class="language-cangjie">public mut prop securityLevel: Int32
</code></pre>
<p>功能：指定客户端的安全级别，默认值为2，可选参数值在 0-5 内，参数值含义参见 openssl-SSL_CTX_set_security_level 说明。</p>
<p>类型：Int32</p>
<h3 id="prop-signaturealgorithms"><a class="header" href="#prop-signaturealgorithms">prop signatureAlgorithms</a></h3>
<pre><code class="language-cangjie">public mut prop signatureAlgorithms: ?Array&lt;SignatureAlgorithm&gt;
</code></pre>
<p>功能：指定保序的签名和哈希算法。在值为 <code>None</code> 或者列表为空时，客户端会使用默认的列表。指定列表后，客户端可能不会发送不合适的签名算法。
参见 <a href="https://www.rfc-editor.org/rfc/rfc5246.html#section-7.4.1.4.1">RFC5246 7.4.1.4.1 (TLS 1.2)</a> 章节， <a href="https://www.rfc-editor.org/rfc/rfc8446.html#section-4.2.3">RFC8446 4.2.3. (TLS 1.3)</a> 章节。</p>
<p>类型：?Array&lt;<a href="net/tls/tls_package_api/tls_package_enums.html#enum-signaturealgorithm">SignatureAlgorithm</a>&gt;</p>
<h3 id="init-23"><a class="header" href="#init-23">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造 <a href="net/tls/tls_package_api/tls_package_structs.html#struct-tlsclientconfig">TlsClientConfig</a>。</p>
<h2 id="struct-tlsserverconfig"><a class="header" href="#struct-tlsserverconfig">struct TlsServerConfig</a></h2>
<pre><code class="language-cangjie">public struct TlsServerConfig {
    public var clientIdentityRequired: TlsClientIdentificationMode = Disabled
    public var keylogCallback: ?(TlsSocket, String) -&gt; Unit = None
    public var verifyMode: CertificateVerifyMode = CertificateVerifyMode.Default
    public init(certChain: Array&lt;X509Certificate&gt;, certKey: PrivateKey)
}
</code></pre>
<p>功能：服务端配置。</p>
<h3 id="var-clientidentityrequired"><a class="header" href="#var-clientidentityrequired">var clientIdentityRequired</a></h3>
<pre><code class="language-cangjie">public var clientIdentityRequired: TlsClientIdentificationMode = Disabled
</code></pre>
<p>功能：设置或获取服务端要求客户端的认证模式，默认不要求客户端认证服务端证书，也不要求客户端发送本端证书。</p>
<p>类型：<a href="net/tls/tls_package_api/tls_package_enums.html#enum-tlsclientidentificationmode">TlsClientIdentificationMode</a></p>
<h3 id="var-keylogcallback-1"><a class="header" href="#var-keylogcallback-1">var keylogCallback</a></h3>
<pre><code class="language-cangjie">public var keylogCallback: ?(TlsSocket, String) -&gt; Unit = None
</code></pre>
<p>功能：握手过程的回调函数，提供 TLS 初始秘钥数据，用于调试和解密记录使用。</p>
<p>类型：?(<a href="net/tls/tls_package_api/tls_package_classes.html#class-tlssocket">TlsSocket</a>, String) -&gt; Unit</p>
<h3 id="var-verifymode-1"><a class="header" href="#var-verifymode-1">var verifyMode</a></h3>
<pre><code class="language-cangjie">public var verifyMode: CertificateVerifyMode = CertificateVerifyMode.Default
</code></pre>
<p>功能：设置或获取认证模式，默认认证系统证书。</p>
<p>类型：<a href="net/tls/tls_package_api/tls_package_enums.html#enum-certificateverifymode">CertificateVerifyMode</a></p>
<h3 id="prop-ciphersuitesv1_2-1"><a class="header" href="#prop-ciphersuitesv1_2-1">prop cipherSuitesV1_2</a></h3>
<pre><code class="language-cangjie">public mut prop cipherSuitesV1_2: Array&lt;String&gt;
</code></pre>
<p>功能：基于 TLS 1.2 协议下的加密套。</p>
<p>类型：Array&lt;String&gt;</p>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 列表元素有 '\0' 字符时，抛出异常。</li>
</ul>
<h3 id="prop-ciphersuitesv1_3-1"><a class="header" href="#prop-ciphersuitesv1_3-1">prop cipherSuitesV1_3</a></h3>
<pre><code class="language-cangjie">public mut prop cipherSuitesV1_3: Array&lt;String&gt;
</code></pre>
<p>功能：基于 TLS 1.3 协议下的加密套。</p>
<p>类型：Array&lt;String&gt;</p>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 列表元素有 '\0' 字符时，抛出异常。</li>
</ul>
<h3 id="prop-dhparameters"><a class="header" href="#prop-dhparameters">prop dhParameters</a></h3>
<pre><code class="language-cangjie">public mut prop dhParameters: ?DHParamters
</code></pre>
<p>功能：指定服务端的 DH 密钥参数，默认为 <code>None</code>， 默认情况下使用 openssl 自动生成的参数值。</p>
<p>类型：?<a href="net/tls/tls_package_api/../../../crypto/x509/x509_package_api/x509_package_interfaces.html#interface-dhparamters">DHParamters</a></p>
<h3 id="prop-maxversion-1"><a class="header" href="#prop-maxversion-1">prop maxVersion</a></h3>
<pre><code class="language-cangjie">public mut prop maxVersion: TlsVersion
</code></pre>
<p>功能：支持的最大 TLS 版本。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>当仅设置 <code>maxVersion</code> 而未设置 <code>minVersion</code> ，或设置的 <code>maxVersion</code> 低于 <code>minVersion</code> ，将会在握手阶段抛出 <a href="net/tls/tls_package_api/tls_package_exceptions.html#class-tlsexception">TlsException</a>。</p>
</blockquote>
<p>类型：<a href="net/tls/tls_package_api/tls_package_enums.html#enum-tlsversion">TlsVersion</a></p>
<h3 id="prop-minversion-1"><a class="header" href="#prop-minversion-1">prop minVersion</a></h3>
<pre><code class="language-cangjie">public mut prop minVersion: TlsVersion
</code></pre>
<p>功能：支持的最小 TLS 版本。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>当仅设置 <code>minVersion</code> 而未设置 <code>maxVersion</code> ，或设置的 <code>minVersion</code> 高于 <code>maxVersion</code> ，将会在握手阶段抛出 <a href="net/tls/tls_package_api/tls_package_exceptions.html#class-tlsexception">TlsException</a>。</p>
</blockquote>
<p>类型：<a href="net/tls/tls_package_api/tls_package_enums.html#enum-tlsversion">TlsVersion</a></p>
<h3 id="prop-securitylevel-1"><a class="header" href="#prop-securitylevel-1">prop securityLevel</a></h3>
<pre><code class="language-cangjie">public mut prop securityLevel: Int32
</code></pre>
<p>功能：指定服务端的安全级别，默认值为2，可选参数值在 [0,5] 内，参数值含义参见 <a href="https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_set_security_level.html">openssl-SSL_CTX_set_security_level</a> 说明。
功能：指定服务端的安全级别，默认值为2，可选参数值在 0-5 内，参数值含义参见 openssl-SSL_CTX_set_security_level 说明。</p>
<p>类型：Int32</p>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 当配置值不在 0-5 范围内时，抛出异常。</li>
</ul>
<h3 id="prop-servercertificatearrayx509certificate-privatekey"><a class="header" href="#prop-servercertificatearrayx509certificate-privatekey">prop serverCertificate(Array&lt;X509Certificate&gt;, PrivateKey)</a></h3>
<pre><code class="language-cangjie">public mut prop serverCertificate: (Array&lt;X509Certificate&gt;, PrivateKey)
</code></pre>
<p>功能：服务端证书和对应的私钥文件。</p>
<p>类型：(Array&lt;<a href="net/tls/tls_package_api/../../../crypto/x509/x509_package_api/x509_package_classes.html#class-x509certificate">X509Certificate</a>&gt;, PrivateKey)</p>
<h3 id="prop-supportedalpnprotocols"><a class="header" href="#prop-supportedalpnprotocols">prop supportedAlpnProtocols</a></h3>
<pre><code class="language-cangjie">public mut prop supportedAlpnProtocols: Array&lt;String&gt;
</code></pre>
<p>功能：应用层协商协议，若客户端尝试协商该协议，服务端将与选取其中相交的协议名称。若客户端未尝试协商协议，则该配置将被忽略。</p>
<p>类型：Array&lt;String&gt;</p>
<p>异常：</p>
<ul>
<li>IllegalArgumentException - 列表元素有 '\0' 字符时，抛出异常。</li>
</ul>
<h3 id="initarrayx509certificate-privatekey"><a class="header" href="#initarrayx509certificate-privatekey">init(Array&lt;X509Certificate&gt;, PrivateKey)</a></h3>
<pre><code class="language-cangjie">public init(certChain: Array&lt;X509Certificate&gt;, certKey: PrivateKey)
</code></pre>
<p>功能：构造 <a href="net/tls/tls_package_api/tls_package_structs.html#struct-tlsserverconfig">TlsServerConfig</a> 对象。</p>
<p>参数：</p>
<ul>
<li>certChain: Array&lt;<a href="net/tls/tls_package_api/../../../crypto/x509/x509_package_api/x509_package_classes.html#class-x509certificate">X509Certificate</a>&gt; - 证书对象。</li>
<li>certKey: <a href="net/tls/tls_package_api/../../../crypto/x509/x509_package_api/x509_package_interfaces.html#interface-privatekey">PrivateKey</a> - 私钥对象。</li>
</ul>
<h2 id="struct-tlssession"><a class="header" href="#struct-tlssession">struct TlsSession</a></h2>
<pre><code class="language-cangjie">public struct TlsSession &lt;: Equatable&lt;TlsSession&gt; &amp; ToString &amp; Hashable
</code></pre>
<p>功能：此结构体表示已建立的客户端会话。此结构体实例用户不可创建，其内部结构对用户不可见。</p>
<p>当客户端 TLS 握手成功后，将会生成一个会话，当连接因一些原因丢失后，客户端可以通过这个会话 id 复用此次会话，省略握手流程。</p>
<p>父类型：</p>
<ul>
<li>Equatable&lt;<a href="net/tls/tls_package_api/tls_package_structs.html#struct-tlssession">TlsSession</a>&gt;</li>
<li>ToString</li>
<li>Hashable</li>
</ul>
<h3 id="func-hashcode-7"><a class="header" href="#func-hashcode-7">func hashCode()</a></h3>
<pre><code class="language-cangjie">public override func hashCode(): Int64
</code></pre>
<p>功能：生成会话 id 哈希值。</p>
<p>返回值：</p>
<ul>
<li>Int64 - 会话 id 哈希值。</li>
</ul>
<h3 id="func-tostring-40"><a class="header" href="#func-tostring-40">func toString()</a></h3>
<pre><code class="language-cangjie">public override func toString(): String
</code></pre>
<p>功能：生成会话 id 字符串。</p>
<p>返回值：</p>
<ul>
<li>String - <a href="net/tls/tls_package_api/tls_package_structs.html#struct-tlssession">TlsSession</a>(会话 id 字符串)。</li>
</ul>
<h3 id="operator-func-tlssession"><a class="header" href="#operator-func-tlssession">operator func !=(TlsSession)</a></h3>
<pre><code class="language-cangjie">public override operator func !=(other: TlsSession)
</code></pre>
<p>功能：判断会话 id 是否不同。</p>
<p>参数：</p>
<ul>
<li>other: <a href="net/tls/tls_package_api/tls_package_structs.html#struct-tlssession">TlsSession</a> - 被比较的会话对象。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Unit - 若会话对象不同，返回 <code>true</code>；否则，返回 <code>false</code>。</li>
</ul>
<h3 id="operator-func-tlssession-1"><a class="header" href="#operator-func-tlssession-1">operator func ==(TlsSession)</a></h3>
<pre><code class="language-cangjie">public override operator func ==(other: TlsSession)
</code></pre>
<p>功能：判断会话 id 是否相同。</p>
<p>参数：</p>
<ul>
<li>other: <a href="net/tls/tls_package_api/tls_package_structs.html#struct-tlssession">TlsSession</a> - 被比较的会话对象。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Unit - 若会话对象相同，返回 <code>true</code>；否则，返回 <code>false</code>。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="异常类-18"><a class="header" href="#异常类-18">异常类</a></h1>
<h2 id="class-tlsexception"><a class="header" href="#class-tlsexception">class TlsException</a></h2>
<pre><code class="language-cangjie">public class TlsException &lt;: Exception {
    public init()
    public init(message: String)
}
</code></pre>
<p>功能：TLS 处理出现错误时抛出的异常。</p>
<p>父类型：</p>
<ul>
<li>Exception</li>
</ul>
<h3 id="init-24"><a class="header" href="#init-24">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：创建 <a href="net/tls/tls_package_api/tls_package_exceptions.html#class-tlsexception">TlsException</a> 实例，异常提示消息为空。</p>
<h3 id="initstring-16"><a class="header" href="#initstring-16">init(String)</a></h3>
<pre><code class="language-cangjie">public init(message: String)
</code></pre>
<p>功能：根据异常信息创建 TlsException 实例。</p>
<p>参数：</p>
<ul>
<li>message: String - 异常信息。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="服务端证书及公钥在一份文件中"><a class="header" href="#服务端证书及公钥在一份文件中">服务端证书及公钥在一份文件中</a></h1>
<blockquote>
<p><strong>说明：</strong></p>
<p>需要自行准备证书文件。</p>
</blockquote>
<p>示例：</p>
<!-- compile -->
<pre><code class="language-cangjie">import std.io.*
import std.{fs.*, collection.*}
import stdx.net.tls.*
import stdx.crypto.x509.{X509Certificate, PrivateKey, Pem, PemEntry, DerBlob}

let certificatePath = &quot;/etc/myserver/cert-and-key.pem&quot;

func parsePem(text: String): (Array&lt;X509Certificate&gt;, PrivateKey) {
    let pem = Pem.decode(text)
    let chain = pem |&gt; filter&lt;PemEntry&gt; {entry =&gt; entry.label == PemEntry.LABEL_CERTIFICATE} |&gt;
        map&lt;PemEntry, X509Certificate&gt; {entry =&gt; X509Certificate.decodeFromDer(entry.body ?? DerBlob())} |&gt; collectArray

    let key = (pem |&gt; filter&lt;PemEntry&gt; {entry =&gt; entry.label == PemEntry.LABEL_PRIVATE_KEY} |&gt;
        map&lt;PemEntry, PrivateKey&gt; {entry =&gt; PrivateKey.decodeDer(entry.body ?? DerBlob())} |&gt; first) ?? throw Exception(
        &quot;No private key found in the PEM file&quot;)

    if (chain.isEmpty()) {
        throw Exception(&quot;No certificates found in the PEM file&quot;)
    }

    return (chain, key)
}

func readTextFromFile(path: String): String {
    var fileString = &quot;&quot;
    try (file = File(path, Read)) {
        fileString = String.fromUtf8(readToEnd(file))
        ()
    }
    fileString
}

main() {
    // 对证书及私钥进行解析
    let pem = readTextFromFile(certificatePath)

    let (certificate, privateKey) = parsePem(pem)

    var _ = TlsServerConfig(certificate, privateKey)

    // 进行 https 服务，请参阅其他服务器示例
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="客户端示例"><a class="header" href="#客户端示例">客户端示例</a></h1>
<p>示例：</p>
<!-- compile -->
<pre><code class="language-cangjie">import std.net.TcpSocket
import stdx.crypto.x509.{X509Certificate, PrivateKey}
import stdx.net.tls.*

main() {
    var config = TlsClientConfig()
    config.verifyMode = TrustAll
    config.alpnProtocolsList = [&quot;h2&quot;]

    // 用于恢复会话
    var lastSession: ?TlsSession = None
    // 重新连接环路
    while (true) {
        try (socket = TcpSocket(&quot;127.0.0.1&quot;, 8443)) {
            // 首先进行 TCP 连接
            socket.connect()
            try (tls = TlsSocket.client(socket, clientConfig: config, session: lastSession)) {
                try {
                    tls.handshake()
                    // 如果成功协商下一次重新连接，将记住会话
                    lastSession = tls.session
                } catch (e: Exception) {
                    // 如果协商失败，将删除会话
                    lastSession = None
                    throw e
                }
                // tls 实例已完成
                tls.write(&quot;Hello, peer! Let's discuss our personal secrets.\n&quot;.toArray())
            }
        } catch (e: Exception) {
            println(&quot;client connection failed ${e}, retrying...&quot;)
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="证书热更新"><a class="header" href="#证书热更新">证书热更新</a></h1>
<p>示例：</p>
<!-- run -->
<pre><code class="language-cangjie">import std.net.StreamingSocket
import stdx.crypto.x509.{X509Certificate, PrivateKey}
import stdx.net.tls.*

class MyServer {
    private var currentConfig: TlsServerConfig

    init(initialConfig: TlsServerConfig) {
        currentConfig = initialConfig
    }

    // 更改带有密钥的证书只会影响新的连接
    public mut prop certificate: (Array&lt;X509Certificate&gt;, PrivateKey) {
        get() {
            currentConfig.serverCertificate
        }
        set(newCertificate) {
            currentConfig.serverCertificate = newCertificate
        }
    }

    public func onAcceptedConnection(client: StreamingSocket) {
        try (tls = TlsSocket.server(client, serverConfig: currentConfig)) {
            tls.handshake()
        }
    }
}

main() {}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="服务端示例"><a class="header" href="#服务端示例">服务端示例</a></h1>
<blockquote>
<p><strong>说明：</strong></p>
<p>需要自行准备证书文件。</p>
</blockquote>
<p>示例：</p>
<!-- compile -->
<pre><code class="language-cangjie">import std.io.*
import std.fs.{File, OpenMode}
import std.net.{TcpServerSocket, TcpSocket}
import stdx.crypto.x509.{X509Certificate, PrivateKey}
import stdx.net.tls.*

// 证书及私钥路径，用户需自备
let certificatePath = &quot;./files/apiserver.crt&quot;
let certificateKeyPath = &quot;./files/apiserver.key&quot;

main() {
    // 对证书以及私钥进行解析
    let pem = readTextFromFile(certificatePath)
    let keyText = readTextFromFile(certificateKeyPath)

    let certificate = X509Certificate.decodeFromPem(pem)
    let privateKey = PrivateKey.decodeFromPem(keyText)

    let config = TlsServerConfig(certificate, privateKey)

    // 可选：允许恢复 TLS 会话
    let sessions = TlsSessionContext.fromName(&quot;my-server&quot;)

    try (server = TcpServerSocket(bindAt: 8443)) {
        server.bind()

        server.acceptLoop {
            clientSocket =&gt; try (tls = TlsSocket.server(clientSocket, serverConfig: config, sessionContext: sessions)) {
                tls.handshake()
                let buffer = Array&lt;Byte&gt;(100, repeat: 0)
                tls.read(buffer)
                println(buffer)
            }
        }
    }
}

extend TcpServerSocket {
    func acceptLoop(handler: (TcpSocket) -&gt; Unit) {
        while (true) {
            let client = accept()
            spawn {
                try {
                    handler(client)
                } finally {
                    client.close()
                }
            }
        }
    }
}

func readTextFromFile(path: String): String {
    var str = &quot;&quot;
    try (file = File(path, Read)) {
        str = String.fromUtf8(readToEnd(file))
    }
    str
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdxserializationserialization"><a class="header" href="#stdxserializationserialization">stdx.serialization.serialization</a></h1>
<h2 id="功能介绍-15"><a class="header" href="#功能介绍-15">功能介绍</a></h2>
<p>serialization 包提供了序列化和反序列化的能力。</p>
<p>序列化（serialization）是指将数据结构或对象状态转换成可取用格式（例如存成文件形式，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。相对地，从一系列字节提取数据结构的反向操作，即反序列化（deserialization）。</p>
<p>用户定义的类型，可以通过实现 <code>Serializable</code> 接口，来支持序列化和反序列化。</p>
<h2 id="api列表"><a class="header" href="#api列表">API列表</a></h2>
<h3 id="函数-8"><a class="header" href="#函数-8">函数</a></h3>
<div class="table-wrapper"><table><thead><tr><th>函数名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="serialization/./serialization_package_api/serialization_package_functions.html#func-fieldtstring-t-where-t--serializablet">field&lt;T&gt;(String, T)</a></td><td>用于将一组数据 <code>name</code> 和 <code>data</code> 封装到 <code>Field</code> 对象中。</td></tr>
</tbody></table>
</div>
<h3 id="接口-10"><a class="header" href="#接口-10">接口</a></h3>
<div class="table-wrapper"><table><thead><tr><th>接口名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="serialization/./serialization_package_api/serialization_package_interfaces.html">Serializable</a></td><td>用于规范序列化。</td></tr>
</tbody></table>
</div>
<h3 id="类-25"><a class="header" href="#类-25">类</a></h3>
<div class="table-wrapper"><table><thead><tr><th>类名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="serialization/./serialization_package_api/serialization_package_classes.html">DataModel</a></td><td>中间数据层。</td></tr>
<tr><td><a href="serialization/./serialization_package_api/serialization_package_classes.html">DataModelBool</a></td><td>此类为 <code>DataModel</code> 的子类，实现对 <code>Bool</code> 类型数据的封装。</td></tr>
<tr><td><a href="serialization/./serialization_package_api/serialization_package_classes.html">DataModelFloat</a></td><td>此类为 <code>DataModel</code> 的子类，实现对 <code>Float64</code> 类型数据的封装。</td></tr>
<tr><td><a href="serialization/./serialization_package_api/serialization_package_classes.html">DataModelInt</a></td><td>此类为 <code>DataModel</code> 的子类，实现对 <code>Int64</code> 类型数据的封装。</td></tr>
<tr><td><a href="serialization/./serialization_package_api/serialization_package_classes.html">DataModelNull</a></td><td>此类为 <code>DataModel</code> 的子类，实现对 <code>Null</code> 类型数据的封装。</td></tr>
<tr><td><a href="serialization/./serialization_package_api/serialization_package_classes.html">DataModelSeq</a></td><td>此类为 <code>DataModel</code> 的子类，实现对 ArrayList&lt;DataModel&gt; 类型数据的封装。</td></tr>
<tr><td><a href="serialization/./serialization_package_api/serialization_package_classes.html">DataModelString</a></td><td>此类为 <code>DataModel</code> 的子类，实现对 <code>String</code> 类型数据的封装。</td></tr>
<tr><td><a href="serialization/./serialization_package_api/serialization_package_classes.html">DataModelStruct</a></td><td>此类为 <code>DataModel</code> 的子类，用来实现 <code>class</code> 对象到 <code>DataModel</code> 的转换。</td></tr>
<tr><td><a href="serialization/./serialization_package_api/serialization_package_classes.html">Field</a></td><td>用于存储 <code>DataModelStruct</code> 的元素。</td></tr>
</tbody></table>
</div>
<h3 id="异常类-19"><a class="header" href="#异常类-19">异常类</a></h3>
<div class="table-wrapper"><table><thead><tr><th>异常类名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="serialization/./serialization_package_api/serialization_package_exceptions.html">DataModelException</a></td><td><code>DataModel</code> 的异常类。</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="函数-9"><a class="header" href="#函数-9">函数</a></h1>
<h2 id="func-fieldtstring-t-where-t--serializablet"><a class="header" href="#func-fieldtstring-t-where-t--serializablet">func field&lt;T&gt;(String, T) where T &lt;: Serializable&lt;T&gt;</a></h2>
<pre><code class="language-cangjie">public func field&lt;T&gt;(name: String, data: T) : Field where T &lt;: Serializable&lt;T&gt;
</code></pre>
<p>功能：此函数用于将一组数据 <code>name</code> 和 <code>data</code> 封装到 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-field">Field</a> 对象中。处理一组数据 <code>name</code> 和 <code>data</code>，将 <code>data</code> 序列化为 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> 类型，并将二者封装到 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-field">Field</a> 对象中。</p>
<p>参数：</p>
<ul>
<li>name: String - String 类型，<code>name</code> 字段为 <code>&quot;&quot;</code> 时行为与为其它字符串时一致。</li>
<li>data: T - <code>T</code> 类型，<code>T</code> 类型必须实现 <a href="serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a>&lt;T&gt; 接口。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_classes.html#class-field">Field</a> - 封装了 <code>name</code> 和 <code>data</code> 的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-field">Field</a> 对象。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="接口-11"><a class="header" href="#接口-11">接口</a></h1>
<h2 id="interface-serializable"><a class="header" href="#interface-serializable">interface Serializable</a></h2>
<pre><code class="language-cangjie">public interface Serializable&lt;T&gt; {
    func serialize(): DataModel
    static func deserialize(dm: DataModel): T
}
</code></pre>
<p>功能：用于规范序列化。</p>
<h3 id="static-func-deserializedatamodel"><a class="header" href="#static-func-deserializedatamodel">static func deserialize(DataModel)</a></h3>
<pre><code class="language-cangjie">static func deserialize(dm: DataModel): T
</code></pre>
<p>功能：将 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> 反序列化为对象。</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>支持实现 <a href="serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a> 的类型包括:</p>
<ul>
<li>基本数据类型：整数类型、浮点类型、布尔类型、字符类型、字符串类型。</li>
<li>Collection 类型：Array、ArrayList、HashSet、HashMap、Option。</li>
<li>用户自定义的实现了 <a href="serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a>&lt;T&gt; 的类型。</li>
</ul>
</blockquote>
<p>参数：</p>
<ul>
<li>dm: <a href="serialization/serialization_package_api/./serialization_package_classes.html#class-datamodel">DataModel</a> - 待反序列化的数据。</li>
</ul>
<p>返回值：</p>
<ul>
<li>T - 反序列化的对象。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_exceptions.html#class-datamodelexception">DataModelException</a> - 当 <code>dm</code> 的类型不支持反序列化到 T 类型时，抛出异常。</li>
</ul>
<h3 id="func-serialize"><a class="header" href="#func-serialize">func serialize()</a></h3>
<pre><code class="language-cangjie">func serialize(): DataModel
</code></pre>
<p>功能：将自身序列化为 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a>。</p>
<p>返回值：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 序列化的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a>。</li>
</ul>
<h3 id="extendt-arrayt--serializablearrayt-where-t--serializablet"><a class="header" href="#extendt-arrayt--serializablearrayt-where-t--serializablet">extend&lt;T&gt; Array&lt;T&gt; &lt;: Serializable&lt;Array&lt;T&gt;&gt; where T &lt;: Serializable&lt;T&gt;</a></h3>
<pre><code class="language-cangjie">extend&lt;T&gt; Array&lt;T&gt; &lt;: Serializable&lt;Array&lt;T&gt;&gt; where T &lt;: Serializable&lt;T&gt;
</code></pre>
<p>功能：为 Array&lt;T&gt; 类型实现 <a href="serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a>&lt;Array&lt;T&gt;&gt; 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a>&lt;Array&lt;T&gt;&gt;</li>
</ul>
<h4 id="static-func-deserializedatamodel-1"><a class="header" href="#static-func-deserializedatamodel-1">static func deserialize(DataModel)</a></h4>
<pre><code class="language-cangjie">static public func deserialize(dm: DataModel): Array&lt;T&gt;
</code></pre>
<p>功能：将 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> 反序列化为 Array&lt;T&gt;。</p>
<p>参数：</p>
<ul>
<li>dm: <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 需要被反序列化的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a>。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Array&lt;T&gt; - 反序列化后的 Array&lt;T&gt;。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_exceptions.html#class-datamodelexception">DataModelException</a> - 当 <code>dm</code> 的类型不是 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelseq">DataModelSeq</a> 时，则抛出异常。</li>
</ul>
<h4 id="func-serialize-1"><a class="header" href="#func-serialize-1">func serialize()</a></h4>
<pre><code class="language-cangjie">public func serialize(): DataModel
</code></pre>
<p>功能：将 Array&lt;T&gt; 序列化为 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelseq">DataModelSeq</a>。</p>
<p>返回值：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 序列化的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelseq">DataModelSeq</a>。</li>
</ul>
<h3 id="extendt-arraylistt--serializablearraylistt-where-t--serializablet"><a class="header" href="#extendt-arraylistt--serializablearraylistt-where-t--serializablet">extend&lt;T&gt; ArrayList&lt;T&gt; &lt;: Serializable&lt;ArrayList&lt;T&gt;&gt; where T &lt;: Serializable&lt;T&gt;</a></h3>
<pre><code class="language-cangjie">extend&lt;T&gt; ArrayList&lt;T&gt; &lt;: Serializable&lt;ArrayList&lt;T&gt;&gt; where T &lt;: Serializable&lt;T&gt;
</code></pre>
<p>功能：为 ArrayList&lt;T&gt; 类型实现 <a href="serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a>&lt;ArrayList&lt;T&gt;&gt; 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a>&lt;ArrayList&lt;T&gt;&gt;</li>
</ul>
<h4 id="static-func-deserializedatamodel-2"><a class="header" href="#static-func-deserializedatamodel-2">static func deserialize(DataModel)</a></h4>
<pre><code class="language-cangjie">static public func deserialize(dm: DataModel): ArrayList&lt;T&gt;
</code></pre>
<p>功能：将 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> 反序列化为 ArrayList&lt;T&gt;。</p>
<p>参数：</p>
<ul>
<li>dm: <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 需要被反序列化的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a>。</li>
</ul>
<p>返回值：</p>
<ul>
<li>ArrayList&lt;T&gt; - 反序列化后的 ArrayList&lt;T&gt;。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_exceptions.html#class-datamodelexception">DataModelException</a> - 当 <code>dm</code> 的类型不是 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelseq">DataModelSeq</a> 时，抛出异常。</li>
</ul>
<h4 id="func-serialize-2"><a class="header" href="#func-serialize-2">func serialize()</a></h4>
<pre><code class="language-cangjie">public func serialize(): DataModel
</code></pre>
<p>功能：将 ArrayList&lt;T&gt; 序列化为 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelseq">DataModelSeq</a>。</p>
<p>返回值：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 序列化的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelseq">DataModelSeq</a>。</li>
</ul>
<h3 id="extend-bool--serializable"><a class="header" href="#extend-bool--serializable">extend Bool &lt;: Serializable</a></h3>
<pre><code class="language-cangjie">extend Bool &lt;: Serializable&lt;Bool&gt;
</code></pre>
<p>功能：为 Bool 类型实现 <a href="serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a> 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a>&lt;Bool&gt;</li>
</ul>
<h4 id="static-func-deserializedatamodel-3"><a class="header" href="#static-func-deserializedatamodel-3">static func deserialize(DataModel)</a></h4>
<pre><code class="language-cangjie">static public func deserialize(dm: DataModel): Bool
</code></pre>
<p>功能：将 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> 反序列化为 Bool。</p>
<p>参数：</p>
<ul>
<li>dm: <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 需要被反序列化的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a>。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Bool - 反序列化后的 Bool。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_exceptions.html#class-datamodelexception">DataModelException</a> - 当 <code>dm</code> 的类型不是 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelbool">DataModelBool</a> 时，抛出异常。</li>
</ul>
<h4 id="func-serialize-3"><a class="header" href="#func-serialize-3">func serialize()</a></h4>
<pre><code class="language-cangjie">public func serialize(): DataModel
</code></pre>
<p>功能：将 Bool 序列化为 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelbool">DataModelBool</a>。</p>
<p>返回值：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 序列化的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelbool">DataModelBool</a>。</li>
</ul>
<h3 id="extend-float16--serializable"><a class="header" href="#extend-float16--serializable">extend Float16 &lt;: Serializable</a></h3>
<pre><code class="language-cangjie">extend Float16 &lt;: Serializable&lt;Float16&gt;
</code></pre>
<p>功能：为 Float16 类型实现 <a href="serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a> 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a>&lt;Float16&gt;</li>
</ul>
<h4 id="static-func-deserializedatamodel-4"><a class="header" href="#static-func-deserializedatamodel-4">static func deserialize(DataModel)</a></h4>
<pre><code class="language-cangjie">static public func deserialize(dm: DataModel): Float16
</code></pre>
<p>功能：将 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> 反序列化为 Float16。</p>
<p>参数：</p>
<ul>
<li>dm: <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 需要被反序列化的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a>。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Float16 - 反序列化后的 Float16。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_exceptions.html#class-datamodelexception">DataModelException</a> - 当 <code>dm</code> 的类型不是 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelfloat">DataModelFloat</a> 或者 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelint">DataModelInt</a> 时，抛出异常。</li>
</ul>
<h4 id="func-serialize-4"><a class="header" href="#func-serialize-4">func serialize()</a></h4>
<pre><code class="language-cangjie">public func serialize(): DataModel
</code></pre>
<p>功能：将 Float16 序列化为 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelfloat">DataModelFloat</a>。</p>
<p>返回值：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 序列化的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelfloat">DataModelFloat</a>。</li>
</ul>
<h3 id="extend-float32--serializable"><a class="header" href="#extend-float32--serializable">extend Float32 &lt;: Serializable</a></h3>
<pre><code class="language-cangjie">extend Float32 &lt;: Serializable&lt;Float32&gt;
</code></pre>
<p>功能：为 Float32 类型实现 <a href="serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a> 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a>&lt;Float32&gt;</li>
</ul>
<h4 id="static-func-deserializedatamodel-5"><a class="header" href="#static-func-deserializedatamodel-5">static func deserialize(DataModel)</a></h4>
<pre><code class="language-cangjie">static public func deserialize(dm: DataModel): Float32
</code></pre>
<p>功能：将 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> 反序列化为 Float32。</p>
<p>参数：</p>
<ul>
<li>dm: <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 需要被反序列化的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a>。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Float32 - 反序列化后的 Float32。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_exceptions.html#class-datamodelexception">DataModelException</a> - 当 <code>dm</code> 的类型不是 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelfloat">DataModelFloat</a> 或者 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelint">DataModelInt</a> 时，抛出异常。</li>
</ul>
<h4 id="func-serialize-5"><a class="header" href="#func-serialize-5">func serialize()</a></h4>
<pre><code class="language-cangjie">public func serialize(): DataModel
</code></pre>
<p>功能：将 Float32 序列化为 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelfloat">DataModelFloat</a>。</p>
<p>返回值：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 序列化的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelfloat">DataModelFloat</a>。</li>
</ul>
<h3 id="extend-float64--serializable"><a class="header" href="#extend-float64--serializable">extend Float64 &lt;: Serializable</a></h3>
<pre><code class="language-cangjie">extend Float64 &lt;: Serializable&lt;Float64&gt;
</code></pre>
<p>功能：为 Float64 类型实现 <a href="serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a> 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a>&lt;Float64&gt;</li>
</ul>
<h4 id="static-func-deserializedatamodel-6"><a class="header" href="#static-func-deserializedatamodel-6">static func deserialize(DataModel)</a></h4>
<pre><code class="language-cangjie">static public func deserialize(dm: DataModel): Float64
</code></pre>
<p>功能：将 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> 反序列化为 Float64。</p>
<p>参数：</p>
<ul>
<li>dm: <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 需要被反序列化的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a>。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Float64 - 反序列化后的 Float64。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_exceptions.html#class-datamodelexception">DataModelException</a> - 当 <code>dm</code> 的类型不是 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelfloat">DataModelFloat</a> 或者 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelint">DataModelInt</a> 时，抛出异常。</li>
</ul>
<h4 id="func-serialize-6"><a class="header" href="#func-serialize-6">func serialize()</a></h4>
<pre><code class="language-cangjie">public func serialize(): DataModel
</code></pre>
<p>功能：将 Float64 序列化为 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelfloat">DataModelFloat</a>。</p>
<p>返回值：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 序列化的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelfloat">DataModelFloat</a>。</li>
</ul>
<h3 id="extendk-v-hashmapk-v--serializablehashmapk-v-where-k--serializablek--hashable--equatablek-v--serializablev"><a class="header" href="#extendk-v-hashmapk-v--serializablehashmapk-v-where-k--serializablek--hashable--equatablek-v--serializablev">extend&lt;K, V&gt; HashMap&lt;K, V&gt; &lt;: Serializable&lt;HashMap&lt;K, V&gt;&gt; where K &lt;: Serializable&lt;K&gt; &amp; Hashable &amp; Equatable&lt;K&gt;, V &lt;: Serializable&lt;V&gt;</a></h3>
<pre><code class="language-cangjie">extend&lt;K, V&gt; HashMap&lt;K, V&gt; &lt;: Serializable&lt;HashMap&lt;K, V&gt;&gt; where K &lt;: Serializable&lt;K&gt; &amp; Hashable &amp; Equatable&lt;K&gt;, V &lt;: Serializable&lt;V&gt;
</code></pre>
<p>功能：为 HashMap&lt;K, V&gt; 类型实现 <a href="serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a>&lt;HashMap&lt;K, V&gt;&gt; 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a>&lt;HashMap&lt;K, V&gt;&gt;</li>
</ul>
<h4 id="static-func-deserializedatamodel-7"><a class="header" href="#static-func-deserializedatamodel-7">static func deserialize(DataModel)</a></h4>
<pre><code class="language-cangjie">static public func deserialize(dm: DataModel): HashMap&lt;K, V&gt;
</code></pre>
<p>功能：将 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> 反序列化为 HashMap&lt;K, V&gt;。</p>
<p>参数：</p>
<ul>
<li>dm: <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 需要被反序列化的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a>。</li>
</ul>
<p>返回值：</p>
<ul>
<li>HashMap&lt;K, V&gt; - 反序列化后的 HashMap&lt;K, V&gt;。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_exceptions.html#class-datamodelexception">DataModelException</a> - 当 <code>dm</code> 不是 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelstruct">DataModelStruct</a> 类型，或者 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelstruct">DataModelStruct</a> 类型的 <code>dm</code> 中的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-field">Field</a> 不是 String 类型时，抛出异常。</li>
</ul>
<h4 id="func-serialize-7"><a class="header" href="#func-serialize-7">func serialize()</a></h4>
<pre><code class="language-cangjie">public func serialize(): DataModel
</code></pre>
<p>功能：将 HashMap&lt;K, V&gt; 序列化为 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelseq">DataModelSeq</a>。</p>
<p>返回值：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 序列化的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelseq">DataModelSeq</a>。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_exceptions.html#class-datamodelexception">DataModelException</a> - 当前 HashMap 实例中的 Key 不是 String 类型时，抛出异常。</li>
</ul>
<h3 id="extendt-hashsett--serializablehashsett-where-t--serializablet--hashable--equatablet"><a class="header" href="#extendt-hashsett--serializablehashsett-where-t--serializablet--hashable--equatablet">extend&lt;T&gt; HashSet&lt;T&gt; &lt;: Serializable&lt;HashSet&lt;T&gt;&gt; where T &lt;: Serializable&lt;T&gt; &amp; Hashable &amp; Equatable&lt;T&gt;</a></h3>
<pre><code class="language-cangjie">extend&lt;T&gt; HashSet&lt;T&gt; &lt;: Serializable&lt;HashSet&lt;T&gt;&gt; where T &lt;: Serializable&lt;T&gt; &amp; Hashable &amp; Equatable&lt;T&gt;
</code></pre>
<p>功能：为 HashSet&lt;T&gt; 类型实现 <a href="serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a>&lt;HashSet&lt;T&gt;&gt; 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a>&lt;HashSet&lt;T&gt;&gt;</li>
</ul>
<h4 id="static-func-deserializedatamodel-8"><a class="header" href="#static-func-deserializedatamodel-8">static func deserialize(DataModel)</a></h4>
<pre><code class="language-cangjie">static public func deserialize(dm: DataModel): HashSet&lt;T&gt;
</code></pre>
<p>功能：将 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> 反序列化为 HashSet&lt;T&gt;。</p>
<p>参数：</p>
<ul>
<li>dm: <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 需要被反序列化的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a>。</li>
</ul>
<p>返回值：</p>
<ul>
<li>HashSet&lt;T&gt; - 反序列化后的 HashSet&lt;T&gt;。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_exceptions.html#class-datamodelexception">DataModelException</a> - 当 <code>dm</code> 的类型不是 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelseq">DataModelSeq</a> 时，抛出异常。</li>
</ul>
<h4 id="func-serialize-8"><a class="header" href="#func-serialize-8">func serialize()</a></h4>
<pre><code class="language-cangjie">public func serialize(): DataModel
</code></pre>
<p>功能：将 HashSet&lt;T&gt; 序列化为 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelseq">DataModelSeq</a>。</p>
<p>返回值：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 序列化的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelseq">DataModelSeq</a>。</li>
</ul>
<h3 id="extend-int16--serializable"><a class="header" href="#extend-int16--serializable">extend Int16 &lt;: Serializable</a></h3>
<pre><code class="language-cangjie">extend Int16 &lt;: Serializable&lt;Int16&gt;
</code></pre>
<p>功能：为 Int16 类型实现 <a href="serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a> 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a>&lt;Int16&gt;</li>
</ul>
<h4 id="static-func-deserializedatamodel-9"><a class="header" href="#static-func-deserializedatamodel-9">static func deserialize(DataModel)</a></h4>
<pre><code class="language-cangjie">static public func deserialize(dm: DataModel): Int16
</code></pre>
<p>功能：将 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> 反序列化为 Int16。</p>
<p>参数：</p>
<ul>
<li>dm: <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 需要被反序列化的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a>。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Int16 - 反序列化后的 Int16。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_exceptions.html#class-datamodelexception">DataModelException</a> - 当 <code>dm</code> 的类型不是 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelint">DataModelInt</a> 时，则抛出异常。</li>
</ul>
<h4 id="func-serialize-9"><a class="header" href="#func-serialize-9">func serialize()</a></h4>
<pre><code class="language-cangjie">public func serialize(): DataModel
</code></pre>
<p>功能：将 Int16 序列化为 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelint">DataModelInt</a>。</p>
<p>返回值：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 序列化的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelint">DataModelInt</a>。</li>
</ul>
<h3 id="extend-int32--serializable"><a class="header" href="#extend-int32--serializable">extend Int32 &lt;: Serializable</a></h3>
<pre><code class="language-cangjie">extend Int32 &lt;: Serializable&lt;Int32&gt;
</code></pre>
<p>功能：为 Int32 类型实现 <a href="serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a> 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a>&lt;Int32&gt;</li>
</ul>
<h4 id="static-func-deserializedatamodel-10"><a class="header" href="#static-func-deserializedatamodel-10">static func deserialize(DataModel)</a></h4>
<pre><code class="language-cangjie">static public func deserialize(dm: DataModel): Int32
</code></pre>
<p>功能：将 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> 反序列化为 Int32。</p>
<p>参数：</p>
<ul>
<li>dm: <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 需要被反序列化的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a>。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Int32 - 反序列化后的 Int32。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_exceptions.html#class-datamodelexception">DataModelException</a> - 当 <code>dm</code> 的类型不是 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelint">DataModelInt</a> 时，抛出异常</li>
</ul>
<h4 id="func-serialize-10"><a class="header" href="#func-serialize-10">func serialize()</a></h4>
<pre><code class="language-cangjie">public func serialize(): DataModel
</code></pre>
<p>功能：将 Int32 序列化为 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelint">DataModelInt</a>。</p>
<p>返回值：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 序列化的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelint">DataModelInt</a>。</li>
</ul>
<h3 id="extend-int64--serializable"><a class="header" href="#extend-int64--serializable">extend Int64 &lt;: Serializable</a></h3>
<pre><code class="language-cangjie">extend Int64 &lt;: Serializable&lt;Int64&gt;
</code></pre>
<p>功能：为 Int64 类型实现 <a href="serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a> 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a>&lt;Int64&gt;</li>
</ul>
<h4 id="static-func-deserializedatamodel-11"><a class="header" href="#static-func-deserializedatamodel-11">static func deserialize(DataModel)</a></h4>
<pre><code class="language-cangjie">static public func deserialize(dm: DataModel): Int64
</code></pre>
<p>功能：将 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> 反序列化为 Int64。</p>
<p>参数：</p>
<ul>
<li>dm: <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 需要被反序列化的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a>。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Int64 - 反序列化后的 Int64。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_exceptions.html#class-datamodelexception">DataModelException</a> - 当 <code>dm</code> 的类型不是 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelint">DataModelInt</a> 时，抛出异常。</li>
</ul>
<h4 id="func-serialize-11"><a class="header" href="#func-serialize-11">func serialize()</a></h4>
<pre><code class="language-cangjie">public func serialize(): DataModel
</code></pre>
<p>功能：将 Int64 序列化为 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelint">DataModelInt</a>。</p>
<p>返回值：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 序列化的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelint">DataModelInt</a>。</li>
</ul>
<h3 id="extend-int8--serializable"><a class="header" href="#extend-int8--serializable">extend Int8 &lt;: Serializable</a></h3>
<pre><code class="language-cangjie">extend Int8 &lt;: Serializable&lt;Int8&gt;
</code></pre>
<p>功能：为 Int8 类型实现 <a href="serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a> 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a>&lt;Int8&gt;</li>
</ul>
<h4 id="static-func-deserializedatamodel-12"><a class="header" href="#static-func-deserializedatamodel-12">static func deserialize(DataModel)</a></h4>
<pre><code class="language-cangjie">static public func deserialize(dm: DataModel): Int8
</code></pre>
<p>功能：将 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> 反序列化为 Int8。</p>
<p>参数：</p>
<ul>
<li>dm: <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 需要被反序列化的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a>。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Int8 - 反序列化后的 Int8。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_exceptions.html#class-datamodelexception">DataModelException</a> - 当 <code>dm</code> 的类型不是 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelint">DataModelInt</a> 时，抛出异常。</li>
</ul>
<h4 id="func-serialize-12"><a class="header" href="#func-serialize-12">func serialize()</a></h4>
<pre><code class="language-cangjie">public func serialize(): DataModel
</code></pre>
<p>功能：将 Int8 序列化为 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelint">DataModelInt</a>。</p>
<p>返回值：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 序列化的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelint">DataModelInt</a>。</li>
</ul>
<h3 id="extendt-optiont--serializableoptiont-where-t--serializablet"><a class="header" href="#extendt-optiont--serializableoptiont-where-t--serializablet">extend&lt;T&gt; Option&lt;T&gt; &lt;: Serializable&lt;Option&lt;T&gt;&gt; where T &lt;: Serializable&lt;T&gt;</a></h3>
<pre><code class="language-cangjie">extend&lt;T&gt; Option&lt;T&gt; &lt;: Serializable&lt;Option&lt;T&gt;&gt; where T &lt;: Serializable&lt;T&gt;
</code></pre>
<p>功能：为 Option&lt;T&gt; 类型实现 <a href="serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a>&lt;Option&lt;T&gt;&gt; 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a>&lt;Option&lt;T&gt;&gt;</li>
</ul>
<h4 id="static-func-deserializedatamodel-13"><a class="header" href="#static-func-deserializedatamodel-13">static func deserialize(DataModel)</a></h4>
<pre><code class="language-cangjie">static public func deserialize(dm: DataModel): Option&lt;T&gt;
</code></pre>
<p>功能：将 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> 反序列化为 Option&lt;T&gt;。</p>
<p>参数：</p>
<ul>
<li>dm: <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 需要被反序列化的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a>。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Option&lt;T&gt; - 反序列化后的 Option&lt;T&gt;。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_exceptions.html#class-datamodelexception">DataModelException</a> - 当 <code>dm</code> 的类型不支持反序列化到 T 类型时，抛出异常。</li>
</ul>
<h4 id="func-serialize-13"><a class="header" href="#func-serialize-13">func serialize()</a></h4>
<pre><code class="language-cangjie">public func serialize(): DataModel
</code></pre>
<p>功能：将 Option&lt;T&gt; 中的 <code>T</code> 序列化为 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a>。</p>
<p>返回值：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 序列化的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a>。</li>
</ul>
<h3 id="extend-rune--serializable"><a class="header" href="#extend-rune--serializable">extend Rune &lt;: Serializable</a></h3>
<pre><code class="language-cangjie">extend Rune &lt;: Serializable&lt;Rune&gt;
</code></pre>
<p>功能：为 Rune 类型实现 <a href="serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a> 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a>&lt;Rune&gt;</li>
</ul>
<h4 id="static-func-deserializedatamodel-14"><a class="header" href="#static-func-deserializedatamodel-14">static func deserialize(DataModel)</a></h4>
<pre><code class="language-cangjie">static public func deserialize(dm: DataModel): Rune
</code></pre>
<p>功能：将 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> 反序列化为 Rune。</p>
<p>参数：</p>
<ul>
<li>dm: <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 需要被反序列化的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a>。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Rune - 反序列化后的字符。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_exceptions.html#class-datamodelexception">DataModelException</a> - 当 <code>dm</code> 的类型不是 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelstring">DataModelString</a> 时，则抛出此异常。</li>
<li>Exception - 当 <code>dm</code> 的类型不是 Rune 时，则抛出此异常。</li>
</ul>
<h4 id="func-serialize-14"><a class="header" href="#func-serialize-14">func serialize()</a></h4>
<pre><code class="language-cangjie">public func serialize(): DataModel
</code></pre>
<p>功能：将 Rune 序列化为 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelstring">DataModelString</a>。</p>
<p>返回值：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 序列化的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelstring">DataModelString</a>。</li>
</ul>
<h3 id="extend-string--serializable"><a class="header" href="#extend-string--serializable">extend String &lt;: Serializable</a></h3>
<pre><code class="language-cangjie">extend String &lt;: Serializable&lt;String&gt;
</code></pre>
<p>功能：为 String 类型实现 <a href="serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a> 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a>&lt;String&gt;</li>
</ul>
<h4 id="static-func-deserializedatamodel-15"><a class="header" href="#static-func-deserializedatamodel-15">static func deserialize(DataModel)</a></h4>
<pre><code class="language-cangjie">static public func deserialize(dm: DataModel): String
</code></pre>
<p>功能：将 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> 反序列化为 String。</p>
<p>参数：</p>
<ul>
<li>dm: <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 需要被反序列化的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a>。</li>
</ul>
<p>返回值：</p>
<ul>
<li>String - 反序列化后的 String。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_exceptions.html#class-datamodelexception">DataModelException</a> - 当 <code>dm</code> 的类型不是 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelstring">DataModelString</a> 时，则抛出异常。</li>
</ul>
<h4 id="func-serialize-15"><a class="header" href="#func-serialize-15">func serialize()</a></h4>
<pre><code class="language-cangjie">public func serialize(): DataModel
</code></pre>
<p>功能：将 String 序列化为 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelstring">DataModelString</a>。</p>
<p>返回值：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 序列化的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelstring">DataModelString</a>。</li>
</ul>
<h3 id="extend-uint16--serializable"><a class="header" href="#extend-uint16--serializable">extend UInt16 &lt;: Serializable</a></h3>
<pre><code class="language-cangjie">extend UInt16 &lt;: Serializable&lt;UInt16&gt;
</code></pre>
<p>功能：为 UInt16 类型实现 <a href="serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a> 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a>&lt;UInt16&gt;</li>
</ul>
<h4 id="static-func-deserializedatamodel-16"><a class="header" href="#static-func-deserializedatamodel-16">static func deserialize(DataModel)</a></h4>
<pre><code class="language-cangjie">static public func deserialize(dm: DataModel): UInt16
</code></pre>
<p>功能：将 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> 反序列化为 UInt16。</p>
<p>参数：</p>
<ul>
<li>dm: <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 需要被反序列化的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a>。</li>
</ul>
<p>返回值：</p>
<ul>
<li>UInt16 - 反序列化后的 UInt16。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_exceptions.html#class-datamodelexception">DataModelException</a> - 当 <code>dm</code> 的类型不是 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelint">DataModelInt</a> 时，则抛出异常。</li>
</ul>
<h4 id="func-serialize-16"><a class="header" href="#func-serialize-16">func serialize()</a></h4>
<pre><code class="language-cangjie">public func serialize(): DataModel
</code></pre>
<p>功能：将 UInt16 序列化为 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelint">DataModelInt</a>。</p>
<p>返回值：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 序列化的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelint">DataModelInt</a>。</li>
</ul>
<h3 id="extend-uint32--serializable"><a class="header" href="#extend-uint32--serializable">extend UInt32 &lt;: Serializable</a></h3>
<pre><code class="language-cangjie">extend UInt32 &lt;: Serializable&lt;UInt32&gt;
</code></pre>
<p>功能：为 UInt32 类型实现 <a href="serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a> 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a>&lt;UInt32&gt;</li>
</ul>
<h4 id="static-func-deserializedatamodel-17"><a class="header" href="#static-func-deserializedatamodel-17">static func deserialize(DataModel)</a></h4>
<pre><code class="language-cangjie">static public func deserialize(dm: DataModel): UInt32
</code></pre>
<p>功能：将 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> 反序列化为 UInt32。</p>
<p>参数：</p>
<ul>
<li>dm: <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 需要被反序列化的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a>。</li>
</ul>
<p>返回值：</p>
<ul>
<li>UInt32 - 反序列化后的 UInt32。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_exceptions.html#class-datamodelexception">DataModelException</a> - 当 <code>dm</code> 的类型不是 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelint">DataModelInt</a> 时，则抛出异常。</li>
</ul>
<h4 id="func-serialize-17"><a class="header" href="#func-serialize-17">func serialize()</a></h4>
<pre><code class="language-cangjie">public func serialize(): DataModel
</code></pre>
<p>功能：将 UInt32 序列化为 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelint">DataModelInt</a>。</p>
<p>返回值：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 序列化的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelint">DataModelInt</a>。</li>
</ul>
<h3 id="extend-uint64--serializable"><a class="header" href="#extend-uint64--serializable">extend UInt64 &lt;: Serializable</a></h3>
<pre><code class="language-cangjie">extend UInt64 &lt;: Serializable&lt;UInt64&gt;
</code></pre>
<p>功能：为 UInt64 类型实现 <a href="serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a> 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a>&lt;UInt64&gt;</li>
</ul>
<h4 id="static-func-deserializedatamodel-18"><a class="header" href="#static-func-deserializedatamodel-18">static func deserialize(DataModel)</a></h4>
<pre><code class="language-cangjie">static public func deserialize(dm: DataModel): UInt64
</code></pre>
<p>功能：将 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> 反序列化为 UInt64。</p>
<p>参数：</p>
<ul>
<li>dm: <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 需要被反序列化的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a>。</li>
</ul>
<p>返回值：</p>
<ul>
<li>UInt64 - 反序列化后的 UInt64。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_exceptions.html#class-datamodelexception">DataModelException</a> - 当 <code>dm</code> 的类型不是 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelint">DataModelInt</a> 时，则抛出异常。</li>
</ul>
<h4 id="func-serialize-18"><a class="header" href="#func-serialize-18">func serialize()</a></h4>
<pre><code class="language-cangjie">public func serialize(): DataModel
</code></pre>
<p>功能：将 UInt64 序列化为 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelint">DataModelInt</a>。</p>
<p>返回值：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 序列化的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelint">DataModelInt</a>。</li>
</ul>
<h3 id="extend-uint8--serializable"><a class="header" href="#extend-uint8--serializable">extend UInt8 &lt;: Serializable</a></h3>
<pre><code class="language-cangjie">extend UInt8 &lt;: Serializable&lt;UInt8&gt;
</code></pre>
<p>功能：为 UInt8 类型实现 <a href="serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a> 接口。</p>
<p>父类型：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a>&lt;UInt8&gt;</li>
</ul>
<h4 id="static-func-deserializedatamodel-19"><a class="header" href="#static-func-deserializedatamodel-19">static func deserialize(DataModel)</a></h4>
<pre><code class="language-cangjie">static public func deserialize(dm: DataModel): UInt8
</code></pre>
<p>功能：将 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> 反序列化为 UInt8。</p>
<p>参数：</p>
<ul>
<li>dm: <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 需要被反序列化的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a>。</li>
</ul>
<p>返回值：</p>
<ul>
<li>UInt8 - 反序列化后的 UInt8。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_exceptions.html#class-datamodelexception">DataModelException</a> - 当 <code>dm</code> 的类型不是 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelint">DataModelInt</a> 时，则抛出异常。</li>
</ul>
<h4 id="func-serialize-19"><a class="header" href="#func-serialize-19">func serialize()</a></h4>
<pre><code class="language-cangjie">public func serialize(): DataModel
</code></pre>
<p>功能：将 UInt8 序列化为 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelint">DataModelInt</a>。</p>
<p>返回值：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 序列化的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelint">DataModelInt</a>。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类-26"><a class="header" href="#类-26">类</a></h1>
<h2 id="class-datamodel"><a class="header" href="#class-datamodel">class DataModel</a></h2>
<pre><code class="language-cangjie">public abstract class DataModel
</code></pre>
<p>功能：此类为中间数据层。</p>
<h2 id="class-datamodelbool"><a class="header" href="#class-datamodelbool">class DataModelBool</a></h2>
<pre><code class="language-cangjie">public class DataModelBool &lt;: DataModel {
    public init(bv: Bool)
}
</code></pre>
<p>功能：此类为 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> 的子类，实现对 Bool 类型数据的封装。</p>
<p>父类型：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a></li>
</ul>
<h3 id="initbool-2"><a class="header" href="#initbool-2">init(Bool)</a></h3>
<pre><code class="language-cangjie">public init(bv: Bool)
</code></pre>
<p>功能：构造一个具有初始数据的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelbool">DataModelBool</a> 实例。</p>
<p>参数：</p>
<ul>
<li>bv: Bool - 传入的 Bool 类型的数据。</li>
</ul>
<h3 id="func-getvalue-4"><a class="header" href="#func-getvalue-4">func getValue()</a></h3>
<pre><code class="language-cangjie">public func getValue(): Bool
</code></pre>
<p>功能：获取 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelbool">DataModelBool</a> 中的数据。</p>
<p>返回值：</p>
<ul>
<li>Bool - <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelbool">DataModelBool</a> 中类型为 Bool 的 <code>value</code> 数值。</li>
</ul>
<h2 id="class-datamodelfloat"><a class="header" href="#class-datamodelfloat">class DataModelFloat</a></h2>
<pre><code class="language-cangjie">public class DataModelFloat &lt;: DataModel {
    public init(fv: Float64)
    public init(v: Int64)
}
</code></pre>
<p>功能：此类为 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> 的子类，实现对 Float64 类型数据的封装。</p>
<p>父类型：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a></li>
</ul>
<h3 id="initfloat64-1"><a class="header" href="#initfloat64-1">init(Float64)</a></h3>
<pre><code class="language-cangjie">public init(fv: Float64)
</code></pre>
<p>功能：构造一个具有初始数据的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelfloat">DataModelFloat</a> 实例。</p>
<p>参数：</p>
<ul>
<li>fv: Float64 - 传入的 Float64 类型的数据。</li>
</ul>
<h3 id="initint64-2"><a class="header" href="#initint64-2">init(Int64)</a></h3>
<pre><code class="language-cangjie">public init(v: Int64)
</code></pre>
<p>功能：构造一个具有初始数据的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelfloat">DataModelFloat</a> 实例。</p>
<p>参数：</p>
<ul>
<li>v: Int64 - 传入的 Int64 类型的数据。</li>
</ul>
<h3 id="func-getvalue-5"><a class="header" href="#func-getvalue-5">func getValue()</a></h3>
<pre><code class="language-cangjie">public func getValue(): Float64
</code></pre>
<p>功能：获取 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelfloat">DataModelFloat</a> 中的数据。</p>
<p>返回值：</p>
<ul>
<li>Float64 - <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelfloat">DataModelFloat</a> 中类型为 Float64 的 <code>value</code> 数值。</li>
</ul>
<h2 id="class-datamodelint"><a class="header" href="#class-datamodelint">class DataModelInt</a></h2>
<pre><code class="language-cangjie">public class DataModelInt &lt;: DataModel {
    public init(iv: Int64)
}
</code></pre>
<p>功能：此类为 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> 的子类，实现对 Int64 类型数据的封装。</p>
<p>父类型：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a></li>
</ul>
<h3 id="initint64-3"><a class="header" href="#initint64-3">init(Int64)</a></h3>
<pre><code class="language-cangjie">public init(iv: Int64)
</code></pre>
<p>功能：构造一个具有初始数据的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelint">DataModelInt</a> 实例。</p>
<p>参数：</p>
<ul>
<li>iv: Int64 - 传入的 Int64 类型的数据。</li>
</ul>
<h3 id="func-getvalue-6"><a class="header" href="#func-getvalue-6">func getValue()</a></h3>
<pre><code class="language-cangjie">public func getValue(): Int64
</code></pre>
<p>功能：获取 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelint">DataModelInt</a> 中的数据。</p>
<p>返回值：</p>
<ul>
<li>Int64 - <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelint">DataModelInt</a> 中类型为 Int64 的 <code>value</code> 数值。</li>
</ul>
<h2 id="class-datamodelnull"><a class="header" href="#class-datamodelnull">class DataModelNull</a></h2>
<pre><code class="language-cangjie">public class DataModelNull &lt;: DataModel
</code></pre>
<p>功能：此类为 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> 的子类，实现对 <code>Null</code> 类型数据的封装。</p>
<p>父类型：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a></li>
</ul>
<h2 id="class-datamodelseq"><a class="header" href="#class-datamodelseq">class DataModelSeq</a></h2>
<pre><code class="language-cangjie">public class DataModelSeq &lt;: DataModel {
    public init()
    public init(list: ArrayList&lt;DataModel&gt;)
}
</code></pre>
<p>功能：此类为 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> 的子类，实现对 ArrayList&lt;<a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a>&gt; 类型数据的封装。</p>
<p>父类型：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a></li>
</ul>
<h3 id="init-25"><a class="header" href="#init-25">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个参数为空的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelseq">DataModelSeq</a> 实例。其中的数据默认为空的 ArrayList&lt;<a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a>&gt;。</p>
<h3 id="initarraylistdatamodel"><a class="header" href="#initarraylistdatamodel">init(ArrayList&lt;DataModel&gt;)</a></h3>
<pre><code class="language-cangjie">public init(list: ArrayList&lt;DataModel&gt;)
</code></pre>
<p>功能：构造一个具有初始数据的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelseq">DataModelSeq</a> 实例。</p>
<p>参数：</p>
<ul>
<li>list: ArrayList&lt;<a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a>&gt; - 传入的 ArrayList&lt;<a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a>&gt; 类型的数据。</li>
</ul>
<h3 id="func-adddatamodel"><a class="header" href="#func-adddatamodel">func add(DataModel)</a></h3>
<pre><code class="language-cangjie">public func add(dm: DataModel)
</code></pre>
<p>功能：在 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelseq">DataModelSeq</a> 末尾增加一个 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> 数据。</p>
<p>参数：</p>
<ul>
<li>dm: <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 传入的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> 类型的数据。</li>
</ul>
<h3 id="func-getitems-1"><a class="header" href="#func-getitems-1">func getItems()</a></h3>
<pre><code class="language-cangjie">public func getItems(): ArrayList&lt;DataModel&gt;
</code></pre>
<p>功能：获取 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelseq">DataModelSeq</a> 中的数据。</p>
<p>返回值：</p>
<ul>
<li>ArrayList&lt;<a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a>&gt; - <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelseq">DataModelSeq</a> 中的数据，类型为 ArrayList&lt;<a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a>&gt;。</li>
</ul>
<h2 id="class-datamodelstring"><a class="header" href="#class-datamodelstring">class DataModelString</a></h2>
<pre><code class="language-cangjie">public class DataModelString &lt;: DataModel {
    public init(sv: String)
}
</code></pre>
<p>功能：此类为 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> 的子类，实现对 String 类型数据的封装。</p>
<p>父类型：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a></li>
</ul>
<h3 id="initstring-17"><a class="header" href="#initstring-17">init(String)</a></h3>
<pre><code class="language-cangjie">public init(sv: String)
</code></pre>
<p>功能：构造一个具有初始数据的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelstring">DataModelString</a>。</p>
<p>参数：</p>
<ul>
<li>sv: String - 传入的 String 类型。</li>
</ul>
<h3 id="func-getvalue-7"><a class="header" href="#func-getvalue-7">func getValue()</a></h3>
<pre><code class="language-cangjie">public func getValue(): String
</code></pre>
<p>功能：获取 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelstring">DataModelString</a> 中的数据。</p>
<p>返回值：</p>
<ul>
<li>String - <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelstring">DataModelString</a> 中类型为 String 的 <code>value</code> 数值。</li>
</ul>
<h2 id="class-datamodelstruct"><a class="header" href="#class-datamodelstruct">class DataModelStruct</a></h2>
<pre><code class="language-cangjie">public class DataModelStruct &lt;: DataModel {
    public init()
    public init(list: ArrayList&lt;Field&gt;)
}
</code></pre>
<p>功能：此类为 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> 的子类，用来实现 <code>class</code> 对象到 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> 的转换。</p>
<p>父类型：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a></li>
</ul>
<h3 id="init-26"><a class="header" href="#init-26">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个空参的 <code>DataModelStructfields</code> 默认为空的 ArrayList&lt;<a href="serialization/serialization_package_api/serialization_package_classes.html#class-field">Field</a>&gt;。</p>
<h3 id="initarraylistfield"><a class="header" href="#initarraylistfield">init(ArrayList&lt;Field&gt;)</a></h3>
<pre><code class="language-cangjie">public init(list: ArrayList&lt;Field&gt;)
</code></pre>
<p>功能：构造一个具有初始数据的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelstruct">DataModelStruct</a>。</p>
<p>参数：</p>
<ul>
<li>list: ArrayList&lt;<a href="serialization/serialization_package_api/serialization_package_classes.html#class-field">Field</a>&gt; - 传入的 ArrayList&lt;<a href="serialization/serialization_package_api/serialization_package_classes.html#class-field">Field</a>&gt; 类型的数据。</li>
</ul>
<h3 id="func-addfield"><a class="header" href="#func-addfield">func add(Field)</a></h3>
<pre><code class="language-cangjie">public func add(fie: Field): DataModelStruct
</code></pre>
<p>功能：添加数据 <code>fie</code> 到 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelstruct">DataModelStruct</a> 中。</p>
<p>参数：</p>
<ul>
<li>fie: <a href="serialization/serialization_package_api/serialization_package_classes.html#class-field">Field</a> - 传入的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-field">Field</a> 类型的数据。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelstruct">DataModelStruct</a> - 得到新的 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelstruct">DataModelStruct</a>。</li>
</ul>
<h3 id="func-getstring-4"><a class="header" href="#func-getstring-4">func get(String)</a></h3>
<pre><code class="language-cangjie">public func get(key: String): DataModel
</code></pre>
<p>功能：获取 <code>key</code> 对应的数据。</p>
<p>参数：</p>
<ul>
<li>key: String - 传入的 String 类型。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 类型为 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a>，如未查找到对应值，则返回 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelnull">DataModelNull</a>。</li>
</ul>
<h3 id="func-getfields-1"><a class="header" href="#func-getfields-1">func getFields()</a></h3>
<pre><code class="language-cangjie">public func getFields(): ArrayList&lt;Field&gt;
</code></pre>
<p>功能：获取 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelstruct">DataModelStruct</a> 的数据集合。</p>
<p>返回值：</p>
<ul>
<li>ArrayList&lt;<a href="serialization/serialization_package_api/serialization_package_classes.html#class-field">Field</a>&gt; - 类型为 ArrayList&lt;<a href="serialization/serialization_package_api/serialization_package_classes.html#class-field">Field</a>&gt; 的数据集合。</li>
</ul>
<h2 id="class-field"><a class="header" href="#class-field">class Field</a></h2>
<pre><code class="language-cangjie">public class Field {
    public init(name: String, data: DataModel)
}
</code></pre>
<p>功能：用于存储 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodelstruct">DataModelStruct</a> 的元素。</p>
<h3 id="initstring-datamodel"><a class="header" href="#initstring-datamodel">init(String, DataModel)</a></h3>
<pre><code class="language-cangjie">public init(name: String, data: DataModel)
</code></pre>
<p>功能：<a href="serialization/serialization_package_api/serialization_package_classes.html#class-field">Field</a> 的构造函数。</p>
<p>参数：</p>
<ul>
<li>name: String - <code>name</code> 字段值，<code>name</code> 字段为 <code>&quot;&quot;</code> 时行为与为其它字符串时一致。</li>
<li>data: <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - <code>data</code> 字段值。</li>
</ul>
<h3 id="func-getdata"><a class="header" href="#func-getdata">func getData()</a></h3>
<pre><code class="language-cangjie">public func getData(): DataModel
</code></pre>
<p>功能：获取 <code>data</code> 字段。</p>
<p>返回值：</p>
<ul>
<li><a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> - 获取到的 <code>data</code> 字段，类型为 <a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a>。</li>
</ul>
<h3 id="func-getname"><a class="header" href="#func-getname">func getName()</a></h3>
<pre><code class="language-cangjie">public func getName(): String
</code></pre>
<p>功能：获取 <code>name</code> 字段。</p>
<p>返回值：</p>
<ul>
<li>String - 获取到的 <code>name</code> 字段，类型为 String。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="异常类-20"><a class="header" href="#异常类-20">异常类</a></h1>
<h2 id="class-datamodelexception"><a class="header" href="#class-datamodelexception">class DataModelException</a></h2>
<pre><code class="language-cangjie">public class DataModelException &lt;: Exception {
    public init()
    public init(message: String)
}
</code></pre>
<p>功能：<a href="serialization/serialization_package_api/serialization_package_classes.html#class-datamodel">DataModel</a> 的异常类。</p>
<p>父类型：</p>
<ul>
<li>Exception</li>
</ul>
<h3 id="init-27"><a class="header" href="#init-27">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：创建 <a href="serialization/serialization_package_api/serialization_package_exceptions.html#class-datamodelexception">DataModelException</a> 实例。</p>
<h3 id="initstring-18"><a class="header" href="#initstring-18">init(String)</a></h3>
<pre><code class="language-cangjie">public init(message: String)
</code></pre>
<p>功能：根据异常信息创建 <a href="serialization/serialization_package_api/serialization_package_exceptions.html#class-datamodelexception">DataModelException</a> 实例。</p>
<p>参数：</p>
<ul>
<li>message: String - 异常信息提示字符串。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-序列化和反序列化"><a class="header" href="#class-序列化和反序列化">class 序列化和反序列化</a></h1>
<!-- verify -->
<pre><code class="language-cangjie">import stdx.serialization.serialization.*
import std.math.*
import stdx.encoding.json.*

/* 通过实现 Serializable 接口，来实现对自定义类型的序列化和反序列化功能 */
class Abc &lt;: Serializable&lt;Abc&gt; {
    var name: String = &quot;Abcde&quot;
    var age: Int64 = 555
    var loc: Option&lt;Location&gt; = Option&lt;Location&gt;.None

    /* 实现 Serializable 接口的序列化方法 */
    public func serialize(): DataModel {
        return DataModelStruct().add(field&lt;String&gt;(&quot;name&quot;, name)).add(field&lt;Int64&gt;(&quot;age&quot;, age)).add(field&lt;Option&lt;Location&gt;&gt;(&quot;loc&quot;, loc))
    }

    /* 实现反序列化方法 */
    public static func deserialize(dm: DataModel): Abc {
        let dms = match (dm) {
            case data: DataModelStruct =&gt; data
            case _ =&gt; throw Exception(&quot;this data is not DataModelStruct&quot;)
        }
        let result = Abc()
        result.name = String.deserialize(dms.get(&quot;name&quot;))
        result.age = Int64.deserialize(dms.get(&quot;age&quot;))
        result.loc = Option&lt;Location&gt;.deserialize(dms.get(&quot;loc&quot;))
        return result
    }
}

class Location &lt;: Serializable&lt;Location&gt; {
    var time: Int64 = 666
    var heheh: Rune = 'T'

    /* 实现 Serializable 接口的序列化方法 */
    public func serialize(): DataModel {
        return DataModelStruct().add(field&lt;Int64&gt;(&quot;time&quot;, time)).add(field&lt;Rune&gt;(&quot;heheh&quot;, heheh))
    }

    /* 实现反序列化方法 */
    public static func deserialize(dm: DataModel): Location {
        let dms = match (dm) {
            case data: DataModelStruct =&gt; data
            case _ =&gt; throw Exception(&quot;this data is not DataModelStruct&quot;)
        }
        let result = Location()
        result.time = Int64.deserialize(dms.get(&quot;time&quot;))
        result.heheh = Rune.deserialize(dms.get(&quot;heheh&quot;))
        return result
    }
}

main(): Unit {
    let dd = Abc()
    let aa: JsonValue = dd.serialize().toJson()
    let bb: JsonObject = (aa as JsonObject).getOrThrow()
    let v1 = (bb.get(&quot;name&quot;).getOrThrow() as JsonString).getOrThrow()
    let v2 = (bb.get(&quot;age&quot;).getOrThrow() as JsonInt).getOrThrow()
    let v3 = bb.get(&quot;loc&quot;).getOrThrow()
    println(v1.getValue())
    println(v2.getValue())
    println(v3.toString())
    println(&quot;===========&quot;)
    let aaa = ##&quot;{&quot;age&quot;: 123, &quot;loc&quot;: { &quot;heheh&quot;: &quot;H&quot;, &quot;time&quot;: 45 }, &quot;name&quot;: &quot;zhangsan&quot;}&quot;##
    let bbb = JsonValue.fromStr(aaa)
    let ccc = (bbb as JsonObject).getOrThrow()
    let v4 = (ccc.get(&quot;name&quot;).getOrThrow() as JsonString).getOrThrow()
    let v5 = (ccc.get(&quot;age&quot;).getOrThrow() as JsonInt).getOrThrow()
    let v6 = (ccc.get(&quot;loc&quot;).getOrThrow() as JsonObject).getOrThrow()
    let v7 = (v6.get(&quot;time&quot;).getOrThrow() as JsonInt).getOrThrow()
    let v8 = (v6.get(&quot;heheh&quot;).getOrThrow() as JsonString).getOrThrow()
    println(v4.getValue())
    println(v5.getValue())
    println(v7.getValue())
    println(v8.getValue())
}
</code></pre>
<p>运行结果如下：</p>
<pre><code class="language-text">Abcde
555
null
===========
zhangsan
123
45
H
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashset-和-hashmap-序列化"><a class="header" href="#hashset-和-hashmap-序列化">HashSet 和 HashMap 序列化</a></h1>
<!-- verify -->
<pre><code class="language-cangjie">import std.collection.*
import stdx.serialization.serialization.*
import stdx.encoding.json.*

main(): Unit {
    let s: HashSet&lt;Values&gt; = HashSet&lt;Values&gt;([Values(3), Values(5), Values(7)])
    let seris: DataModel = s.serialize()
    println(seris.toJson().toJsonString())
    println(&quot;===========&quot;)
    let m: HashMap&lt;String, Values&gt; = HashMap&lt;String, Values&gt;([(&quot;1&quot;, Values(3)), (&quot;2&quot;, Values(6)), (&quot;3&quot;, Values(9))])
    let serim: DataModel = m.serialize()
    print(serim.toJson().toJsonString())
}

class Values &lt;: Hashable &amp; Equatable&lt;Values&gt; &amp; Serializable&lt;Values&gt; {
    var m_data: Int64

    init(m_data: Int64) {
        this.m_data = m_data
    }

    public func hashCode(): Int64 {
        return this.m_data
    }

    public operator func ==(right: Values): Bool {
        let a = (this.m_data == right.m_data)
        if (a) { return true } else { return false }
    }

    public operator func !=(right: Values): Bool {
        let a = (this.m_data != right.m_data)
        if (a) { return true } else { return false }
    }

    /* 实现 Serializable 接口的序列化方法 */
    public func serialize(): DataModel {
        return DataModelStruct().add(field&lt;Int64&gt;(&quot;m_data&quot;, m_data))
    }

    /* 实现反序列化方法 */
    public static func deserialize(dm: DataModel): Values {
        let dms: DataModelStruct = match (dm) {
            case data: DataModelStruct =&gt; data
            case _ =&gt; throw Exception(&quot;this data is not DataModelStruct&quot;)
        }
        let result = Values(0)
        result.m_data = Int64.deserialize(dms.get(&quot;m_data&quot;))
        return result
    }
}
</code></pre>
<p>运行结果如下：</p>
<pre><code class="language-text">[
  {
    &quot;m_data&quot;: 3
  },
  {
    &quot;m_data&quot;: 5
  },
  {
    &quot;m_data&quot;: 7
  }
]
===========
{
  &quot;1&quot;: {
    &quot;m_data&quot;: 3
  },
  &quot;2&quot;: {
    &quot;m_data&quot;: 6
  },
  &quot;3&quot;: {
    &quot;m_data&quot;: 9
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdxunittestdata"><a class="header" href="#stdxunittestdata">stdx.unittest.data</a></h1>
<h2 id="功能介绍-16"><a class="header" href="#功能介绍-16">功能介绍</a></h2>
<p>unittest.data 库用于在编写仓颉项目单元测试代码时提供输入序列化格式的测试数据的能力，当前支持 json/csv/tsv 等格式。</p>
<p>标准测试能力可参考标准库 API 文档。</p>
<h2 id="api-列表-15"><a class="header" href="#api-列表-15">API 列表</a></h2>
<h3 id="函数-10"><a class="header" href="#函数-10">函数</a></h3>
<div class="table-wrapper"><table><thead><tr><th>函数名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="unittest/data/./data_package_api/data_package_functions.html#func-csvtstring-rune-rune-rune-optionrune-optionarraystring-arrayuint64-arrayuint64-bool-where-t--serializablet">csv&lt;T&gt;(String, Rune, Rune, Rune, Option&lt;Rune&gt;, Option&lt;Array&lt;String&gt;&gt;, Array&lt;UInt64&gt;, Array&lt;UInt64&gt;, Bool)</a></td><td>该函数可从 csv 文件中读取类型 T 的数据值，其中 T 必须可被序列化。该函数的返回值是参数化测试的一种参数源。</td></tr>
<tr><td><a href="unittest/data/./data_package_api/data_package_functions.html#func-jsontstring-where-t--serializablet">json&lt;T&gt;(String)</a></td><td>该函数可从 JSON 文件中读取类型 T 的数据值，其中 T 必须可被序列化。该函数的返回值是参数化测试的一种参数源。</td></tr>
<tr><td><a href="unittest/data/./data_package_api/data_package_functions.html#func-tsvtstring-rune-rune-optionrune-optionarraystring-arrayuint64-arrayuint64-bool-where-t--serializablet">tsv&lt;T&gt;(String, Rune, Rune, Option&lt;Rune&gt;, Option&lt;Array&lt;String&gt;&gt;, Array&lt;UInt64&gt;, Array&lt;UInt64&gt;, Bool)</a></td><td>该函数可从 tsv 文件中读取类型 T 的数据值，其中 T 必须可被序列化。该函数的返回值是参数化测试的一种参数源。</td></tr>
</tbody></table>
</div>
<h3 id="类-27"><a class="header" href="#类-27">类</a></h3>
<div class="table-wrapper"><table><thead><tr><th>类名</th><th>功能</th></tr></thead><tbody>
<tr><td><a href="unittest/data/./data_package_api/data_package_classes.html#class-csvstrategy">CsvStrategy</a></td><td><code>DataStrategy</code> 对 CSV 数据格式的序列化实现。</td></tr>
<tr><td><a href="unittest/data/./data_package_api/data_package_classes.html#class-jsonstrategy">JsonStrategy</a></td><td><code>DataStrategy</code> 对 JSON 数据格式的序列化实现。</td></tr>
<tr><td><a href="unittest/data/./data_package_api/data_package_classes.html#class-serializableprovider">SerializableProvider</a></td><td>获取序列化数据 DataProvider 接口的实现。</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h2 id="func-csvtstring-rune-rune-rune-optionrune-optionarraystring-arrayuint64-arrayuint64-bool-where-t--serializablet"><a class="header" href="#func-csvtstring-rune-rune-rune-optionrune-optionarraystring-arrayuint64-arrayuint64-bool-where-t--serializablet">func csv&lt;T&gt;(String, Rune, Rune, Rune, Option&lt;Rune&gt;, Option&lt;Array&lt;String&gt;&gt;, Array&lt;UInt64&gt;, Array&lt;UInt64&gt;, Bool) where T &lt;: Serializable&lt;T&gt;</a></h2>
<pre><code class="language-cangjie">public func csv&lt;T&gt;(
 fileName: String,
 delimiter!: Rune = ',',
 quoteChar!: Rune = '&quot;',
 escapeChar!: Rune = '&quot;',
 commentChar!: Option&lt;Rune&gt; = None,
 header!: Option&lt;Array&lt;String&gt;&gt; = None,
 skipRows!: Array&lt;UInt64&gt; = [],
 skipColumns!: Array&lt;UInt64&gt; = [],
 skipEmptyLines!: Bool = false
): CsvStrategy&lt;T&gt; where T &lt;: Serializable&lt;T&gt;
</code></pre>
<p>功能：该函数可从 csv 文件中读取类型 T 的数据值，其中 T 必须可被序列化。该函数的返回值是参数化测试的一种参数源。</p>
<p>参数：</p>
<ul>
<li>fileName: String - CSV 格式的文件地址，可为相对地址，不限制后缀名。</li>
<li>delimiter!: Rune - 一行中作为元素分隔符的符号。默认值为 <code>,</code> （逗号）。</li>
<li>quoteChar!: Rune - 括住元素的符号。默认值为 <code>&quot;</code> （双引号）。</li>
<li>escapeChar!: Rune ：转义括住元素的符号。默认值为 <code>&quot;</code> （双引号）。</li>
<li>commentChar!: Option&lt;Rune&gt; - 注释符号，跳过一行。必须在一行的最左侧。默认值是 <code>None</code> (不存在注释符号)。</li>
<li>header!: Option&lt;Array&lt;String&gt;&gt; - 提供一种方式覆盖第一行。
<ul>
<li>当 header 被指定时，文件的第一行将被作为数据行，指定的 header 将被使用。</li>
<li>当 header 被指定，同时第一行通过指定 <code>skipRows</code> 被跳过时，第一行将被忽略，指定的 header 将被使用。</li>
<li>当 header 未被指定时，即值为 <code>None</code> 时，文件的第一行将被作为表头。此为默认值。</li>
</ul>
</li>
<li>skipRows!: Array&lt;UInt64&gt; - 指定需被跳过的数据行号，行号从 0 开始。默认值为空数组 <code>[]</code> 。</li>
<li>skipColumns!: Array&lt;UInt64&gt; - 指定需被跳过的数据列号，列号从 0 开始。当有数据列被跳过，并且用户指定了自定义的 header 时，该 header 将按照跳过后的实际数据列对应。默认值为空数据 <code>[]</code> 。</li>
<li>skipEmptyLines!: Bool - 指定是否需要跳过空行。默认值为 <code>false</code> 。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="unittest/data/data_package_api/data_package_classes.html#class-csvstrategy">CsvStrategy</a>&lt;T&gt; 对象，T 可被序列化，数据值从 CSV 文件中读取。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalStateException - 如果 CSV 数据的结构不正确，则抛出该异常。</li>
</ul>
<h2 id="func-jsontstring-where-t--serializablet"><a class="header" href="#func-jsontstring-where-t--serializablet">func json&lt;T&gt;(String) where T &lt;: Serializable&lt;T&gt;</a></h2>
<pre><code class="language-cangjie">public func json&lt;T&gt;(fileName: String): JsonStrategy&lt;T&gt; where T &lt;: Serializable&lt;T&gt;
</code></pre>
<p>功能：该函数可从 JSON 文件中读取类型 T 的数据值，其中 T 必须可被序列化。该函数的返回值是参数化测试的一种参数源。</p>
<p>参数：</p>
<ul>
<li>fileName: String - JSON 格式的文件地址，可为相对地址。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="unittest/data/data_package_api/data_package_classes.html#class-jsonstrategy">JsonStrategy</a>&lt;T&gt; - T 可被序列化，数据值从 JSON 文件中读取。</li>
</ul>
<p>示例：</p>
<pre><code class="language-cangjie">@Test[user in json(&quot;users.json&quot;)]
func test_user_age(user: User): Unit {
    @Expect(user.age, 100)
}
</code></pre>
<p>json 文件示例：</p>
<pre><code class="language-json">[
    {
        &quot;age&quot;: 100
    },
    {
        &quot;age&quot;: 100
    }
]
</code></pre>
<p>创建一种被用作测试函数参数的类，该类实现接口 <a href="unittest/data/data_package_api/../../../serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a> 。</p>
<!--compile-->
<pre><code class="language-cangjie">import stdx.serialization.serialization.*
import std.convert.*
class User &lt;: Serializable&lt;User&gt; {
    User(let age: Int64) {}

    public func serialize(): DataModel {
        DataModelStruct()
          .add(Field(&quot;age&quot;, DataModelInt(age)))
    }

    public static func deserialize(dm: DataModel): User {
        if (let Some(dms) &lt;- (dm as DataModelStruct)) {
          if (let Some(age) &lt;- (dms.get(&quot;age&quot;) as DataModelInt)) {
            return User(age.getValue())
          }
        }

        throw Exception(&quot;Can't deserialize user.&quot;)
    }
}
</code></pre>
<p>任何实现 <a href="unittest/data/data_package_api/../../../serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a> 的类型都可以用作参数类型，包括默认值：</p>
<pre><code class="language-cangjie">@Test[user in json(&quot;numbers.json&quot;)]
func test(value: Int64)
</code></pre>
<pre><code class="language-cangjie">@Test[user in json(&quot;names.json&quot;)]
func test(name: String)
</code></pre>
<h2 id="func-tsvtstring-rune-rune-optionrune-optionarraystring-arrayuint64-arrayuint64-bool-where-t--serializablet"><a class="header" href="#func-tsvtstring-rune-rune-optionrune-optionarraystring-arrayuint64-arrayuint64-bool-where-t--serializablet">func tsv&lt;T&gt;(String, Rune, Rune, Option&lt;Rune&gt;, Option&lt;Array&lt;String&gt;&gt;, Array&lt;UInt64&gt;, Array&lt;UInt64&gt;, Bool) where T &lt;: Serializable&lt;T&gt;</a></h2>
<pre><code class="language-cangjie">public func tsv&lt;T&gt;(
    fileName: String,
    quoteChar!: Rune = '&quot;',
    escapeChar!: Rune = '&quot;',
    commentChar!: Option&lt;Rune&gt; = None,
    header!: Option&lt;Array&lt;String&gt;&gt; = None,
    skipRows!: Array&lt;UInt64&gt; = [],
    skipColumns!: Array&lt;UInt64&gt; = [],
    skipEmptyLines!: Bool = false
): CsvStrategy&lt;T&gt; where T &lt;: Serializable&lt;T&gt;
</code></pre>
<p>功能：该函数可从 tsv 文件中读取类型 T 的数据值，其中 T 必须可被序列化。该函数的返回值是参数化测试的一种参数源。</p>
<p>参数:</p>
<ul>
<li>fileName: String - TSV 格式的文件地址，可为相对地址，不限制后缀名。</li>
<li>quoteChar!: Rune - 括住元素的符号。默认值为 <code>&quot;</code> （双引号）。</li>
<li>escapeChar!: Rune - 转义括住元素的符号。默认值为 <code>&quot;</code> （双引号）。</li>
<li>commentChar!: Option&lt;Rune&gt; - 注释符号，跳过一行。必须在一行的最左侧。默认值是 <code>None</code> (不存在注释符号)。</li>
<li>header!: Option&lt;Array&lt;String&gt;&gt; - 提供一种方式覆盖第一行。
<ul>
<li>当 header 被指定时，文件的第一行将被作为数据行，指定的 header 将被使用。</li>
<li>当 header 被指定，同时第一行通过指定 <code>skipRows</code> 被跳过时，第一行将被忽略，指定的 header 将被使用。</li>
<li>当 header 未被指定时，即值为 <code>None</code> 时，文件的第一行（跳过后的实际数据）将被作为表头。此为默认值。</li>
</ul>
</li>
<li>skipRows!: Array&lt;UInt64&gt; - 指定需被跳过的数据行号，行号从 0 开始。默认值为空数组 <code>[]</code> 。</li>
<li>skipColumns!: Array&lt;UInt64&gt; - 指定需被跳过的数据列号，列号从 0 开始。当有数据列被跳过，并且用户指定了自定义的 header 时，该 header 将按照跳过后的实际数据列对应。默认值为空数据 <code>[]</code> 。</li>
<li>skipEmptyLines!: Bool - 指定是否需要跳过空行。默认值为 <code>false</code> 。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="unittest/data/data_package_api/data_package_classes.html#class-csvstrategy">CsvStrategy</a>&lt;T&gt; - T 可被序列化，数据值从 TSV 文件中读取。</li>
</ul>
<p>异常：</p>
<ul>
<li>IllegalStateException - 如果 TSV 数据的结构不正确，则抛出该异常。</li>
</ul>
<p>示例：</p>
<p>在单元测试中，可以通过传入 csv/tsv 文件地址进行参数化测试。</p>
<p>CSV 文件每一行的数据应当被表示成一个 <a href="unittest/data/data_package_api/../../../serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a>&lt;T&gt; 对象，它的成员名是文件每一列头的值，成员值是 <a href="unittest/data/data_package_api/../../../serialization/serialization_package_api/serialization_package_classes.html#class-datamodelstring">DataModelString</a> 类型的对应列号上的值。</p>
<p>举例来说，有一个 <code>testdata.csv</code> 文件，具有如下内容：</p>
<pre><code class="language-csv">username,age
Alex Great,21
Donald Sweet,28
</code></pre>
<p>有几种方式可以序列化上述数据：</p>
<ol>
<li>
<p>将数据表示为 HashMap&lt;String, String&gt; 类型。</p>
<p>具体示例为：</p>
<!--compile-->
<pre><code class="language-cangjie">import std.collection.HashMap
import std.unittest.*
import std.unittest.testmacro.*

@Test[user in csv(&quot;testdata.csv&quot;)]
func testUser(user: HashMap&lt;String, String&gt;) {
    @Assert(user[&quot;username&quot;] == &quot;Alex Great&quot; || user[&quot;username&quot;] == &quot;Donald Sweet&quot;)
    @Assert(user[&quot;age&quot;] == &quot;21&quot; || user[&quot;age&quot;] == &quot;28&quot;)
}
</code></pre>
</li>
<li>
<p>将数据表示为 <a href="unittest/data/data_package_api/../../../serialization/serialization_package_api/serialization_package_interfaces.html#interface-serializable">Serializable</a>&lt;T&gt; 类型数据，其 String 类型的数据可被反序列化为 <a href="unittest/data/data_package_api/../../../serialization/serialization_package_api/serialization_package_classes.html#class-datamodelstruct">DataModelStruct</a> 格式对象。</p>
</li>
</ol>
<p>具体示例为：</p>
<!--compile-->
<pre><code class="language-cangjie">import serialization.serialization.*
import std.convert.*
import std.unittest.*
import std.unittest.testmacro.*

public class User &lt;: Serializable&lt;User&gt; {
    public User(let name: String, let age: UInt32) {}

    public func serialize(): DataModel {
        let dms = DataModelStruct()
        dms.add(Field(&quot;username&quot;, DataModelString(name)))
        dms.add(Field(&quot;age&quot;, DataModelString(age.toString())))
        return dms
    }

    static public func deserialize(dm: DataModel): User {
        var data: DataModelStruct = match (dm) {
            case dms: DataModelStruct =&gt; dms
            case _ =&gt; throw DataModelException(&quot;this data is not DataModelStruct&quot;)
        }

        let name = String.deserialize(data.get(&quot;username&quot;))
        let age = String.deserialize(data.get(&quot;age&quot;))
        return User(name, UInt32.parse(age))
    }
}

@Test[user in csv(&quot;testdata.csv&quot;)]
func testUser(user: User) {
   @Assert(user.name == &quot;Alex Great&quot; || user.name == &quot;Donald Sweet&quot;)
   @Assert(user.age == 21 || user.age == 28)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="class-csvstrategy"><a class="header" href="#class-csvstrategy">class CsvStrategy</a></h2>
<pre><code class="language-cangjie">public class CsvStrategy&lt;T&gt; &lt;: DataStrategy&lt;T&gt; where T &lt;: Serializable&lt;T&gt; {}
</code></pre>
<p>功能：DataStrategy 对 CSV 数据格式的序列化实现。</p>
<p>父类型：</p>
<ul>
<li>DataStrategy&lt;T&gt;</li>
</ul>
<h3 id="func-providerconfiguration"><a class="header" href="#func-providerconfiguration">func provider(Configuration)</a></h3>
<pre><code class="language-cangjie">public override func provider(configuration: Configuration): SerializableProvider&lt;T&gt;
</code></pre>
<p>功能：生成序列化数据迭代器。</p>
<p>参数：</p>
<ul>
<li>configuration: Configuration - 数据配置信息。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="unittest/data/data_package_api/data_package_classes.html#class-serializableprovider">SerializableProvider</a>&lt;T&gt; - 序列化迭代器对象。</li>
</ul>
<h2 id="class-jsonstrategy"><a class="header" href="#class-jsonstrategy">class JsonStrategy</a></h2>
<pre><code class="language-cangjie">public class JsonStrategy&lt;T&gt; &lt;: DataStrategy&lt;T&gt; where T &lt;: Serializable&lt;T&gt; {}
</code></pre>
<p>功能：DataStrategy 对 JSON 数据格式的序列化实现。</p>
<p>父类型：</p>
<ul>
<li>DataStrategy&lt;T&gt;</li>
</ul>
<h3 id="func-providerconfiguration-1"><a class="header" href="#func-providerconfiguration-1">func provider(Configuration)</a></h3>
<pre><code class="language-cangjie">public override func provider(configuration: Configuration): SerializableProvider&lt;T&gt;
</code></pre>
<p>功能：生成序列化数据迭代器。</p>
<p>参数：</p>
<ul>
<li>configuration: Configuration - 数据配置信息。</li>
</ul>
<p>返回值：</p>
<ul>
<li>SerializableProvider&lt;T&gt; - 序列化迭代器对象。</li>
</ul>
<h2 id="class-serializableprovider"><a class="header" href="#class-serializableprovider">class SerializableProvider</a></h2>
<pre><code class="language-cangjie">public class SerializableProvider&lt;T&gt; &lt;: DataProvider&lt;T&gt; where T &lt;: Serializable&lt;T&gt; {}
</code></pre>
<p>功能：获取序列化数据 DataProvider 接口的实现。</p>
<p>父类型：</p>
<ul>
<li>DataProvider&lt;T&gt;</li>
</ul>
<h3 id="prop-isinfinite"><a class="header" href="#prop-isinfinite">prop isInfinite</a></h3>
<pre><code class="language-cangjie">public prop isInfinite: Bool
</code></pre>
<p>功能：是否生成无限的数据。</p>
<p>Bool。</p>
<h3 id="func-provide"><a class="header" href="#func-provide">func provide()</a></h3>
<pre><code class="language-cangjie">public override func provide(): Iterable&lt;T&gt; 
</code></pre>
<p>功能：获取数据迭代器。</p>
<p>返回值：</p>
<ul>
<li>Iterable&lt;T&gt; - 数据迭代器。</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="cangjie-highlight-export.js"></script><script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        
        <script src="cangjie-highlight-export.js"></script><script src="highlight.js"></script>
        <script src="assets/elasticlunr.js"></script>
        <script src="assets/fzf.umd.js"></script>
        <script src="assets/sidebar.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
